var tipuesearch = {"pages":[{"text":"Fortran Program Hi, my name is Son Tung Dang. This is a project which I wrote. This file will provide the documents. I'm\nwriting the body of the text here. It contains an overall description of the\nproject. It might explain how to go about installing/compiling it. It might\nprovide a change-log for the code. linalg Maybe it will talk about the\nhistory and/or motivation for this software. Note You can include any notes (or bugs, warnings, or todos) like so. Bug You can have multi-paragraph versions of these too! That means you can\ninclude ordered lists unordered lists images etc. Bug Hey I'm doing it again... Developer Info Son Tung Dang I program cut-cell and clsvof in Fortran.","tags":"home","loc":"index.html","title":" Fortran Program "},{"text":"Contents Modules vtk Source Code VTK_mod.f90 Source Code module vtk !! VTK_mod.f90 --- VTK data file format !! !! Auteur          : Jalel Chergui (LIMSI-CNRS) <Jalel.Chergui@limsi.fr> !! Dern. mod. par  : Jalel Chergui (LIMSI-CNRS) <Jalel.Chergui@limsi.fr> !! Dern. mod. le   : Wed Sep 16 14:35:06 2009 use PrecisionVar IMPLICIT NONE PRIVATE INTEGER , PARAMETER :: s = selected_real_kind ( 6 ) INTEGER , PARAMETER :: d = selected_real_kind ( 12 ) character ( len = 1 ), PARAMETER :: newline = achar ( 10 ) INTEGER :: iproc = 0 , nb_procs = 1 TYPE , PUBLIC :: VTK_file_handle PRIVATE character ( len = 80 ) :: prefix INTEGER :: unit INTEGER :: ni , nj , nk INTEGER :: counter = 0 INTEGER :: restart = 0 logical :: first = . true . end TYPE VTK_file_handle PRIVATE :: handle_error , handle_warning , handle_info PRIVATE :: VTK_write_mesh_2d , VTK_write_mesh_3d , & VTK_write_vector_2d , VTK_write_vector_3d , & VTK_write_scalar_2d , VTK_write_scalar_3d PUBLIC :: VTK_open_file , & VTK_write_mesh , & VTK_write_var , & VTK_close_file , & VTK_collect_file interface VTK_write_mesh module procedure VTK_write_mesh_2d , VTK_write_mesh_3d end interface interface VTK_write_var module procedure VTK_write_scalar_2d , VTK_write_scalar_3d , & VTK_write_vector_2d , VTK_write_vector_3d end interface contains subroutine handle_error ( name , message ) !! The subroutine is used to print out the error with opening or writting vtk file IMPLICIT NONE character ( len =* ), INTENT ( IN ) :: name , message !! The error message print '(/,\"   *** Error *** \", A,\": \", A,/)' , name , message stop end subroutine handle_error subroutine handle_warning ( name , message ) !! The subroutine is used to print out the warning with opening or writting vtk file IMPLICIT NONE character ( len =* ), INTENT ( IN ) :: name , message !! The warning message print '(/,\"   *** Warning *** \",A,\": \", A,/)' , name , message end subroutine handle_warning subroutine handle_info ( name , message ) !! The subroutine is used to print out the information about the opening or writting vtk file IMPLICIT NONE character ( len =* ), INTENT ( IN ) :: name , message !! The info message print '(/,\"   *** Info *** \",A,\": \", A,/)' , name , message end subroutine handle_info subroutine VTK_open_file ( prefix , proc_rank , num_procs , restart , fd ) !! The subroutine is used to open a .vtk file IMPLICIT NONE character ( len =* ), INTENT ( IN ) :: prefix !! The directory where the output files are stored INTEGER , optional , INTENT ( IN ) :: proc_rank , num_procs , restart !! Arguments for MPI TYPE ( VTK_file_handle ), INTENT ( INOUT ) :: fd !! The character ( len = 10 ) :: rank , snapshot character ( len = 80 ) :: f character ( len = 256 ) :: MAIN_header INTEGER :: err logical :: file_opened ! Looking for a none connected logical file unit. fd % prefix = trim ( prefix ) fd % unit = 99 inquire ( unit = fd % unit , opened = file_opened ) do while ( file_opened . and . fd % unit /= 0 ) fd % unit = fd % unit - 1 inquire ( unit = fd % unit , opened = file_opened ) end do if ( fd % unit == 0 . and . file_opened ) then call handle_error ( \"VTK_open_file\" , \"All file units from 0 to 99 are already connected.\" ) stop else if ( present ( proc_rank ) . and . present ( num_procs ) ) then iproc = proc_rank nb_procs = num_procs else if ( present ( proc_rank ) ) then call handle_error ( \"VTK_open_file\" , \"Both PROC_RANK and NUM_PROCS arguments must be present.\" ) else if ( present ( num_procs ) ) then call handle_error ( \"VTK_open_file\" , \"Both PROC_RANK and NUM_PROCS arguments must be present.\" ) end if if (( fd % first ) . and . ( present ( restart ))) then fd % restart = restart fd % counter = restart fd % first = . false . end if fd % counter = fd % counter + 1 write ( snapshot , '(i8.8)' ) fd % counter if ( present ( proc_rank ) ) then write ( rank , '(i8)' ) iproc f = trim ( fd % prefix ) // \"_\" // trim ( adjustl ( rank )) // \"_\" // trim ( adjustl ( snapshot )) // \".vtk\" else f = trim ( fd % prefix ) // \"_\" // trim ( adjustl ( snapshot )) // \".vtk\" end if open ( unit = fd % unit , file = trim ( adjustl ( f )), form = \"UNFORMATTED\" , access = \"STREAM\" , status = \"replace\" , & action = \"write\" , iostat = err ) if ( err /= 0 ) print '(\"Problem creating file \",a,\".\")' , trim ( f ) end if MAIN_header = \"# vtk DataFile Version 2.0\" // newline // \"(c) J.C. April 2009\" // newline // \"BINARY\" // newline write ( unit = fd % unit ) trim ( MAIN_header ) end subroutine VTK_open_file subroutine VTK_write_mesh_2d ( fd , x , y ) IMPLICIT NONE TYPE ( VTK_file_handle ), INTENT ( INOUT ) :: fd REAL ( KIND = dp ), INTENT ( IN ), DIMENSION (:) :: x , y character ( len = 30 ) :: buf1 , buf2 character ( len = 256 ) :: GRID_header INTEGER , PARAMETER :: nk = 1 fd % ni = size ( x ) ; fd % nj = size ( y ) write ( buf1 , '(i8,\" \",i8,\" \",i8)' ) fd % ni , fd % nj , fd % nk GRID_header = \"DATASET RECTILINEAR_GRID\" // newline // \"DIMENSIONS \" // trim ( adjustl ( buf1 )) // newline write ( unit = fd % unit ) trim ( GRID_header ) write ( buf2 , '(i8)' ) fd % ni GRID_header = \"X_COORDINATES \" // trim ( adjustl ( buf2 )) // \" float\" // newline write ( unit = fd % unit ) trim ( GRID_header ), real ( x ( 1 : fd % ni ), kind = s ), newline write ( buf2 , '(i8)' ) fd % nj GRID_header = \"Y_COORDINATES \" // trim ( adjustl ( buf2 )) // \" float\" // newline write ( unit = fd % unit ) trim ( GRID_header ), real ( y ( 1 : fd % nj ), kind = s ), newline write ( buf2 , '(i8)' ) fd % nk GRID_header = \"Z_COORDINATES \" // trim ( adjustl ( buf2 )) // \" float\" // newline write ( unit = fd % unit ) trim ( GRID_header ), real ( 0.0 _ d , kind = s ), newline write ( buf2 , '(i8)' ) fd % ni * fd % nj GRID_header = \"POINT_DATA \" // trim ( adjustl ( buf2 )) // newline write ( unit = fd % unit ) trim ( GRID_header ) end subroutine VTK_write_mesh_2d subroutine VTK_write_mesh_3d ( fd , x , y , z ) IMPLICIT NONE TYPE ( VTK_file_handle ), INTENT ( INOUT ) :: fd REAL ( KIND = dp ), INTENT ( IN ), DIMENSION (:) :: x , y , z character ( len = 30 ) :: buf1 , buf2 character ( len = 256 ) :: GRID_header fd % ni = size ( x ) ; fd % nj = size ( y ) ; fd % nk = size ( z ) write ( buf1 , '(i8,\" \",i8,\" \",i8)' ) fd % ni , fd % nj , fd % nk GRID_header = \"DATASET RECTILINEAR_GRID\" // newline // \"DIMENSIONS \" // trim ( adjustl ( buf1 )) // newline write ( unit = fd % unit ) trim ( GRID_header ) write ( buf2 , '(i8)' ) fd % ni GRID_header = \"X_COORDINATES \" // trim ( adjustl ( buf2 )) // \" float\" // newline write ( unit = fd % unit ) trim ( GRID_header ), real ( x ( 1 : fd % ni ), kind = s ), newline write ( buf2 , '(i8)' ) fd % nj GRID_header = \"Y_COORDINATES \" // trim ( adjustl ( buf2 )) // \" float\" // newline write ( unit = fd % unit ) trim ( GRID_header ), real ( y ( 1 : fd % nj ), kind = s ), newline write ( buf2 , '(i8)' ) fd % nk GRID_header = \"Z_COORDINATES \" // trim ( adjustl ( buf2 )) // \" float\" // newline write ( unit = fd % unit ) trim ( GRID_header ), real ( z ( 1 : fd % nk ), kind = s ), newline write ( buf2 , '(i8)' ) fd % ni * fd % nj * fd % nk GRID_header = \"POINT_DATA \" // trim ( adjustl ( buf2 )) // newline write ( unit = fd % unit ) trim ( GRID_header ) end subroutine VTK_write_mesh_3d subroutine VTK_write_vector_2d ( fd , name , vx , vy ) IMPLICIT NONE TYPE ( VTK_file_handle ), INTENT ( IN ) :: fd character ( len =* ), INTENT ( IN ) :: name REAL ( KIND = dp ), INTENT ( IN ), DIMENSION (:,:) :: vx , vy REAL ( KIND = dp ), allocatable , DIMENSION (:,:,:) :: velocity INTEGER :: i , j , code = 0 character ( len = 256 ) :: uname , vname , VAR_header if (( size ( vx , dim = 1 ) /= fd % ni ) . or . & ( size ( vx , dim = 2 ) /= fd % nj )) call handle_warning ( \"VTK_write_var\" , \"Incompatible X component and mesh sizes.\" ) if (( size ( vy , dim = 1 ) /= fd % ni ) . or . & ( size ( vy , dim = 2 ) /= fd % nj )) call handle_warning ( \"VTK_write_var\" , \"Incompatible Y component and mesh sizes.\" ) if (. not . Allocated ( velocity )) then Allocate ( velocity ( 3 , fd % ni , fd % nj ), STAT = code ) if ( code /= 0 ) & call handle_error ( \"VTK_write_var\" , \"Not enough memory to Allocate VELOCITY array\" ) end if do j = 1 , fd % nj do i = 1 , fd % ni velocity ( 1 , i , j ) = vx ( i , j ) velocity ( 2 , i , j ) = vy ( i , j ) velocity ( 3 , i , j ) = 0.0 _ d end do end do VAR_header = \"VECTORS \" // trim ( adjustl ( name )) // \" float \" // newline write ( unit = fd % unit ) trim ( VAR_header ), real ( velocity (:, 1 : fd % ni , 1 : fd % nj ), kind = s ), newline uname = \"X_\" // name VAR_header = \"SCALARS \" // trim ( adjustl ( uname )) // \" float \" // newline // \"LOOKUP_TABLE default\" // newline write ( unit = fd % unit ) trim ( VAR_header ), real ( velocity ( 1 , 1 : fd % ni , 1 : fd % nj ), kind = s ), newline vname = \"Y_\" // name VAR_header = \"SCALARS \" // trim ( adjustl ( vname )) // \" float \" // newline // \"LOOKUP_TABLE default\" // newline write ( unit = fd % unit ) trim ( VAR_header ), real ( velocity ( 2 , 1 : fd % ni , 1 : fd % nj ), kind = s ), newline if ( Allocated ( velocity )) deAllocate ( velocity ) end subroutine VTK_write_vector_2d subroutine VTK_write_vector_3d ( fd , name , vx , vy , vz ) IMPLICIT NONE TYPE ( VTK_file_handle ), INTENT ( IN ) :: fd character ( len =* ), INTENT ( IN ) :: name REAL ( KIND = dp ), INTENT ( IN ), DIMENSION (:,:,:) :: vx , vy , vz REAL ( KIND = dp ), allocatable , DIMENSION (:,:,:,:) :: velocity INTEGER :: i , j , k , code = 0 character ( len = 256 ) :: uname , vname , wname , VAR_header if (( size ( vx , dim = 1 ) /= fd % ni ) . or . & ( size ( vx , dim = 2 ) /= fd % nj ) . or . & ( size ( vx , dim = 3 ) /= fd % nk )) call handle_warning ( \"VTK_write_var\" , \"Incompatible X component and mesh sizes.\" ) if (( size ( vy , dim = 1 ) /= fd % ni ) . or . & ( size ( vy , dim = 2 ) /= fd % nj ) . or . & ( size ( vy , dim = 3 ) /= fd % nk )) call handle_warning ( \"VTK_write_var\" , \"Incompatible Y component and mesh sizes.\" ) if (( size ( vz , dim = 1 ) /= fd % ni ) . or . & ( size ( vz , dim = 2 ) /= fd % nj ) . or . & ( size ( vz , dim = 3 ) /= fd % nk )) call handle_warning ( \"VTK_write_var\" , \"Incompatible Z component and mesh sizes.\" ) if (. not . Allocated ( velocity )) then Allocate ( velocity ( 3 , fd % ni , fd % nj , fd % nk ), STAT = code ) if ( code /= 0 ) & call handle_error ( \"VTK_write_var\" , \"Not enough memory to Allocate VELOCITY array\" ) end if do k = 1 , fd % nk do j = 1 , fd % nj do i = 1 , fd % ni velocity ( 1 , i , j , k ) = vx ( i , j , k ) velocity ( 2 , i , j , k ) = vy ( i , j , k ) velocity ( 3 , i , j , k ) = vz ( i , j , k ) end do end do end do VAR_header = \"VECTORS \" // trim ( adjustl ( name )) // \" float \" // newline write ( unit = fd % unit ) trim ( VAR_header ), real ( velocity (:, 1 : fd % ni , 1 : fd % nj , 1 : fd % nk ), kind = s ), newline uname = \"X_\" // name VAR_header = \"SCALARS \" // trim ( adjustl ( uname )) // \" float \" // newline // \"LOOKUP_TABLE default\" // newline write ( unit = fd % unit ) trim ( VAR_header ), real ( velocity ( 1 , 1 : fd % ni , 1 : fd % nj , 1 : fd % nk ), kind = s ), newline vname = \"Y_\" // name VAR_header = \"SCALARS \" // trim ( adjustl ( vname )) // \" float \" // newline // \"LOOKUP_TABLE default\" // newline write ( unit = fd % unit ) trim ( VAR_header ), real ( velocity ( 2 , 1 : fd % ni , 1 : fd % nj , 1 : fd % nk ), kind = s ), newline wname = \"Z_\" // name VAR_header = \"SCALARS \" // trim ( adjustl ( wname )) // \" float \" // newline // \"LOOKUP_TABLE default\" // newline write ( unit = fd % unit ) trim ( VAR_header ), real ( velocity ( 3 , 1 : fd % ni , 1 : fd % nj , 1 : fd % nk ), kind = s ), newline if ( Allocated ( velocity )) deAllocate ( velocity ) end subroutine VTK_write_vector_3d subroutine VTK_write_scalar_2d ( fd , name , field ) IMPLICIT NONE TYPE ( VTK_file_handle ), INTENT ( IN ) :: fd character ( len =* ), INTENT ( IN ) :: name REAL ( KIND = dp ), INTENT ( IN ), DIMENSION (:,:) :: field character ( len = 256 ) :: VAR_header if (( size ( field , dim = 1 ) /= fd % ni ) . or . ( size ( field , dim = 2 ) /= fd % nj )) & call handle_warning ( \"VTK_write_var\" , \"Incompatible FIELD and MESH sizes.\" ) VAR_header = \"SCALARS \" // trim ( adjustl ( name )) // \" float \" // newline // \"LOOKUP_TABLE default\" // newline write ( unit = fd % unit ) trim ( VAR_header ), real ( field ( 1 : fd % ni , 1 : fd % nj ), kind = s ), newline end subroutine VTK_write_scalar_2d subroutine VTK_write_scalar_3d ( fd , name , field ) IMPLICIT NONE TYPE ( VTK_file_handle ), INTENT ( IN ) :: fd character ( len =* ), INTENT ( IN ) :: name REAL ( KIND = dp ), INTENT ( IN ), DIMENSION (:,:,:) :: field character ( len = 256 ) :: VAR_header if (( size ( field , dim = 1 ) /= fd % ni ) . or . & ( size ( field , dim = 2 ) /= fd % nj ) . or . & ( size ( field , dim = 3 ) /= fd % nk )) call handle_warning ( \"VTK_write_var\" , \"Incompatible FIELD and MESH sizes.\" ) VAR_header = \"SCALARS \" // trim ( adjustl ( name )) // \" float \" // newline // \"LOOKUP_TABLE default\" // newline write ( unit = fd % unit ) trim ( VAR_header ), real ( field ( 1 : fd % ni , 1 : fd % nj , 1 : fd % nk ), kind = s ), newline end subroutine VTK_write_scalar_3d subroutine VTK_close_file ( fd ) IMPLICIT NONE TYPE ( VTK_file_handle ), INTENT ( IN ) :: fd logical :: file_opened inquire ( unit = fd % unit , opened = file_opened ) if ( file_opened ) then close ( unit = fd % unit ) else call handle_warning ( \"VTK_close_file\" , \"No such file to close. Please, check file descriptor.\" ) end if end subroutine VTK_close_file subroutine VTK_collect_file ( fd ) IMPLICIT NONE TYPE ( VTK_file_handle ), INTENT ( INOUT ) :: fd character ( len = 10 ) :: rank , snapshot character ( len = 80 ) :: f , vtrfile INTEGER :: shot , code , err , nt , np , k logical :: file_opened ! Looking for a none connected logical file unit. if ( iproc == 0 ) then fd % unit = 99 inquire ( unit = fd % unit , opened = file_opened ) do while ( file_opened . and . fd % unit /= 0 ) fd % unit = fd % unit - 1 inquire ( unit = fd % unit , opened = file_opened ) end do if ( fd % unit == 0 . and . file_opened ) then call handle_warning ( \"VTK_open_file\" , \"warning, all file units from 0 to 99 are already connected.\" ) else f = trim ( adjustl ( fd % prefix )) // \".pvd\" open ( unit = fd % unit , file = trim ( adjustl ( f )), form = \"FORMATTED\" , status = \"replace\" , & action = \"write\" , iostat = err ) if ( err /= 0 ) print '(\"VTK_collect_file: Error, problem creating file \",a,\".\")' , trim ( f ) write ( unit = fd % unit , fmt = '(100A)' ) '<?xml version=\"1.0\"?>' write ( unit = fd % unit , fmt = '(100A)' ) '<VTKFile type=\"Collection\" version=\"0.1\" format=\"ascii\">' write ( unit = fd % unit , fmt = '(100A)' ) '  <Collection>' nt = len_trim ( fd % prefix ) np = scan ( STRING = fd % prefix , SET = \"/\" , BACK = . true .) vtrfile = fd % prefix ( np + 1 : nt ) if ( nb_procs == 1 ) then do shot = 1 , fd % counter write ( snapshot , '(i6)' ) shot write ( unit = fd % unit , fmt = '(100A)' ) '    <DataSet timestep=\"' // trim ( adjustl ( snapshot )) // & & '\" part=\"0' // '\" file=\"' // trim ( adjustl ( vtrfile )) // & & \"_\" // trim ( adjustl ( snapshot )) // '.vtr\"/>' end do else do k = 0 , nb_procs - 1 write ( rank , '(i6)' ) k do shot = 1 , fd % counter write ( snapshot , '(i6)' ) shot write ( unit = fd % unit , fmt = '(100A)' ) '    <DataSet timestep=\"' // trim ( adjustl ( snapshot )) // & & '\" part=\"' // trim ( adjustl ( rank )) // '\" file=\"' // & & trim ( adjustl ( vtrfile )) // \"_\" // trim ( adjustl ( rank )) // & & \"_\" // trim ( adjustl ( snapshot )) // '.vtr\"/>' end do end do end if write ( unit = fd % unit , fmt = '(100A)' ) '  </Collection>' write ( unit = fd % unit , fmt = '(100A)' ) '</VTKFile>' close ( unit = fd % unit ) end if end if fd % counter = 0 ; fd % restart = 0 ; fd % first = . true . ; iproc = 0 ; nb_procs = 1 end subroutine VTK_collect_file end module vtk","tags":"","loc":"sourcefile/vtk_mod.f90.html","title":"VTK_mod.f90 – Fortran Program"},{"text":"Contents Modules ComputePUV Source Code ComputePUV_Mod.f90 Source Code Module ComputePUV !! Description: !! The module calculates the pressure and velocities (correction step). lied. ! Current Code Owner: SIMCOFlow ! Code Description: ! Language: Fortran 90. ! Software Standards: \"European Standards for Writing and ! Documenting Exchangeable Fortran 90 Code\". !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! Author : Son Tung Dang !        : NTNU,SINTEF ! Date : 20.09.2019 USE PrecisionVar USE Mesh USE Clsvof USE Cutcell USE StateVariables USE PredictorUV USE ProjectionP USE Particles IMPLICIT NONE PRIVATE PUBLIC :: UpdatePUV Interface UpdatePUV Module Procedure UpdatePUV End interface Contains Subroutine UpdatePUV ( UGrid , VGrid , PGrid , PCellO , UCellO , VCellO , PCell , UCell , & VCell , TVar , Flux_n1 , TraPar , BoomCase , dt , itt ) !! The subroutine computes the flow field parameters in the next time step. !! IMPLICIT NONE TYPE ( Grid ), INTENT ( IN ) :: UGrid , VGrid , PGrid !! The input grid TYPE ( Cell ), INTENT ( INOUT ) :: PCell , UCell , VCell !! The input and output cell TYPE ( Cell ), INTENT ( INOUT ) :: PCellO , UCellO , VCellO !! The input and output cell a previous time step TYPE ( Variables ), INTENT ( INOUT ) :: TVar !! The state variables REAL ( KIND = dp ), DIMENSION (:,:,:), allocatable , INTENT ( INOUT ) :: Flux_n1 !! The total flux at the previous time step TYPE ( Particle ), INTENT ( INOUT ) :: TraPar !! The particle information TYPE ( SolidObject ), INTENT ( IN ) :: BoomCase !! The boom REAL ( KIND = dp ), INTENT ( IN ) :: dt !! The time step INTEGER ( kind = it8b ), INTENT ( IN ) :: itt TYPE ( PoissonCoefficient ) :: PU , PV TYPE ( Predictor ) :: Pred TYPE ( Projection ) :: Proj INTEGER ( kind = it4b ) :: i , j , ii , jj REAL ( KIND = dp ) :: dps REAL ( KIND = dp ) :: BetaP , BetaM , BetaW , BetaD , Yint , Hjump , Lamda , tol REAL ( KIND = dp ), DIMENSION (:,:), allocatable :: GradPUV allocate ( Pred % u ( ibeg - ight : ibeg + ight + Isize - 1 , jbeg - jght : jbeg + jght + Jsize - 1 )) allocate ( Pred % v ( ibeg - ight : ibeg + ight + Isize - 1 , jbeg - jght : jbeg + jght + Jsize - 1 )) allocate ( Proj % Pp ( ibeg - ight : ibeg + ight + Isize - 1 , jbeg - jght : jbeg + jght + Jsize - 1 )) allocate ( PU % Dp ( ibeg - ight : jbeg + Isize - 1 + ight , jbeg - jght : jbeg + Jsize - 1 + jght )) allocate ( PV % Dp ( ibeg - ight : jbeg + Isize - 1 + ight , jbeg - jght : jbeg + Jsize - 1 + jght )) allocate ( GradPUV ( Isize , Jsize )) BetaP = 1.d0 / ( row / Roref ) BetaM = 1.d0 / ( roa / Roref ) Pred % u (:,:) = TVar % u (:,:) Pred % v (:,:) = TVar % v (:,:) tol = 1.d-24 Proj % Pp (:,:) = 0.d0 dps = 0.d0 call Predictor_UV ( PGrid , UGrid , VGrid , PCellO , UCellO , VCellO , PCell , UCell , & VCell , TVar , PU , PV , Pred , Flux_n1 , TraPar , VolParU , & BoomCase , dt , itt ) call PoissonEquationSolver ( PGrid , UGrid , VGrid , PCellO , PCell , UCell , VCell , & TVar , Pred , PU , PV , Proj , BoomCase % vs , dt , itt ) ! Correct u do i = 1 , Isize - 1 do j = 1 , Jsize GRadPUV ( i , j ) = 0.d0 if ( UCell % Posnu ( i , j ) /=- 1. and . UCell % MoExCell ( i , j ) /= 1 ) then if (( PCell % vof ( i , j ) >= 0.5d0 . and . PCell % vofS ( i , j ) < epsi ). or . & ( PCell % phi ( i , j ) < 0.d0 . and . PCell % vofS ( i , j ) >= epsi )) then if (( PCell % vof ( i + 1 , j ) < 0.5d0 . and . PCell % vofS ( i + 1 , j ) < epsi ). or . & ( PCell % phi ( i + 1 , j ) >= 0.d0 . and . PCell % vofS ( i + 1 , j ) >= epsi )) then Lamda = dabs ( PCell % phi ( i , j )) / ( dabs ( PCell % phi ( i , j )) + & dabs ( PCell % phi ( i + 1 , j )) + tol ) BetaW = Lamda * BetaM + ( 1.d0 - Lamda ) * BetaP GradPUV ( i , j ) = ( Proj % Pp ( i + 1 , j ) - Proj % Pp ( i , j )) * BetaM * BetaP / BetaW * & PU % Dp ( i , j ) / UGrid % dx ( i , j ) TVar % u ( i , j ) = Pred % u ( i , j ) - GradPUV ( i , j ) elseif (( PCell % vof ( i + 1 , j ) >= 0.5d0 . and . PCell % vofS ( i + 1 , j ) < epsi ). or . & ( PCell % phi ( i + 1 , j ) < 0.d0 . and . PCell % vofS ( i + 1 , j ) >= epsi )) then BetaW = BetaM GradPUV ( i , j ) = ( Proj % Pp ( i + 1 , j ) - Proj % Pp ( i , j )) * BetaM * BetaP / BetaW * & PU % Dp ( i , j ) / UGrid % dx ( i , j ) TVar % u ( i , j ) = Pred % u ( i , j ) - GradPUV ( i , j ) end if elseif (( PCell % vof ( i , j ) < 0.5d0 . and . PCell % vofS ( i , j ) < epsi ). or . & ( PCell % phi ( i , j ) >= 0.d0 . and . PCell % vofS ( i , j ) >= epsi )) then if (( PCell % vof ( i + 1 , j ) >= 0.5d0 . and . PCell % vofS ( i + 1 , j ) < epsi ). or . & ( PCell % phi ( i + 1 , j ) < 0.d0 . and . PCell % vofS ( i + 1 , j ) >= epsi )) then Lamda = dabs ( PCell % phi ( i , j )) / ( dabs ( PCell % phi ( i , j )) + & dabs ( PCell % phi ( i + 1 , j )) + tol ) BetaW = Lamda * BetaP + ( 1.d0 - Lamda ) * BetaM GradPUV ( i , j ) = ( Proj % Pp ( i + 1 , j ) - Proj % Pp ( i , j )) * BetaM * BetaP / BetaW * & PU % Dp ( i , j ) / UGrid % dx ( i , j ) TVar % u ( i , j ) = Pred % u ( i , j ) - GradPUV ( i , j ) elseif (( PCell % vof ( i + 1 , j ) < 0.5d0 . and . PCell % vofS ( i + 1 , j ) < epsi ). or . & ( PCell % phi ( i + 1 , j ) >= 0.d0 . and . PCell % vofS ( i + 1 , j ) >= epsi )) then BetaW = BetaP GradPUV ( i , j ) = ( Proj % Pp ( i + 1 , j ) - Proj % Pp ( i , j )) * BetaM * BetaP / BetaW * & PU % Dp ( i , j ) / UGrid % dx ( i , j ) TVar % u ( i , j ) = Pred % u ( i , j ) - GradPUV ( i , j ) end if end if end if end do end do ! Cell-Linking method for small cell do i = 1 , Isize - 1 do j = 1 , Jsize if ( UCell % MoExCell ( i , j ) == 1 ) then ii = UCell % MsCe ( i , j , 1 ) jj = UCell % MsCe ( i , j , 2 ) !     TVar%u(i,j)=0.d0 !Pred%u(i,j)!-GradPUV(ii,jj)/PU%Dp(ii,jj)*PU%Dp(i,j) end if end do end do ! Correct v do i = 1 , Isize do j = 1 , Jsize - 1 GRadPUV ( i , j ) = 0.d0 if ( VCell % Posnu ( i , j ) /=- 1. and . VCell % MoExCell ( i , j ) /= 1 ) then if (( PCell % vof ( i , j ) >= 0.5d0 . and . PCell % vofS ( i , j ) < epsi ). or . & ( PCell % phi ( i , j ) < 0.d0 . and . PCell % vofS ( i , j ) >= epsi )) then ! this cell is wet if (( PCell % vof ( i , j + 1 ) < 0.5d0 . and . PCell % vofS ( i , j + 1 ) < epsi ). or . & ( PCell % phi ( i , j + 1 ) >= 0.d0 . and . PCell % vofS ( i , j + 1 ) >= epsi )) then Lamda = dabs ( PCell % phi ( i , j )) / ( dabs ( PCell % phi ( i , j )) + & dabs ( PCell % phi ( i , j + 1 )) + tol ) BetaW = Lamda * BetaM + ( 1.d0 - Lamda ) * BetaP GradPUV ( i , j ) = ( Proj % Pp ( i , j + 1 ) - Proj % Pp ( i , j )) * BetaM * BetaP / BetaW * & PV % Dp ( i , j ) / VGrid % dy ( i , j ) TVar % v ( i , j ) = Pred % v ( i , j ) - GradPUV ( i , j ) elseif (( PCell % vof ( i , j + 1 ) >= 0.5d0 . and . PCell % vofS ( i , j + 1 ) < epsi ). or . & ( PCell % phi ( i , j + 1 ) < 0.d0 . and . PCell % vofS ( i , j + 1 ) >= epsi )) then BetaW = BetaM GRadPUV ( i , j ) = ( Proj % Pp ( i , j + 1 ) - Proj % Pp ( i , j )) * BetaM * BetaP / BetaW * & PV % Dp ( i , j ) / VGrid % dy ( i , j ) TVar % v ( i , j ) = Pred % v ( i , j ) - GradPUV ( i , j ) end if elseif (( PCell % vof ( i , j ) < 0.5d0 . and . PCell % vofS ( i , j ) < epsi ). or . & ( PCell % phi ( i , j ) >= 0.d0 . and . PCell % vofS ( i , j ) >= epsi )) then if (( PCell % vof ( i , j + 1 ) >= 0.5d0 . and . PCell % vofS ( i , j + 1 ) < epsi ). or . & ( PCell % phi ( i , j + 1 ) < 0.d0 . and . PCell % vofS ( i , j + 1 ) >= epsi )) then Lamda = dabs ( PCell % phi ( i , j )) / ( dabs ( PCell % phi ( i , j )) + & dabs ( PCell % phi ( i , j + 1 )) + tol ) BetaW = Lamda * BetaP + ( 1.d0 - Lamda ) * BetaM GradPUV ( i , j ) = ( Proj % Pp ( i , j + 1 ) - Proj % Pp ( i , j )) * BetaM * BetaP / BetaW * & PV % Dp ( i , j ) / VGrid % dy ( i , j ) TVar % v ( i , j ) = Pred % v ( i , j ) - GradPUV ( i , j ) elseif (( PCell % vof ( i , j + 1 ) < 0.5d0 . and . PCell % vofS ( i , j + 1 ) < epsi ). or . & ( PCell % phi ( i , j + 1 ) >= 0.d0 . and . PCell % vofS ( i , j + 1 ) >= epsi )) then BetaW = BetaP GradPUV ( i , j ) = ( Proj % Pp ( i , j + 1 ) - Proj % Pp ( i , j )) * BetaM * BetaP / BetaW * & PV % Dp ( i , j ) / VGrid % dy ( i , j ) TVar % v ( i , j ) = Pred % v ( i , j ) - GradPUV ( i , j ) end if end if end if end do end do ! Cell-Linking method for small cell do i = 1 , Isize do j = 1 , Jsize - 1 if ( VCell % MoExCell ( i , j ) == 1 ) then ii = VCell % MsCe ( i , j , 1 ) jj = VCell % MsCe ( i , j , 2 ) end if end do end do do i = 1 , Isize do j = 1 , Jsize if ( PCell % Posnu ( i , j ) /=- 1 ) then TVar % p ( i , j ) = Proj % Pp ( i , j ) !+TVar%p(i,j) end if end do end do !      do j = 1,Jsize !        TVar%u(Isize,j)=((-TVar%v(Isize,j)*PCell%NEdge_Area(Isize,j)+          & !                          TVar%v(Isize,j-1)*PCell%SEdge_Area(Isize,j))*        & !                          PGrid%dx(Isize,j)+TVar%u(Isize-1,j)*                 & !                          PCell%WEdge_Area(Isize,j)*PGrid%dy(Isize,j))/        & !                          PCell%EEdge_Area(Isize,j)/PGrid%dy(Isize,j) !      end do ! Compute the velocity at the boundary such that the global mass is conserved. do i = 1 , Isize TVar % v ( i , Jsize ) = (( - TVar % u ( i , Jsize ) * PCell % EEdge_Area ( i , Jsize ) & + TVar % u ( i - 1 , Jsize ) * PCell % WEdge_Area ( i , Jsize )) * PGrid % dy ( i , Jsize )& + TVar % v ( i , Jsize - 1 ) * PCell % SEdge_Area ( i , Jsize ) * PGrid % dx ( i , Jsize ))& / PGrid % dx ( i , Jsize ) / PCell % NEdge_Area ( i , Jsize ) end do ! Compute the mass error. do i = ibeg , ibeg + Isize - 1 do j = jbeg , jbeg + Jsize - 1 TVar % mres ( i , j ) = ( TVar % u ( i , j ) * PCell % EEdge_Area ( i , j ) - TVar % u ( i - 1 , j ) * & PCell % WEdge_Area ( i , j )) * PGrid % dy ( i , j ) & + ( TVar % v ( i , j ) * PCell % NEdge_Area ( i , j ) - TVar % v ( i , j - 1 ) * & PCell % SEdge_Area ( i , j )) * PGrid % dx ( i , j ) & - BoomCase % vs * PCell % nyS ( i , j ) * PCell % WlLh ( i , j ) if ( PCell % vofS ( i , j ) > 1.d0 - epsi ) TVar % mres ( i , j ) = 0.d0 end do end do call VariablesInternalCellCondition ( TVar , PCell , UCell , VCell ) deallocate ( GradPUV ) deallocate ( Pred % u ) deallocate ( Pred % v ) deallocate ( Proj % Pp ) deallocate ( PU % Dp ) deallocate ( PV % Dp ) END SUBROUTINE UpdatePUV SUBROUTINE VariablesInternalCellCondition ( TVar , PCell , UCell , VCell ) IMPLICIT NONE TYPE ( Variables ), INTENT ( INOUT ) :: TVar TYPE ( Cell ), INTENT ( IN ) :: PCell , UCell , VCell INTEGER ( kind = it4b ) :: i , j do i = ibeg , ibeg + Isize - 1 do j = jbeg , jbeg + Jsize - 1 if ( PCell % vofS ( i , j ) > 1.d0 - epsi ) then TVar % p ( i , j ) = 0.d0 end if if ( UCell % vofS ( i , j ) >= 1.d0 - epsi ) then TVar % u ( i , j ) = 0.d0 end if if ( VCell % vofS ( i , j ) >= 1.d0 - epsi ) then TVar % v ( i , j ) = 0.d0 end if end do end do END SUBROUTINE VariablesInternalCellCondition end Module ComputePUV","tags":"","loc":"sourcefile/computepuv_mod.f90.html","title":"ComputePUV_Mod.f90 – Fortran Program"},{"text":"Contents Programs Main Source Code Main.f90 Source Code !******************************************************* ! !              Open air !     |                        | !     |Air                     | !     |_____                   | !     |     |                  | ! Wall|Water|                  |Wall !     |     |                  | !     |     |                  | !     |_____|__________________| !                Wall !******************************************************* Program Main USE PrecisionVar USE Mesh USE Cutcell USE Clsvof USE StateVariables USE PrintResult USE MPI USE Solver USE Particles IMPLICIT NONE TYPE ( Grid ) :: UGrid , VGrid , PGrid TYPE ( Cell ) :: UCell , VCell , PCell TYPE ( Point ) :: ReS , ReE TYPE ( Variables ) :: Var TYPE ( Particle ) :: TraPar TYPE ( SolidObject ) :: BoomCase INTEGER ( kind = it4b ) :: Irec , Jrec , NI , NJ , iprint REAL ( KIND = dp ) :: vel , Uref , Vint open ( unit = 5 , file = 'input.dat' , action = 'read' ) read ( 5 , * ), read ( 5 , * ), Isize , Jsize , Irec , Jrec , Rey , Hw , iprint read ( 5 , * ), read ( 5 , '(a70)' ), dir close ( 5 ) Isize = 500 Jsize = 160 NI = Isize + 1 NJ = Jsize + 1 allocate ( UGrid % x ( ibeg : Isize + ibeg - 1 , jbeg : Jsize + jbeg - 1 )) allocate ( UGrid % y ( ibeg : Isize + ibeg - 1 , jbeg : Jsize + jbeg - 1 )) allocate ( VGrid % x ( ibeg : Isize + ibeg - 1 , jbeg : Jsize + jbeg - 1 )) allocate ( VGrid % y ( ibeg : Isize + ibeg - 1 , jbeg : Jsize + jbeg - 1 )) allocate ( PGrid % x ( ibeg : Isize + ibeg - 1 , jbeg : Jsize + jbeg - 1 )) allocate ( PGrid % y ( ibeg : Isize + ibeg - 1 , jbeg : Jsize + jbeg - 1 )) allocate ( UGrid % dx ( ibeg : Isize + ibeg - 1 , jbeg : Jsize + jbeg - 1 )) allocate ( UGrid % dy ( ibeg : Isize + ibeg - 1 , jbeg : Jsize + jbeg - 1 )) allocate ( VGrid % dx ( ibeg : Isize + ibeg - 1 , jbeg : Jsize + jbeg - 1 )) allocate ( VGrid % dy ( ibeg : Isize + ibeg - 1 , jbeg : Jsize + jbeg - 1 )) allocate ( PGrid % dx ( ibeg : Isize + ibeg - 1 , jbeg : Jsize + jbeg - 1 )) allocate ( PGrid % dy ( ibeg : Isize + ibeg - 1 , jbeg : Jsize + jbeg - 1 )) allocate ( UCell % vof ( ibeg : Isize + ibeg - 1 , jbeg : Jsize + jbeg - 1 )) allocate ( UCell % phi ( ibeg : Isize + ibeg - 1 , jbeg : Jsize + jbeg - 1 )) allocate ( UCell % nx ( ibeg : Isize + ibeg - 1 , jbeg : Jsize + jbeg - 1 )) allocate ( UCell % ny ( ibeg : Isize + ibeg - 1 , jbeg : Jsize + jbeg - 1 )) allocate ( UCell % vofS ( ibeg : Isize + ibeg - 1 , jbeg : Jsize + jbeg - 1 )) allocate ( UCell % phiS ( ibeg : Isize + ibeg - 1 , jbeg : Jsize + jbeg - 1 )) allocate ( UCell % nxS ( ibeg : Isize + ibeg - 1 , jbeg : Jsize + jbeg - 1 )) allocate ( UCell % nyS ( ibeg : Isize + ibeg - 1 , jbeg : Jsize + jbeg - 1 )) allocate ( UCell % EEdge_Area ( ibeg - 1 : Isize + ibeg - 1 + 1 , jbeg - 1 : Jsize + jbeg - 1 + 1 )) allocate ( UCell % WEdge_Area ( ibeg - 1 : Isize + ibeg - 1 + 1 , jbeg - 1 : Jsize + jbeg - 1 + 1 )) allocate ( UCell % NEdge_Area ( ibeg - 1 : Isize + ibeg - 1 + 1 , jbeg - 1 : Jsize + jbeg - 1 + 1 )) allocate ( UCell % SEdge_Area ( ibeg - 1 : Isize + ibeg - 1 + 1 , jbeg - 1 : Jsize + jbeg - 1 + 1 )) allocate ( UCell % MoExCell ( ibeg : Isize + ibeg - 1 , jbeg : Jsize + jbeg - 1 )) allocate ( UCell % EtaE ( ibeg - ight : ibeg + Isize - 1 + ight , jbeg - jght : jbeg + Jsize - 1 + jght )) allocate ( UCell % EtaN ( ibeg - ight : ibeg + Isize - 1 + ight , jbeg - jght : jbeg + Jsize - 1 + jght )) allocate ( UCell % DAlE ( ibeg - ight : ibeg + Isize - 1 + ight , jbeg - jght : jbeg + Jsize - 1 + jght )) allocate ( UCell % DAlN ( ibeg - ight : ibeg + Isize - 1 + ight , jbeg - jght : jbeg + Jsize - 1 + jght )) allocate ( UCell % AlE ( ibeg - ight : ibeg + Isize - 1 + ight , jbeg - jght : jbeg + Jsize - 1 + jght )) allocate ( UCell % AlN ( ibeg - ight : ibeg + Isize - 1 + ight , jbeg - jght : jbeg + Jsize - 1 + jght )) allocate ( UCell % SxE ( ibeg - ight : ibeg + Isize - 1 + ight , jbeg - jght : jbeg + Jsize - 1 + jght )) allocate ( UCell % SyN ( ibeg - ight : ibeg + Isize - 1 + ight , jbeg - jght : jbeg + Jsize - 1 + jght )) allocate ( UCell % FCE ( ibeg - ight : ibeg + Isize - 1 + ight , jbeg - jght : jbeg + Jsize - 1 + jght , 2 )) allocate ( UCell % FCN ( ibeg - ight : ibeg + Isize - 1 + ight , jbeg - jght : jbeg + Jsize - 1 + jght , 2 )) allocate ( UCell % WlLh ( ibeg : ibeg + Isize - 1 , jbeg : jbeg + Jsize - 1 )) allocate ( UCell % delh ( ibeg : ibeg + Isize - 1 , jbeg : jbeg + Jsize - 1 )) allocate ( UCell % PosNu ( ibeg - ight : ibeg + Isize - 1 + ight , jbeg - jght : jbeg + Jsize - 1 + jght )) allocate ( UCell % Cell_Cent ( Isize , Jsize , 2 )) allocate ( UCell % MsCe ( Isize , Jsize , 2 )) allocate ( VCell % vof ( ibeg : Isize + ibeg - 1 , jbeg : Jsize + jbeg - 1 )) allocate ( VCell % phi ( ibeg : Isize + ibeg - 1 , jbeg : Jsize + jbeg - 1 )) allocate ( VCell % nx ( ibeg : Isize + ibeg - 1 , jbeg : Jsize + jbeg - 1 )) allocate ( VCell % ny ( ibeg : Isize + ibeg - 1 , jbeg : Jsize + jbeg - 1 )) allocate ( VCell % vofS ( ibeg : Isize + ibeg - 1 , jbeg : Jsize + jbeg - 1 )) allocate ( VCell % phiS ( ibeg : Isize + ibeg - 1 , jbeg : Jsize + jbeg - 1 )) allocate ( VCell % nxS ( ibeg : Isize + ibeg - 1 , jbeg : Jsize + jbeg - 1 )) allocate ( VCell % nyS ( ibeg : Isize + ibeg - 1 , jbeg : Jsize + jbeg - 1 )) allocate ( VCell % EEdge_Area ( ibeg - 1 : Isize + ibeg - 1 + 1 , jbeg - 1 : Jsize + jbeg - 1 + 1 )) allocate ( VCell % WEdge_Area ( ibeg - 1 : Isize + ibeg - 1 + 1 , jbeg - 1 : Jsize + jbeg - 1 + 1 )) allocate ( VCell % NEdge_Area ( ibeg - 1 : Isize + ibeg - 1 + 1 , jbeg - 1 : Jsize + jbeg - 1 + 1 )) allocate ( VCell % SEdge_Area ( ibeg - 1 : Isize + ibeg - 1 + 1 , jbeg - 1 : Jsize + jbeg - 1 + 1 )) allocate ( VCell % MoExCell ( ibeg : Isize + ibeg - 1 , jbeg : Jsize + jbeg - 1 )) allocate ( VCell % EtaE ( ibeg - ight : ibeg + Isize - 1 + ight , jbeg - jght : jbeg + Jsize - 1 + jght )) allocate ( VCell % EtaN ( ibeg - ight : ibeg + Isize - 1 + ight , jbeg - jght : jbeg + Jsize - 1 + jght )) allocate ( VCell % DAlE ( ibeg - ight : ibeg + Isize - 1 + ight , jbeg - jght : jbeg + Jsize - 1 + jght )) allocate ( VCell % DAlN ( ibeg - ight : ibeg + Isize - 1 + ight , jbeg - jght : jbeg + Jsize - 1 + jght )) allocate ( VCell % AlE ( ibeg - ight : ibeg + Isize - 1 + ight , jbeg - jght : jbeg + Jsize - 1 + jght )) allocate ( VCell % AlN ( ibeg - ight : ibeg + Isize - 1 + ight , jbeg - jght : jbeg + Jsize - 1 + jght )) allocate ( VCell % SxE ( ibeg - ight : ibeg + Isize - 1 + ight , jbeg - jght : jbeg + Jsize - 1 + jght )) allocate ( VCell % SyN ( ibeg - ight : ibeg + Isize - 1 + ight , jbeg - jght : jbeg + Jsize - 1 + jght )) allocate ( VCell % FCE ( ibeg - ight : ibeg + Isize - 1 + ight , jbeg - jght : jbeg + Jsize - 1 + jght , 2 )) allocate ( VCell % FCN ( ibeg - ight : ibeg + Isize - 1 + ight , jbeg - jght : jbeg + Jsize - 1 + jght , 2 )) allocate ( VCell % WlLh ( ibeg : ibeg + Isize - 1 , jbeg : jbeg + Jsize - 1 )) allocate ( VCell % delh ( ibeg : ibeg + Isize - 1 , jbeg : jbeg + Jsize - 1 )) allocate ( VCell % PosNu ( ibeg - ight : ibeg + Isize - 1 + ight , jbeg - jght : jbeg + Jsize - 1 + jght )) allocate ( VCell % Cell_Cent ( Isize , Jsize , 2 )) allocate ( VCell % MsCe ( Isize , Jsize , 2 )) allocate ( PCell % vof ( ibeg : Isize , jbeg : Jsize )) allocate ( PCell % phi ( ibeg : Isize , jbeg : Jsize )) allocate ( PCell % nx ( ibeg : Isize , jbeg : Jsize )) allocate ( PCell % ny ( ibeg : Isize , jbeg : Jsize )) allocate ( PCell % vofS ( ibeg : Isize , jbeg : Jsize )) allocate ( PCell % phiS ( ibeg : Isize , jbeg : Jsize )) allocate ( PCell % nxS ( ibeg : Isize , jbeg : Jsize )) allocate ( PCell % nyS ( ibeg : Isize , jbeg : Jsize )) allocate ( PCell % EEdge_Area ( ibeg - 1 : Isize + 1 , jbeg - 1 : Jsize + 1 )) allocate ( PCell % WEdge_Area ( ibeg - 1 : Isize + 1 , jbeg - 1 : Jsize + 1 )) allocate ( PCell % NEdge_Area ( ibeg - 1 : Isize + 1 , jbeg - 1 : Jsize + 1 )) allocate ( PCell % SEdge_Area ( ibeg - 1 : Isize + 1 , jbeg - 1 : Jsize + 1 )) allocate ( PCell % FCE ( ibeg - ight : ibeg + Isize - 1 + ight , jbeg - jght : jbeg + Jsize - 1 + jght , 2 )) allocate ( PCell % FCN ( ibeg - ight : ibeg + Isize - 1 + ight , jbeg - jght : jbeg + Jsize - 1 + jght , 2 )) allocate ( PCell % WlLh ( ibeg : Isize , jbeg : Jsize )) allocate ( PCell % PosNu ( ibeg - ight : ibeg + Isize - 1 + ight , jbeg - jght : jbeg + Jsize - 1 + jght )) allocate ( PCell % Cell_Cent ( Isize , Jsize , 2 )) allocate ( Var % u ( ibeg - ight : Isize - ibeg + ight + 1 , jbeg - jght : Jsize - jbeg + jght + 1 )) allocate ( Var % v ( ibeg - ight : Isize - ibeg + ight + 1 , jbeg - jght : Jsize - jbeg + jght + 1 )) allocate ( Var % p ( ibeg - ight : Isize - ibeg + ight + 1 , jbeg - jght : Jsize - jbeg + jght + 1 )) allocate ( Var % Gpu ( ibeg : ibeg + Isize - 1 , jbeg : jbeg + Jsize - 1 )) allocate ( Var % Gpv ( ibeg : ibeg + Isize - 1 , jbeg : jbeg + Jsize - 1 )) allocate ( Var % ures ( ibeg : ibeg + Isize - 1 , jbeg : jbeg + Jsize - 1 )) allocate ( Var % vres ( ibeg : ibeg + Isize - 1 , jbeg : jbeg + Jsize - 1 )) allocate ( Var % pres ( ibeg : ibeg + Isize - 1 , jbeg : jbeg + Jsize - 1 )) allocate ( Var % mres ( ibeg : ibeg + Isize - 1 , jbeg : jbeg + Jsize - 1 )) allocate ( Var % t ( ibeg - ight : Isize - ibeg + ight + 1 , jbeg - jght : Jsize - jbeg + jght + 1 )) allocate ( TraPar % dp ( 10000 )) allocate ( TraPar % Posp ( 10000 )) allocate ( TraPar % uvp ( 10000 )) TraPar % np = 0 Lref = 1.d0 !Hw Uref = 1.d0 Roref = row nuref = nuw rop = 71 1.d0 Hw = 6.0d0 / Lref !DWedge HDomain = 8.d0 HChannel = 8 0.d0 / Lref LChannel = 2 5.d0 / Lref Ha = HDomain - Hw Depthw = HChannel - Ha ! for sinusoidal wave twp = 1.131371d0 Lamdaw = g * twp ** 2.d0 / 2.d0 / pi cw0 = dsqrt ( g * Lamdaw / 2.d0 / pi ) Lamdaw = Lamdaw / Lref cw0 = cw0 / Uref twp = twp / ( Lref / Uref ) kw = 2.d0 * pi / Lamdaw Amp0 = 0.1d0 / Lref / 2.d0 omew = 2.d0 * pi / twp !   Start_Point%x=-6.5/Lref Start_Point % x = 0.d0 / Lref Start_point % y = ( HChannel - HDomain ) / Lref !-Hw/Lref !   End_Point%x=6.5d0/Lref End_Point % x = LChannel / Lref End_Point % y = HChannel / Lref BoomCase % Posp % x = 1 5.d0 / Lref BoomCase % Posp % y = Depthw BoomCase % Dobj = 0.8d0 / Lref BoomCase % Wobj = 0.16d0 / Lref BoomCase % XBar1 = BoomCase % Posp % x - BoomCase % Wobj / 2.d0 BoomCase % XBar2 = BoomCase % Posp % x + BoomCase % Wobj / 2.d0 BoomCase % LBar = 1.5d0 / Lref BoomCase % YBar = BoomCase % Posp % y - dsqrt (( BoomCase % Dobj / 2.d0 ) ** 2.d0 - & ( BoomCase % Wobj / 2.d0 ) ** 2.d0 ) - BoomCase % LBar BoomCase % Mobj = ( pi / 4.d0 * ( BoomCase % Dobj ) ** 2.d0 + BoomCase % Wobj * BoomCase % LBar ) * 0.5d0 * rop / Roref UwInlet = 1.d0 / Uref UgInlet = 3.d0 / Uref UParInlet = 4.d0 / Uref HParInlet = 1.5d0 / Lref DParInlet = 1.d-2 / Lref IParInlet = 50 NParInlet = 5 ReS % x = 1 3.5d0 / Lref ReS % y = 0.2d0 / Lref ReE % x = 1 6.0d0 / Lref ReE % y = 0.8d0 / Lref zp = 1.d-2 / Lref Irec = 375 Jrec = 60 Vint = 0.d0 vel = 0.d0 gx = 0.d0 gy = g VofInlet = 1.d0 RunAgain = . FALSE . !   define corner problem ICorProb = . TRUE . IttRun = 600 call Initial_Grid ( Start_Point , End_Point , ReS , ReE , NI , NJ , Irec , Jrec , PGrid , Lref , 0 ) call InitialUVGrid ( PGrid , UGrid , 0 , Lref ) call InitialUVGrid ( PGrid , VGrid , 1 , Lref ) call MPI_Initial call HYPRE_CreateGrid ( PGrid ) call Initial_Clsvof ( PGrid , PCell , BoomCase ) call Initial_Clsvof ( UGrid , UCell , BoomCase ) call Initial_Clsvof ( VGrid , VCell , BoomCase ) call Grid_Preprocess ( PGrid , UGrid , VGrid , PCell , UCell , VCell , Var , int8 ( 1 )) call Initial_Var ( PCell , PGrid , Var , vel , Vint , 0.d0 , 30 0.d0 , Uref , 30 0.d0 , Roref , Lref ) call InitializeParticles ( PGrid , Var , TraPar ) !  call Print_Result_Tecplot_PCent(PGrid,Var,PCell,TraPar,INT8(0),1) call Print_Result_Tecplot_UCent ( UGrid , Var , UCell , INT8 ( 0 )) call Print_Result_Tecplot_VCent ( VGrid , Var , VCell , INT8 ( 0 )) call NewCellFace ( PCell , UCell , VCell , PGrid , UGrid , VGrid ) call IterationSolution ( PGrid , UGrid , VGrid , PCell , UCell , VCell , Var , TraPar , BoomCase , 50 ) pause end program main","tags":"","loc":"sourcefile/main.f90.html","title":"Main.f90 – Fortran Program"},{"text":"Contents Modules Cutcell Source Code Cutcell_Mod.f90 Source Code Module Cutcell !! Description: !! The module provides all information about cut-cell. !! Cells inside the solid will be excluded from computational work. ! Current Code Owner: SIMCOFlow ! Code Description: ! Language: Fortran 90. ! Software Standards: \"European Standards for Writing and ! Documenting Exchangeable Fortran 90 Code\". !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! Author : Son Tung Dang !        : NTNU,SINTEF ! Date : 20.09.2019 USE PrecisionVar USE Mesh USE StateVariables IMPLICIT NONE PRIVATE PUBLIC :: Grid_Preprocess , NumberExternalCell , NewCellFace Interface Grid_Preprocess Module procedure Grid_Preprocess End interface Grid_Preprocess Interface NumberExternalCell Module procedure NumberExternalCell End interface Interface NewCellFace Module procedure NewCellFace End interface Contains Subroutine Grid_Preprocess ( PGrid , UGrid , VGrid , PCell , UCell , VCell , TVar , itt ) !! The subroutine compute the surface area and define solid cells. IMPLICIT NONE TYPE ( Grid ), INTENT ( IN ) :: PGrid , UGrid , VGrid !! The grid TYPE ( Cell ), INTENT ( INOUT ) :: PCell , UCell , VCell !! The cell TYPE ( Variables ), INTENT ( IN ) :: TVar !! The state variables INTEGER ( kind = it8b ), INTENT ( IN ) :: itt !! The number of iterations INTEGER ( kind = it4b ) :: i , j call Cell_Geo_Cal ( PGrid , PCell ) call Cell_Geo_Cal ( UGrid , UCell ) call Cell_Geo_Cal ( VGrid , VCell ) call DefineMomentumExchangeCell ( PCell , UCell , VCell ) call NumberExternalCell ( PCell , 0 , 0 ) call NumberExternalCell ( UCell , 1 , 0 ) call NumberExternalCell ( VCell , 0 , 1 ) End subroutine Grid_Preprocess Subroutine Cell_Geo_Cal ( TGrid , TCell ) !! The subroutine computes the surface area for cut cell. IMPLICIT NONE TYPE ( Grid ), INTENT ( IN ) :: TGrid !! The grid TYPE ( Cell ), INTENT ( INOUT ) :: TCell !! The cell TYPE ( Point ) :: Pt ( 0 : 1 , 0 : 1 ), FaCe INTEGER ( kind = it4b ) :: i , j , ii , jj , ctr REAL ( KIND = dp ) :: Nodels ( 0 : 1 , 0 : 1 ), MaxFace , AverageArea REAL ( KIND = dp ) :: dh , AverageFace , Roundoff REAL ( KIND = dp ), DIMENSION (:,:,:), allocatable :: FCW , FCS allocate ( FCW ( Isize , Jsize , 2 )) allocate ( FCS ( Isize , Jsize , 2 )) Roundoff = 1.d-24 do i = ibeg , Isize + ibeg - 1 do j = jbeg , Jsize + jbeg - 1 TCell % Cell_Cent ( i , j , 1 ) = 0.d0 TCell % Cell_Cent ( i , j , 2 ) = 0.d0 ctr = 0 dh = 0.d0 do ii = 0 , 1 do jj = 0 , 1 Pt ( ii , jj )% x =- TGrid % dx ( i , j ) * ( 0.5d0 - dble ( ii )) Pt ( ii , jj )% y =- TGrid % dy ( i , j ) * ( 0.5d0 - dble ( jj )) end do end do ! Calculate the surface area and the center for cell face call Edge_Geo_Cal ( Pt ( 0 , 0 ), Pt ( 0 , 1 ), TCell % nxs ( i , j ), TCell % nys ( i , j ), & TCell % phis ( i , j ), TCell % WEdge_Area ( i , j ), FaCe ) FCW ( i , j , 1 ) = Face % x FCW ( i , j , 2 ) = Face % y call Edge_Geo_Cal ( Pt ( 0 , 1 ), Pt ( 1 , 1 ), TCell % nxs ( i , j ), TCell % nys ( i , j ), & TCell % phis ( i , j ), TCell % NEdge_Area ( i , j ), FaCe ) TCell % FCN ( i , j , 1 ) = FaCe % x TCell % FCN ( i , j , 2 ) = FaCe % y call Edge_Geo_Cal ( Pt ( 1 , 1 ), Pt ( 1 , 0 ), TCell % nxs ( i , j ), TCell % nys ( i , j ), & TCell % phis ( i , j ), TCell % EEdge_Area ( i , j ), FaCe ) TCell % FCE ( i , j , 1 ) = FaCe % x TCell % FCE ( i , j , 2 ) = FaCe % y call Edge_Geo_Cal ( Pt ( 1 , 0 ), Pt ( 0 , 0 ), TCell % nxs ( i , j ), TCell % nys ( i , j ), & TCell % phis ( i , j ), TCell % SEdge_Area ( i , j ), FaCe ) FCS ( i , j , 1 ) = Face % x FCS ( i , j , 2 ) = Face % y ! Calculate the face area of internal cell ! An edge sharing with internal cell will be set up at 0 ! The other edges will be set up at actual value. end do end do if ( allocated ( TCell % WlLh )) then do i = 1 , Isize do j = 1 , Jsize TCell % WlLh ( i , j ) = dsqrt ((( TCell % EEdge_Area ( i , j ) - & TCell % WEdge_Area ( i , j )) * TGrid % dx ( i , j )) ** 2.d0 + & (( TCell % NEdge_Area ( i , j ) - TCell % SEdge_Area ( i , j )) * & TGrid % dy ( i , j )) ** 2.d0 ) !        TCell%WlLh(i,j) = 0.d0 end do end do end if TCell % FCE ( ibeg - 1 ,:, 1 ) = TCell % FCE ( ibeg ,:, 1 ) - TGrid % dx ( ibeg , 1 ) TCell % FCE ( ibeg - 1 ,:, 2 ) = TCell % FCE ( ibeg ,:, 2 ) TCell % FCE ( ibeg + Isize ,:, 1 ) = TCell % FCE ( ibeg + Isize - 1 ,:, 1 ) + & TGrid % dx ( ibeg + Isize - 1 , 1 ) TCell % FCE ( ibeg + Isize ,:, 2 ) = TCell % FCE ( ibeg + Isize - 1 ,:, 2 ) TCell % FCN ( ibeg - 1 ,:, 1 ) = TCell % FCN ( ibeg ,:, 1 ) - TGrid % dx ( ibeg , 1 ) TCell % FCN ( ibeg - 1 ,:, 2 ) = TCell % FCN ( ibeg ,:, 2 ) TCell % FCN ( ibeg + Isize ,:, 1 ) = TCell % FCN ( ibeg + Isize - 1 ,:, 1 ) + & TGrid % dx ( ibeg + Isize - 1 , 1 ) TCell % FCN ( ibeg + Isize ,:, 2 ) = TCell % FCN ( ibeg + Isize - 1 ,:, 2 ) TCell % FCE (:, jbeg - 1 , 1 ) = TCell % FCE (:, jbeg , 1 ) TCell % FCE (:, jbeg - 1 , 2 ) = TCell % FCE (:, jbeg , 2 ) - TGrid % dy ( 1 , jbeg ) TCell % FCE (:, jbeg + Jsize , 1 ) = TCell % FCE (:, jbeg + Jsize - 1 , 1 ) TCell % FCE (:, jbeg + Jsize , 2 ) = TCell % FCE (:, jbeg + Jsize - 1 , 2 ) + & TGrid % dy ( 1 , jbeg + Jsize - 1 ) TCell % FCN (:, jbeg - 1 , 1 ) = TCell % FCE (:, jbeg , 1 ) TCell % FCN (:, jbeg - 1 , 2 ) = TCell % FCE (:, jbeg , 2 ) - TGrid % dy ( 1 , jbeg ) TCell % FCN (:, jbeg + Jsize , 1 ) = TCell % FCE (:, jbeg + Jsize - 1 , 1 ) TCell % FCN (:, jbeg + Jsize , 2 ) = TCell % FCE (:, jbeg + Jsize - 1 , 2 ) + & TGrid % dy ( 1 , jbeg + Jsize - 1 ) do i = 1 , Isize do j = 1 , Jsize TCell % WEdge_Area ( i , j ) = 1.d0 - TCell % WEdge_Area ( i , j ) TCell % EEdge_Area ( i , j ) = 1.d0 - TCell % EEdge_Area ( i , j ) TCell % NEdge_Area ( i , j ) = 1.d0 - TCell % NEdge_Area ( i , j ) TCell % SEdge_Area ( i , j ) = 1.d0 - TCell % SEdge_Area ( i , j ) ! Calculate the Face Ceter for Eastern Edge ! (Convert from solid face to fluid face) if ( dabs ( TCell % FCE ( i , j , 2 )) < epsi ) then TCell % FCE ( i , j , 2 ) = 0.d0 else TCell % FCE ( i , j , 2 ) = ( 0.5d0 - TCell % EEdge_Area ( i , j ) / 2.d0 ) * & dsign ( 1.d0 , - TCell % FCE ( i , j , 2 )) * TGrid % dy ( i , j ) end if if ( TCell % EEdge_Area ( i , j ) < epsiF ) TCell % FCE ( i , j , 2 ) = 0.d0 ! Calculate the Face Ceter for Western Edge ! (Convert from solid face to fluid face) if ( dabs ( FCW ( i , j , 2 )) < epsi ) then FCW ( i , j , 2 ) = 0.d0 else FCW ( i , j , 2 ) = ( 0.5d0 - TCell % WEdge_Area ( i , j ) / 2.d0 ) * & dsign ( 1.d0 , - FCW ( i , j , 2 )) * TGrid % dy ( i , j ) end if if ( TCell % WEdge_Area ( i , j ) < epsiF ) FCW ( i , j , 2 ) = 0.d0 ! Calculate the Face Ceter for Northern Edge ! (Convert from solid face to fluid face) if ( dabs ( TCell % FCN ( i , j , 1 )) < epsi ) then TCell % FCN ( i , j , 1 ) = 0.d0 else TCell % FCN ( i , j , 1 ) = ( 0.5d0 - TCell % NEdge_Area ( i , j ) / 2.d0 ) * & dsign ( 1.d0 , - TCell % FCN ( i , j , 1 )) * TGrid % dx ( i , j ) end if if ( TCell % NEdge_Area ( i , j ) < epsiF ) TCell % FCN ( i , j , 1 ) = 0.d0 ! Calculate the Face Ceter for Southern Edge ! (Convert from solid face to fluid face) if ( dabs ( FCS ( i , j , 1 )) < epsi ) then FCS ( i , j , 1 ) = 0.d0 else FCS ( i , j , 1 ) = ( 0.5d0 - TCell % SEdge_Area ( i , j ) / 2.d0 ) * & dsign ( 1.d0 , - FCS ( i , j , 1 )) * TGrid % dx ( i , j ) end if if ( TCell % SEdge_Area ( i , j ) < epsiF ) FCS ( i , j , 1 ) = 0.d0 end do end do do i = 2 , Isize - 1 do j = 2 , Jsize - 1 AverageFace = 2.d0 * TCell % NEdge_Area ( i , j ) * TCell % SEdge_Area ( i , j + 1 ) / & ( TCell % NEdge_Area ( i , j ) + TCell % SEdge_Area ( i , j + 1 ) + Roundoff ) TCell % FCN ( i , j , 1 ) = ( TCell % FCN ( i , j , 1 ) * TCell % NEdge_Area ( i , j ) + & FCS ( i , j + 1 , 1 ) * TCell % SEdge_Area ( i , j + 1 )) / & ( TCell % NEdge_Area ( i , j ) + TCell % SEdge_Area ( i , j + 1 ) + Roundoff ) TCell % FCN ( i , j , 2 ) = ( TCell % FCN ( i , j , 2 ) * TCell % NEdge_Area ( i , j ) + & ( FCS ( i , j + 1 , 2 ) + ( TGrid % y ( i , j + 1 ) - TGrid % y ( i , j ))) * & TCell % SEdge_Area ( i , j + 1 )) / ( TCell % NEdge_Area ( i , j ) + & TCell % SEdge_Area ( i , j + 1 ) + Roundoff ) if ( TCell % NEdge_Area ( i , j ) < epsiF . and . TCell % SEdge_Area ( i , j + 1 ) < epsiF ) then TCell % FCN ( i , j , 2 ) = TGrid % dy ( i , j ) / 2.d0 end if if ( isnan ( TCell % FCN ( i , j , 1 )). or . isnan ( TCell % FCN ( i , j , 2 ))) then print * , FCS ( i , j + 1 , 1 ), TCell % NEdge_Area ( i , j ), TCell % SEdge_Area ( i , j + 1 ) print * , FCS ( i , j + 1 , 2 ) print * , 'Cutcell_178' end if TCell % NEdge_Area ( i , j ) = AverageFace TCell % SEdge_Area ( i , j + 1 ) = AverageFace AverageFace = 2.d0 * TCell % EEdge_Area ( i , j ) * TCell % WEdge_Area ( i + 1 , j ) / & ( TCell % EEdge_Area ( i , j ) + TCell % WEdge_Area ( i + 1 , j ) + Roundoff ) TCell % FCE ( i , j , 1 ) = ( TCell % FCE ( i , j , 1 ) * TCell % EEdge_Area ( i , j ) + & ( FCW ( i + 1 , j , 1 ) + ( TGrid % x ( i + 1 , j ) - TGrid % x ( i , j ))) * & TCell % WEdge_Area ( i + 1 , j )) / ( TCell % EEdge_Area ( i , j ) + & TCell % WEdge_Area ( i + 1 , j ) + Roundoff ) TCell % FCE ( i , j , 2 ) = ( TCell % FCE ( i , j , 2 ) * TCell % EEdge_Area ( i , j ) + & FCW ( i + 1 , j , 2 ) * TCell % WEdge_Area ( i + 1 , j )) / & ( TCell % EEdge_Area ( i , j ) + TCell % WEdge_Area ( i + 1 , j ) + Roundoff ) if ( TCell % EEdge_Area ( i , j ) < epsiF . and . TCell % WEdge_Area ( i + 1 , j ) < epsiF ) then TCell % FCE ( i , j , 1 ) = TGrid % dx ( i , j ) / 2.d0 end if if ( isnan ( TCell % FCE ( i , j , 1 )). or . isnan ( TCell % FCE ( i , j , 2 ))) then print * , FCW ( i + 1 , j , 1 ), TCell % EEdge_Area ( i , j ), TCell % WEdge_Area ( i , j + 1 ) print * , FCW ( i + 1 , j , 2 ) print * , 'Cutcell_198' end if TCell % EEdge_Area ( i , j ) = AverageFace TCell % WEdge_Area ( i + 1 , j ) = AverageFace end do end do !    Modify the face area for sharing cell do i = 1 , Isize do j = 1 , Jsize if ( TCell % vofS ( i , j ) > 1.d0 - epsi ) then TCell % vofS ( i , j ) = 1.d0 TCell % WEdge_Area ( i , j ) = 0.d0 TCell % EEdge_ARea ( i , j ) = 0.d0 TCell % NEdge_ARea ( i , j ) = 0.d0 TCell % SEdge_ARea ( i , j ) = 0.d0 ! for neighbor cell TCell % EEdge_Area ( i - 1 , j ) = 0.d0 TCell % NEdge_Area ( i , j - 1 ) = 0.d0 TCell % WEdge_Area ( i + 1 , j ) = 0.d0 TCell % SEdge_Area ( i , j + 1 ) = 0.d0 end if if (( TCell % WEdge_Area ( i , j ) + TCell % EEdge_Area ( i , j ) < Roundoff . or . & TCell % SEdge_ARea ( i , j ) + TCell % NEdge_Area ( i , j ) < Roundoff ). and . & TCell % VofS ( i , j ) < 1.d0 - epsi . and .(. not . allocated ( TCell % MsCe ))) then TCell % vofS ( i , j ) = 1.d0 TCell % WEdge_Area ( i , j ) = 0.d0 TCell % EEdge_ARea ( i , j ) = 0.d0 TCell % NEdge_ARea ( i , j ) = 0.d0 TCell % SEdge_ARea ( i , j ) = 0.d0 ! for neighbor cell TCell % EEdge_Area ( i - 1 , j ) = 0.d0 TCell % NEdge_Area ( i , j - 1 ) = 0.d0 TCell % WEdge_Area ( i + 1 , j ) = 0.d0 TCell % SEdge_Area ( i , j + 1 ) = 0.d0 end if end do end do do i = ibeg , ibeg + Isize - 1 do j = jbeg , jbeg + Jsize - 1 if ( dabs ( TCell % vofS ( i , j ) - 1.d0 ) < Roundoff ) then if ( TCell % WEdge_Area ( i , j ) == 0.d0 . or . TCell % EEdge_Area ( i , j ) == 0.d0 ) then TCell % WlLh ( i , j ) = TGrid % dy ( i , j ) if ( allocated ( TCell % delh )) TCell % delh ( i , j ) = TGrid % dx ( i , j ) / 2.d0 end if if ( TCell % NEdge_ARea ( i , j ) == 0.d0 . or . TCell % SEdge_ARea ( i , j ) == 0.d0 ) then TCell % WlLh ( i , j ) = TGrid % dx ( i , j ) if ( allocated ( TCell % delh )) TCell % delh ( i , j ) = TGrid % dy ( i , j ) / 2.d0 end if end if end do end do if (( ICorProb . eqv .. TRUE .). and .(. not . allocated ( TCell % MoExCell ))) then do i = 1 , Isize do j = 1 , Jsize - 4 if ( TCell % VofS ( i , j ) >- epsi . and . TCell % vofS ( i , j ) < epsi ) then if ( TCell % vofS ( i , j + 1 ) > 0.6d0 - epsi . and . TCell % vofS ( i , j + 1 ) < 0.6d0 + & epsi ) then if ( TCell % vofS ( i , j + 2 ) > 0.6d0 - epsi . and . TCell % vofS ( i , j + 2 ) < 0.6d0 + & epsi ) then TCell % NEdge_ARea ( i , j ) = 0.40 TCell % SEDGe_Area ( i , j + 1 ) = 0.4d0 TCell % FCN ( i , j , 1 ) =- 0.3d0 * TGrid % dx ( i , j ) TCell % FCN ( i , j , 2 ) = 0.5d0 * TGrid % dy ( i , j ) TCell % WlLh ( i , j ) = 0.6d0 * TGrid % dx ( i , j ) TCell % nyS ( i , j ) =- 1.d0 TCell % nxS ( i , j ) = 0.d0 end if end if if ( TCell % vofS ( i , j + 1 ) > 1.d0 - epsi . and . TCell % vofS ( i , j + 1 ) < 1.d0 + & epsi ) then TCell % WlLh ( i , j ) = TGrid % dx ( i , j ) TCell % nyS ( i , j ) =- 1.d0 TCell % nxS ( i , j ) = 0.d0 end if end if end do end do end if deallocate ( FCW , FCS ) end subroutine Cell_Geo_Cal SUBROUTINE Edge_Geo_Cal ( Pt1 , Pt2 , nxx , nyy , diss , Edge_Area , FaCe ) IMPLICIT NONE TYPE ( point ), INTENT ( IN ) :: Pt1 , Pt2 TYPE ( point ), INTENT ( OUT ) :: Face REAL ( KIND = dp ), INTENT ( IN ) :: nxx , nyy , diss REAL ( KIND = dp ), INTENT ( OUT ) :: Edge_Area REAL ( KIND = dp ) :: epsil , Lvs_Pt1 , Lvs_Pt2 Lvs_Pt1 = nxx * Pt1 % x + nyy * Pt1 % y + diss Lvs_Pt2 = nxx * Pt2 % x + nyy * Pt2 % y + diss epsil = 1.d-14 FaCe % x = 0.5d0 * ( pt1 % x + pt2 % x ) FaCe % y = 0.5d0 * ( pt1 % y + pt2 % y ) if ( Lvs_Pt1 >= epsil . and . Lvs_Pt2 >= epsil ) then Edge_Area = 0.d0 elseif ( Lvs_Pt1 < epsil . and . Lvs_Pt2 < epsil ) then Edge_Area = 1.d0 ! the Pt2 in solid field, Pt1 in liquid field elseif ( Lvs_Pt1 >= epsil . and . Lvs_Pt2 < epsil ) then if ( dabs ( pt1 % x - pt2 % x ) <= 1.d-10 ) then Edge_Area = dabs ( Lvs_Pt2 ) / ( dabs ( Lvs_Pt1 ) + dabs ( Lvs_Pt2 )) FaCe % y = pt2 % y - 0.5d0 * Edge_Area * ( pt2 % y - pt1 % y ) else Edge_Area = dabs ( Lvs_Pt2 ) / ( dabs ( Lvs_Pt1 ) + dabs ( Lvs_Pt2 )) FaCe % x = pt2 % x - 0.5d0 * Edge_Area * ( pt2 % x - pt1 % x ) end if ! the Pt1 in solid field, Pt2 in liquid field elseif ( Lvs_Pt1 < epsil . and . Lvs_Pt2 >= epsil ) then if ( dabs ( pt1 % x - pt2 % x ) <= 1.d-10 ) then Edge_Area = dabs ( Lvs_Pt1 ) / ( dabs ( Lvs_Pt1 ) + dabs ( Lvs_Pt2 )) FaCe % y = pt1 % y - 0.5d0 * Edge_Area * ( pt1 % y - pt2 % y ) else Edge_Area = dabs ( Lvs_Pt1 ) / ( dabs ( Lvs_Pt1 ) + dabs ( Lvs_Pt2 )) FaCe % x = pt1 % x - 0.5d0 * Edge_Area * ( pt1 % x - pt2 % x ) end if end if end subroutine Edge_Geo_Cal ! numbering the pressure cell for poisson equation Subroutine NumberExternalCell ( TCell , iu , iv ) IMPLICIT NONE TYPE ( Cell ), INTENT ( INOUT ) :: TCell INTEGER ( kind = it4b ), INTENT ( IN ) :: iu , iv INTEGER ( kind = it4b ) :: i , j INTEGER ( kind = it4b ) :: ctr ctr = 0 Do i = ibeg , Isize - iu Do j = jbeg , Jsize - iv if ( TCell % vofS ( i , j ) < 1.d0 - epsi ) then TCell % Posnu ( i , j ) = ctr ctr = ctr + 1 else TCell % Posnu ( i , j ) =- 1 end if End do End do TCell % ExtCell = ctr - 1 End subroutine NumberExternalCell subroutine DefineMomentumExchangeCell ( PCell , UCell , VCell ) IMPLICIT NONE TYPE ( Cell ), INTENT ( INOUT ) :: PCell TYPE ( Cell ), INTENT ( INOUT ) :: UCell , VCell INTEGER ( kind = it4b ) :: i , j do i = ibeg , ibeg + Isize - 1 do j = jbeg , jbeg + Jsize - 1 UCell % MoExCell ( i , j ) = 0 VCell % MoExCell ( i , j ) = 0 ! Define the U-cell applying the momentum exchange term if ( UCell % VofS ( i , j ) >= epsi . and . UCell % VofS ( i , j ) < 1.d0 - epsi ) then if ( i < ibeg + Isize - 1 ) then if ( PCell % VofS ( i , j ) >= 1.d0 - epsi . or . PCell % VofS ( i + 1 , j ) >= 1.d0 - epsi & . or . PCell % EEdge_Area ( i , j ) < epsiF ) then UCell % MoExCell ( i , j ) = 1 PCell % EEdge_Area ( i , j ) = 0.d0 PCell % WEdge_Area ( i + 1 , j ) = 0.d0 end if else if ( PCell % VofS ( i , j ) >= 1.d0 - epsi ) UCell % MoExCell ( i , j ) = 1 end if end if ! Define the V-cell applying the momentum exchange term if ( VCell % VofS ( i , j ) >= epsi . and . VCell % VofS ( i , j ) < 1.d0 - epsi ) then if ( j < jbeg + Jsize - 1 ) then if ( Pcell % VofS ( i , j ) >= 1.d0 - epsi . or . PCell % VofS ( i , j + 1 ) >= 1.d0 - epsi & . or . PCell % NEdge_Area ( i , j ) < epsiF ) then VCell % MoExCell ( i , j ) = 1 PCell % NEdge_Area ( i , j ) = 0.d0 PCell % SEdge_Area ( i , j + 1 ) = 0.d0 end if else if ( PCell % VofS ( i , j ) >= 1.d0 - epsi ) VCell % MoExCell ( i , j ) = 1 end if end if end do end do end subroutine DefineMomentumExchangeCell Subroutine NewCellFace ( PCell , UCell , VCell , PGrid , UGrid , VGrid ) IMPLICIT NONE TYPE ( Cell ), INTENT ( INOUT ) :: PCell , UCell , VCell TYPE ( Grid ), INTENT ( IN ) :: PGrid , UGrid , VGrid INTEGER ( kind = it4b ) :: i , j , k , ii , jj , temp REAL ( KIND = dp ) :: MaxFace INTEGER ( kind = it4b ), PARAMETER :: nx = 5 , ny = 5 REAL ( KIND = dp ) :: dxx , dyy , xx , yy , dd , Cdis , vol , delh , Sx , Sy REAL ( KIND = dp ) :: xf , yf , nxf , nyf , delh1 , delh2 , tol , tol1 REAL ( KIND = dp ), DIMENSION (:) :: phi ( 4 ) REAL ( KIND = dp ), DIMENSION (:,:) :: node ( 6 , 2 ) tol = 1.d-24 tol1 = 1.d-14 !   dxx = PGrid%delx/dble(nx) !   dyy = PGrid%dely/dble(ny) temp = 0 do i = ibeg , ibeg + Isize - 1 do j = jbeg , jbeg + Jsize - 1 if ( UCell % MoExCell ( i , j ) /= 1. and . UCell % VofS ( i , j ) > epsi ) then UCell % Cell_Cent ( i , j , 1 ) = PCell % FCE ( i , j , 1 ) - PGrid % dx ( i , j ) / 2.d0 UCell % Cell_Cent ( i , j , 2 ) = PCell % FCE ( i , j , 2 ) end if if ( VCell % MoExCell ( i , j ) /= 1. and . VCell % VofS ( i , j ) > epsi ) then VCell % Cell_Cent ( i , j , 1 ) = PCell % FCN ( i , j , 1 ) VCell % Cell_Cent ( i , j , 2 ) = PCell % FCN ( i , j , 2 ) - PGrid % dy ( i , j ) / 2.d0 end if end do end do do i = 1 , Isize do j = 1 , Jsize if ( UCell % MoExCell ( i , j ) == 1 ) then ! for very small UCell which connects to only one PCell if ( UCell % vofS ( i , j ) < 1.d0 - epsi ) then if ( UCell % NEdge_Area ( i , j ) * UCell % NEdge_Area ( i , j - 1 ) == 0.d0 ) then UCell % Cell_Cent ( i , j , 1 ) = UCell % FCN ( i , j , 1 ) * UCell % NEdge_Area ( i , j )& / ( UCell % NEdge_Area ( i , j ) + tol ) + & UCell % FCN ( i , j - 1 , 1 ) * UCell % NEdge_Area ( i , j - 1 )& / ( UCell % NEdge_Area ( i , j - 1 ) + tol ) else UCell % Cell_Cent ( i , j , 2 ) = UCell % FCE ( i , j , 2 ) * UCell % EEdge_Area ( i , j )& / ( UCell % EEdge_Area ( i , j ) + tol ) + & UCell % FCE ( i - 1 , j , 2 ) * UCell % EEdge_Area ( i - 1 , j )& / ( UCell % EEdge_Area ( i - 1 , j ) + tol ) UCell % Cell_Cent ( i , j , 1 ) =- ( UCell % nyS ( i , j ) * UCell % Cell_Cent ( i , j , 2 )& + UCell % phiS ( i , j )) / ( UCell % nxS ( i , j ) + tol ) end if if ( UCell % EEdge_Area ( i , j ) * UCell % EEdge_Area ( i - 1 , j ) == 0.d0 ) then UCell % Cell_Cent ( i , j , 2 ) = UCell % FCE ( i , j , 2 ) * UCell % EEdge_Area ( i , j )& / ( UCell % EEdge_Area ( i , j ) + tol ) + & UCell % FCE ( i - 1 , j , 2 ) * UCell % EEdge_Area ( i - 1 , j )& / ( UCell % EEdge_Area ( i - 1 , j ) + tol ) else UCell % Cell_Cent ( i , j , 2 ) =- ( UCell % nxS ( i , j ) * UCell % Cell_Cent ( i , j , 1 )& + UCell % phiS ( i , j )) / ( UCell % nyS ( i , j ) + tol ) end if else !   UCell%Cell_Cent(i,j,1) = 0.d0 !   UCell%Cell_Cent(i,j,2) = 0.d0 end if call CellLinking ( UGrid , UCell , i , j ) end if if ( VCell % MoExCell ( i , j ) == 1 ) then ! for very small VCell which connects to only one PCell if ( VCell % vofS ( i , j ) < 1.d0 - epsi ) then if ( VCell % NEdge_Area ( i , j ) * VCell % NEdge_Area ( i , j - 1 ) == 0.d0 ) then VCell % Cell_Cent ( i , j , 1 ) = VCell % FCN ( i , j , 1 ) * VCell % NEdge_Area ( i , j )& / ( VCell % NEdge_Area ( i , j ) + tol ) + & VCell % FCN ( i , j - 1 , 1 ) * VCell % NEdge_Area ( i , j - 1 )& / ( VCell % NEdge_Area ( i , j - 1 ) + tol ) else VCell % Cell_Cent ( i , j , 2 ) = VCell % FCE ( i , j , 2 ) * VCell % EEdge_Area ( i , j )& / ( VCell % EEdge_Area ( i , j ) + tol ) + & VCell % FCE ( i - 1 , j , 2 ) * VCell % EEdge_Area ( i - 1 , j )& / ( VCell % EEdge_Area ( i - 1 , j ) + tol ) VCell % Cell_Cent ( i , j , 1 ) =- ( VCell % Cell_Cent ( i , j , 2 ) * VCell % nyS ( i , j )& + VCell % phiS ( i , j )) / ( VCell % nxS ( i , j ) + tol ) end if if ( VCell % EEdge_Area ( i , j ) * VCell % EEdge_Area ( i - 1 , j ) == 0.d0 ) then VCell % Cell_Cent ( i , j , 2 ) = VCell % FCE ( i , j , 2 ) * VCell % EEdge_Area ( i , j )& / ( VCell % EEdge_Area ( i , j ) + tol ) + & VCell % FCE ( i - 1 , j , 2 ) * VCell % EEdge_Area ( i - 1 , j )& / ( VCell % EEdge_Area ( i - 1 , j ) + tol ) else VCell % Cell_Cent ( i , j , 2 ) =- ( VCell % Cell_Cent ( i , j , 1 ) * VCell % nxS ( i , j )& + VCell % phiS ( i , j )) / ( VCell % nyS ( i , j ) + tol ) end if else !    VCell%Cell_Cent(i,j,1) = 0.d0 !    VCell%Cell_Cent(i,j,2) = 0.d0 end if call CellLinking ( VGrid , VCell , i , j ) end if end do end do do i = 1 , Isize do j = 1 , Jsize ! For UCell !    if(i<Isize) then !      delh1=(UCell%Cell_Cent(i,j,1)+PGrid%dx(i,j)/2.d0)*PCell%nxS(i,j)+& !             UCell%Cell_Cent(i,j,2)*PCell%nyS(i,j)+PCell%phiS(i,j) !     delh2=(UCell%Cell_Cent(i,j,1)-PGrid%dx(i+1,j)/2.d0)*             & !             PCell%nxS(i+1,j)+UCell%Cell_Cent(i,j,2)*PCell%nyS(i+1,j)+ & !                                                      PCell%phiS(i+1,j) !      UCell%delh(i,j)=0.5d0*dabs(delh1+delh2)+tol1 !      if(PCell%vofS(i,j)>1.d0-epsi.or.PCell%vofS(i,j)<epsi) then !        UCell%delh(i,j)=dabs(delh2)+tol1 !      end if !      if(PCell%vofS(i+1,j)>1.d0-epsi.or.PCell%vofS(i+1,j)<epsi) then !        UCell%delh(i,j)=dabs(delh1)+tol1 !      end if !    else UCell % delh ( i , j ) = dabs ( UCell % Cell_Cent ( i , j , 1 ) * UCell % nxS ( i , j ) + & UCell % Cell_Cent ( i , j , 2 ) * UCell % nyS ( i , j ) + UCell % phiS ( i , j )) + tol if ( UCell % MoExCell ( i , j ) == 1 ) UCell % delh ( i , j ) = 1.d-20 !    end if ! For VCell !    if(j<Jsize) then !      delh1=VCell%Cell_Cent(i,j,1)*PCell%nxS(i,j)+                     & !           (VCell%Cell_Cent(i,j,2)+PGrid%dy(i,j)/2.d0)*                & !                                   PCell%nyS(i,j)+PCell%phiS(i,j) !      delh2=VCell%Cell_Cent(i,j,1)*PCell%nxS(i,j+1)+                   & !           (VCell%Cell_Cent(i,j,2)-PGrid%dy(i,j+1)/2.d0)*              & !                                   PCell%nyS(i,j+1)+PCell%phiS(i,j+1) !      VCell%delh(i,j)=0.5d0*dabs(delh1+delh2)+tol1 !      if(PCell%vofS(i,j)>1.d0-epsi.or.PCell%vofS(i,j)<epsi) then !         VCell%delh(i,j)=dabs(delh2)+tol1 !       end if !       if(PCell%vofS(i,j+1)>1.d0-epsi.or.PCell%vofS(i,j+1)<epsi) then !         VCell%delh(i,j)=dabs(delh1)+tol1 !       end if !     else VCell % delh ( i , j ) = dabs ( VCell % Cell_Cent ( i , j , 1 ) * VCell % nxS ( i , j ) + & VCell % Cell_Cent ( i , j , 2 ) * VCell % nyS ( i , j ) + VCell % phiS ( i , j )) + tol if ( VCell % MoExCell ( i , j ) == 1 ) VCell % delh ( i , j ) = 1.d-20 !    end if UCell % WlLh ( i , j ) = dsqrt ((( UCell % EEdge_Area ( i , j ) - UCell % WEdge_Area ( i , j ))& * UGrid % dx ( i , j )) ** 2.d0 + (( UCell % NEdge_Area ( i , j ) - & UCell % SEdge_Area ( i , j )) * UGrid % dy ( i , j )) ** 2.d0 ) VCell % WlLh ( i , j ) = dsqrt ((( VCell % EEdge_Area ( i , j ) - VCell % WEdge_Area ( i , j ))& * VGrid % dx ( i , j )) ** 2.d0 + (( VCell % NEdge_Area ( i , j ) - & VCell % SEdge_Area ( i , j )) * VGrid % dy ( i , j )) ** 2.d0 ) end do end do ! Define other Coefficients which are used for convective flux and diffusive calculation ! For UCell call EastFaceInterpolationInf ( UCell , UGrid , PGrid , 1 ) call NorthFaceInterpolationInf ( UCell , UGrid , VGrid , 0 ) call EastFaceInterpolationInf ( VCell , VGrid , UGrid , 0 ) call NorthFaceInterpolationInf ( VCell , VGrid , PGrid , 1 ) end subroutine NewCellFace SUBROUTINE EastFaceInterpolationInf ( TCell , TGrid , BGrid , iu ) IMPLICIT NONE TYPE ( Grid ), INTENT ( IN ) :: TGrid , BGrid TYPE ( Cell ), INTENT ( INOUT ) :: TCell INTEGER ( kind = it4b ), INTENT ( IN ) :: iu INTEGER ( kind = it4b ) :: i , j REAL ( KIND = dp ) :: IntPointDist , FaceCenterDist , Sy , xf , yf , nxf , nyf , Sx do j = 1 , Jsize do i = 1 , Isize - 1 if ( TCell % Posnu ( i , j ) /=- 1. and . TCell % Posnu ( i + 1 , j ) /=- 1 ) then TCell % SxE ( i , j ) = TCell % Cell_Cent ( i + 1 , j , 1 ) + BGrid % dx ( i + iu , j ) - & TCell % Cell_Cent ( i , j , 1 ) Sy = TCell % Cell_Cent ( i + 1 , j , 2 ) - TCell % Cell_Cent ( i , j , 2 ) TCell % EtaE ( i , j ) = dabs ( TCell % FCE ( i , j , 1 ) - TCell % Cell_Cent ( i , j , 1 )) / & TCell % SxE ( i , j ) if ( TCell % EtaE ( i , j ) >= 1.d0 ) TCell % EtaE ( i , j ) = 0.5d0 xf = ( 1.d0 - TCell % EtaE ( i , j )) * TCell % Cell_Cent ( i , j , 1 ) + TCell % EtaE ( i , j ) * & ( TCell % Cell_Cent ( i + 1 , j , 1 ) + BGrid % dx ( i + iu , j )) yf = ( 1.d0 - TCell % EtaE ( i , j )) * TCell % Cell_Cent ( i , j , 2 ) + TCell % EtaE ( i , j ) * & TCell % Cell_Cent ( i + 1 , j , 2 ) !      nxf=xf/dsqrt(xf**2.d0+yf**2.d0) !      nyf=yf/dsqrt(xf**2.d0+yf**2.d0) if ( dabs ( Sy ) > 0.0001d0 * TGrid % dy ( i , j )) then nxf = 0.5d0 * ( TCell % nxS ( i , j ) + TCell % nxS ( i + 1 , j )) nyf = 0.5d0 * ( TCell % nyS ( i , j ) + TCell % nyS ( i + 1 , j )) IntPointDist = 0.5d0 * ( dabs ( xf * TCell % nxS ( i , j ) + yf * TCell % nyS ( i , j ) + & TCell % phiS ( i , j )) + dabs (( xf - BGrid % dx ( i + iu , j )) * & TCell % nxS ( i + 1 , j ) + yf * TCell % nyS ( i + 1 , j ) + TCell % phiS ( i + 1 , j ))) FaceCenterDist = 0.5d0 * ( dabs ( TCell % FCE ( i , j , 1 ) * TCell % nxS ( i , j ) + & TCell % FCE ( i , j , 2 ) * TCell % nyS ( i , j ) + TCell % phiS ( i , j )) + & dabs (( TCell % FCE ( i , j , 1 ) - BGrid % dx ( i + iu , j )) * TCell % nxS ( i + 1 , j ) + & TCell % FCE ( i , j , 2 ) * TCell % nyS ( i + 1 , j ) + TCell % phiS ( i + 1 , j ))) TCell % AlE ( i , j ) = dabs ( FaceCenterDist ) / dabs ( IntPointDist ) TCell % DAlE ( i , j ) = Sy * nyf / ( TCell % SxE ( i , j ) * dabs ( IntPointDist )) !              if(TCell%AlE(i,j)>1.5d0) TCell%AlE(i,j)=1.5d0 if ( dabs ( IntPointDist ) < 1.d-5 ) then TCell % DalE ( i , j ) = 0.d0 TCell % AlE ( i , j ) = 1.d0 end if if ( TCell % AlE ( i , j ) >= 2.d0 ) TCell % AlE ( i , j ) = 2.d0 !  if(TCell%MoExCell(i,j)==1.or.TCell%MoExCell(i+1,j)==1) then !    TCell%DAlE(i,j) = 0.d0 !    TCell%AlE(i,j) = 1.d0 !  end if else TCell % DAlE ( i , j ) = 0.d0 TCell % AlE ( i , j ) = 1.d0 end if !     TCell%AlE(i,j)=1.d0 else TCell % AlE ( i , j ) = 1.d0 TCell % DalE ( i , j ) = 0.d0 TCell % SxE ( i , j ) = BGrid % dx ( i + iu , j ) TCell % EtaE ( i , j ) = 0.5d0 end if end do TCell % SxE ( i , j ) = TCell % SxE ( i - 1 , j ) TCell % EtaE ( i , j ) = TCell % EtaE ( i - 1 , j ) TCell % DAlE ( i , j ) = TCell % DAlE ( i - 1 , j ) TCell % AlE ( i , j ) = TCell % AlE ( i - 1 , j ) TCell % SxE ( 0 , j ) = TCell % SxE ( 1 , j ) TCell % EtaE ( 0 , j ) = TCell % EtaE ( 1 , j ) TCell % DAlE ( 0 , j ) = TCell % DAlE ( 1 , j ) TCell % AlE ( 0 , j ) = TCell % AlN ( 1 , j ) end do END SUBROUTINE EastFaceInterpolationInf SUBROUTINE NorthFaceInterpolationInf ( TCell , TGrid , BGrid , iv ) IMPLICIT NONE TYPE ( Grid ), INTENT ( IN ) :: TGrid , BGrid TYPE ( Cell ), INTENT ( INOUT ) :: TCell INTEGER ( kind = it4b ), INTENT ( IN ) :: iv INTEGER ( kind = it4b ) :: i , j REAL ( KIND = dp ) :: IntPointDist , FaceCenterDist , xf , yf , nxf , nyf , Sx do i = 1 , Isize do j = 1 , Jsize - 1 if ( TCell % Posnu ( i , j ) /=- 1. and . TCell % Posnu ( i , j + 1 ) /=- 1 ) then TCell % SyN ( i , j ) = TCell % Cell_Cent ( i , j + 1 , 2 ) + BGrid % dy ( i , j + iv ) - & TCell % Cell_Cent ( i , j , 2 ) Sx = TCell % Cell_Cent ( i , j + 1 , 1 ) - TCell % Cell_Cent ( i , j , 1 ) TCell % EtaN ( i , j ) = dabs ( TCell % FCN ( i , j , 2 ) - TCell % Cell_Cent ( i , j , 2 )) / & TCell % SyN ( i , j ) if ( TCell % EtaN ( i , j ) >= 1.d0 ) TCell % EtaN ( i , j ) = 0.5d0 xf = ( 1.d0 - TCell % EtaN ( i , j )) * TCell % Cell_Cent ( i , j , 1 ) + TCell % EtaN ( i , j ) * & TCell % Cell_Cent ( i , j + 1 , 1 ) yf = ( 1.d0 - TCell % EtaN ( i , j )) * TCell % Cell_Cent ( i , j , 2 ) + TCell % EtaN ( i , j ) * & ( TCell % Cell_Cent ( i , j + 1 , 2 ) + BGrid % dy ( i , j + iv )) !    nxf=xf/dsqrt(xf**2.d0+yf**2.d0) !    nyf=yf/dsqrt(xf**2.d0+yf**2.d0) if ( dabs ( Sx ) >= 0.0001d0 * TGrid % dx ( i , j )) then nxf = 0.5d0 * ( TCell % nxS ( i , j ) + TCell % nxS ( i , j + 1 )) nyf = 0.5d0 * ( TCell % nyS ( i , j ) + TCell % nyS ( i , j + 1 )) IntPointDist = 0.5d0 * ( dabs ( xf * TCell % nxS ( i , j ) + yf * TCell % nyS ( i , j ) + & TCell % phiS ( i , j )) + dabs ( xf * TCell % nxS ( i , j + 1 ) + & ( yf - BGrid % dy ( i , j + iv )) * TCell % nyS ( i , j + 1 ) + TCell % phiS ( i , j + 1 ))) FaceCenterDist = 0.5d0 * ( dabs ( TCell % FCN ( i , j , 1 ) * TCell % nxS ( i , j ) + & TCell % FCN ( i , j , 2 ) * TCell % nyS ( i , j ) + TCell % phiS ( i , j )) + & dabs ( TCell % FCN ( i , j , 1 ) * TCell % nxS ( i , j + 1 ) + ( TCell % FCN ( i , j , 2 ) - & BGrid % dy ( i , j + iv )) * TCell % nyS ( i , j + 1 ) + TCell % phiS ( i , j + 1 ))) TCell % AlN ( i , j ) = dabs ( IntPointDist ) / dabs ( FaceCenterDist ) TCell % DAlN ( i , j ) = Sx * nxf / ( TCell % SyN ( i , j ) * dabs ( IntPointDist )) !    if(TCell%AlN(i,j)>1.5d0) TCell%AlN=1.5d0 if ( dabs ( IntPointDist ) < 1.d-5 ) then TCell % DAlN ( i , j ) = 0.d0 TCell % AlN ( i , j ) = 1.d0 end if if ( TCell % AlN ( i , j ) >= 2.d0 ) TCell % AlN ( i , j ) = 2.d0 ! if(TCell%MoExCell(i,j)==1.or.TCell%MoExCell(i,j+1)==1) then !   TCell%DAlN(i,j)=0.d0 !   TCell%AlN(i,j)=1.d0 ! end if else TCell % DAlN ( i , j ) = 0.d0 TCell % AlN ( i , j ) = 1.d0 end if if ( isnan ( TCell % DAlN ( i , j ))) then print * , i , j print * , iv print * , print * , TCell % MoExCell ( i , j ) print * , print * , TCell % nxS ( i , j ), TCell % nyS ( i , j ) print * , TCell % phiS ( i , j ) print * , print * , TCell % vofS ( i , j ), TCell % vofS ( i , j + 1 ) print * , print * , TCell % Cell_Cent ( i , j + 1 , 1 ), TCell % Cell_Cent ( i , j , 1 ) print * , TCell % Cell_Cent ( i , j + 1 , 2 ), TCell % Cell_Cent ( i , j , 2 ) print * , print * , Sx , nxf print * , 'CutCell_615' end if !      TCell%AlN(i,j)=1.d0 else TCell % EtaN ( i , j ) = 0.5d0 TCell % AlN ( i , j ) = 1.d0 TCell % DAlN ( i , j ) = 0.d0 TCell % SyN ( i , j ) = BGrid % dy ( i , j + iv ) end if end do TCell % SyN ( i , j ) = TCell % SyN ( i , j - 1 ) TCell % EtaN ( i , j ) = TCell % EtaN ( i , j - 1 ) TCell % DAlN ( i , j ) = TCell % DAlN ( i , j - 1 ) TCell % AlN ( i , j ) = TCell % AlN ( i , j - 1 ) TCell % SyN ( i , 0 ) = TCell % SyN ( i , 1 ) TCell % EtaN ( i , 0 ) = TCell % EtaN ( i , 1 ) TCell % DAlN ( i , 0 ) = TCell % DAlN ( i , 1 ) TCell % AlN ( i , 0 ) = TCell % AlN ( i , 1 ) end do END SUBROUTINE NorthFaceInterpolationInf SUBROUTINE CellLinking ( TGrid , TCell , i , j ) IMPLICIT NONE INTEGER ( kind = it4b ), INTENT ( IN ) :: i , j TYPE ( Grid ), INTENT ( IN ) :: TGrid TYPE ( Cell ), INTENT ( INOUT ) :: TCell INTEGER ( kind = it4b ) :: ii , jj REAL ( KIND = dp ) :: tol tol = 1.d-10 ii = i + INT ( sign ( 1.d0 , TCell % nxS ( i , j ))) jj = j + INT ( sign ( 1.d0 , TCell % nyS ( i , j ))) if ( TCell % vofS ( ii , j ) < TCell % VofS ( i , jj )) then TCell % MsCe ( i , j , 1 ) = ii TCell % MsCe ( i , j , 2 ) = j !   TCell%Cell_Cent(i,j,1)=TCell%Cell_Cent(ii,j,1)+                      & !    dabs(TGrid%x(ii,j)-TGrid%x(i,j))*(1.d0-tol)*dsign(1.d0,TCell%nxS(i,j)) !   TCell%Cell_Cent(i,j,2)=TCell%Cell_Cent(ii,j,2) else TCell % MsCe ( i , j , 1 ) = i TCell % MsCe ( i , j , 2 ) = jj !   TCell%Cell_Cent(i,j,1)=TCell%Cell_Cent(i,jj,1) !   TCell%Cell_Cent(i,j,2)=TCell%Cell_Cent(i,jj,2)+                      & !    dabs(TGrid%y(i,jj)-TGrid%y(i,j))*(1.d0-tol)*dsign(1.d0,TCell%nyS(i,j)) end if END SUBROUTINE CellLinking End module Cutcell","tags":"","loc":"sourcefile/cutcell_mod.f90.html","title":"Cutcell_Mod.f90 – Fortran Program"},{"text":"Contents Modules Mesh Source Code Mesh_Mod.f90 Source Code Module Mesh USE PrecisionVar USE MPI PRIVATE INTEGER ( kind = it4b ), PUBLIC :: ibeg = 1 , jbeg = 1 INTEGER ( kind = it4b ), PUBLIC :: Isize , Jsize TYPE , PUBLIC :: Point REAL ( KIND = dp ) :: x , y End TYPE Point TYPE , PUBLIC :: Grid INTEGER * 8 :: Grid_Id REAL ( KIND = dp ), DIMENSION (:,:), allocatable :: x , y , dx , dy REAL ( KIND = dp ) :: Lref End TYPE Grid TYPE , PUBLIC :: Cell ! cell_TYPE: 0 fluid cell and not target cell !            1 boudary cell !            2 solid cell ! cell number for Poisson solving equation only for Pressure cell INTEGER ( kind = it4b ), DIMENSION (:,:), allocatable :: PosNu , MoExCell INTEGER ( kind = it4b ) :: ExtCell ! Cell number of Implicit solving for diffusive term for u-velocity and v-velocity ! Volume fraction of liquid and level set function ! Volume fraction of Solid and level set function vofS,phiS REAL ( KIND = dp ), DIMENSION (:,:), allocatable :: Vof , Phi , VofS , PhiS ! normal vector of Interface and Solid Boundary REAL ( KIND = dp ), DIMENSION (:,:), allocatable :: nx , ny , nxS , nyS ! the center of cell ! the area of edge in x,y direction REAL ( KIND = dp ), DIMENSION (:,:), allocatable :: EEdge_Area , WEdge_Area REAL ( KIND = dp ), DIMENSION (:,:), allocatable :: NEdge_Area , SEdge_Area REAL ( KIND = dp ), DIMENSION (:,:,:), allocatable :: Cell_Cent , MsCe ! the cellface center of velocity cell REAL ( KIND = dp ), DIMENSION (:,:), allocatable :: WlLh , delh REAL ( KIND = dp ), DIMENSION (:,:,:), allocatable :: FCE , FCN REAL ( KIND = dp ), DIMENSION (:,:), allocatable :: EtaE , EtaN , DAlE , DAlN REAL ( KIND = dp ), DIMENSION (:,:), allocatable :: AlE , AlN , SxE , SyN ! the cellface center of velocity cell End TYPE PUBLIC :: Initial_Grid , HYPRE_CreateGrid , InitialUVGrid Interface Initial_Grid Module procedure Initial_Grid End interface Interface HYPRE_CreateGrid Module procedure HYPRE_CreateGrid End interface Interface InitialUVGrid Module procedure InitialUVGrid End interface Contains Subroutine Initial_Grid ( Start_Point , End_Point , ReS , ReE , NI , NJ , Irec , Jrec , & TGrid , Lref , NonUniformMesh ) IMPLICIT NONE TYPE ( Grid ), INTENT ( INOUT ) :: TGrid TYPE ( Point ), INTENT ( IN ) :: Start_Point , End_Point , ReS , ReE REAL ( KIND = dp ), INTENT ( IN ) :: Lref INTEGER ( kind = it4b ), INTENT ( IN ) :: Irec , Jrec , NI , NJ INTEGER ( kind = it4b ), INTENT ( IN ) :: NonUniformMesh REAL ( KIND = dp ), DIMENSION (:), allocatable :: x , y INTEGER :: i , j , IJsizeS , IJsizeE REAL ( KIND = dp ) :: beta , dx , dy , dl allocate ( x ( NI )) allocate ( y ( NJ )) TGrid % Lref = Lref ! for y-direction if ( NonUniformMesh == 1 ) then dy = ( ReE % y - ReS % y ) / dble ( Jrec - 1 ) dl = ReS % y - Start_Point % y !  find the number of grid points from bottom wall to grid refining region IJsizeS = ( NJ - Jrec ) * dabs ( ReS % y - Start_Point % y ) / & ( dabs ( ReS % y - Start_Point % y ) + dabs ( End_Point % y - ReE % y )) call NewtonRaphson ( beta , dl , dy , IJsizeS ) y ( jbeg ) = Start_Point % y do j = jbeg + 1 , jbeg + ibeg + IJsizeS y ( j ) = y ( j - 1 ) + dy * beta ** ( IJsizeS - ( j - jbeg - 1 )) end do !  the grid refining region do j = jbeg + IJsizeS + 1 , jbeg + IJsizeS + Jrec - 1 y ( j ) = y ( j - 1 ) + dy end do dl = End_Point % y - ReE % y IJsizeE = ( NJ - Jrec ) - IJsizeS !  the section from the grid refining region to open air call NewtonRaphson ( beta , dl , dy , IJsizeE ) do j = jbeg + IJsizeS + Jrec , NJ y ( j ) = y ( j - 1 ) + dy * beta ** ( j - ( jbeg + IJsizeS + Jrec - 1 )) end do else dy = ( End_Point % y - Start_Point % y ) / dble ( NJ - 1 ) do j = 1 , NJ y ( j ) = Start_Point % y + dy * dble ( j - 1 ) end do end if ! For x-direction if ( NonUniformMesh == 1 ) then dx = ( ReE % x - ReS % x ) / ( Irec - 1 ) dl = ReS % x - Start_Point % x !  find the number of grid points from inlet to grid refining region IJsizeS = ( NI - Irec ) * dabs ( ReS % x - Start_Point % x ) / & ( dabs ( ReS % x - Start_Point % x ) + dabs ( End_Point % x - ReE % x )) call NewtonRaphson ( beta , dl , dx , IJsizeS ) x ( ibeg ) = Start_Point % x do i = ibeg + 1 , ibeg + IJsizeS x ( i ) = x ( i - 1 ) + dx * beta ** ( IJsizeS - ( i - ibeg - 1 )) end do !  the grid refining region do i = ibeg + IJsizeS + 1 , ibeg + IJsizeS + Irec - 1 x ( i ) = x ( i - 1 ) + dx end do dl = End_Point % x - ReE % x IJsizeE = ( NI - Irec ) - IJsizeS !  the section from the grid refining region to outlet call NewtonRaphson ( beta , dl , dx , IJsizeE ) do i = ibeg + IJsizeS + Irec , NI x ( i ) = x ( i - 1 ) + dx * beta ** ( i - ( ibeg + IJsizeS + Irec - 1 )) end do else dx = ( End_Point % x - Start_Point % x ) / dble ( NI - 1 ) do i = 1 , NI x ( i ) = Start_Point % x + dx * dble ( i - 1 ) end do end if do i = ibeg , ibeg + NI - 2 do j = jbeg , jbeg + NJ - 2 TGrid % x ( i , j ) = 0.5d0 * ( x ( i + 1 ) + x ( i )) TGrid % dx ( i , j ) = x ( i + 1 ) - x ( i ) TGrid % y ( i , j ) = 0.5d0 * ( y ( j + 1 ) + y ( j )) TGrid % dy ( i , j ) = y ( j + 1 ) - y ( j ) end do end do deallocate ( x , y ) end subroutine Initial_Grid subroutine InitialUVGrid ( PGrid , TGrid , UV , Lref ) IMPLICIT NONE TYPE ( Grid ), INTENT ( IN ) :: PGrid TYPE ( Grid ), INTENT ( INOUT ) :: TGrid REAL ( KIND = dp ), INTENT ( IN ) :: Lref INTEGER ( kind = it4b ), INTENT ( IN ) :: UV INTEGER :: i , j ! for UGrid TGrid % Lref = Lref if ( UV == 0 ) then do i = ibeg , Isize do j = jbeg , Jsize TGrid % x ( i , j ) = PGrid % x ( i , j ) + 0.5d0 * PGrid % dx ( i , j ) TGrid % y ( i , j ) = PGrid % y ( i , j ) TGrid % dy ( i , j ) = PGrid % dy ( i , j ) if ( i < Isize ) then TGrid % dx ( i , j ) = PGrid % x ( i + 1 , j ) - PGrid % x ( i , j ) else TGrid % dx ( i , j ) = PGrid % dx ( i , j ) end if end do end do else do i = ibeg , Isize do j = jbeg , Jsize TGrid % x ( i , j ) = Pgrid % x ( i , j ) TGrid % y ( i , j ) = PGrid % y ( i , j ) + 0.5d0 * PGrid % dy ( i , j ) Tgrid % dx ( i , j ) = PGrid % dx ( i , j ) if ( j < Jsize ) then TGrid % dy ( i , j ) = PGrid % y ( i , j + 1 ) - PGrid % y ( i , j ) else TGrid % dy ( i , j ) = PGrid % dy ( i , j ) end if end do end do end if end subroutine subroutine HYPRE_CreateGrid ( TGrid ) IMPLICIT NONE TYPE ( Grid ), INTENT ( INOUT ) :: TGrid INTEGER :: ilower ( 0 : 1 ), iupper ( 0 : 1 ) ilower ( 0 ) = ibeg ilower ( 1 ) = jbeg iupper ( 0 ) = ibeg + Isize - 1 iupper ( 1 ) = jbeg + Jsize - 1 call HYPRE_StructGridCreate ( MPI_COMM_WORLD , 2 , TGrid % Grid_Id , ierr ) call HYPRE_StructGridSetExtents ( TGrid % Grid_Id , ilower , iupper , ierr ) call HYPRE_StructGridAssemble ( TGrid % Grid_Id , ierr ) end subroutine HYPRE_CreateGrid subroutine NewtonRaphson ( beta , dl , dx , IJsize ) REAL ( KIND = dp ), INTENT ( INOUT ) :: beta REAL ( KIND = dp ), INTENT ( IN ) :: dl , dx INTEGER ( kind = it4b ), INTENT ( IN ) :: IJsize REAL ( KIND = dp ) :: tol , fx , dfx tol = 1.d0 beta = 1.001d0 do while ( tol > 1.d-14 ) fx = dx * ( beta ** ( IJsize + 1 ) - beta ) / ( beta - 1.d0 ) - dl dfx = dx * ( IJsize * beta ** ( IJsize + 1 ) - ( IJsize + 1 ) * beta ** IJsize + 1 ) / ( beta - 1 ) ** 2.d0 tol = dabs ( fx / dfx ) beta = beta - fx / dfx end do end subroutine end module Mesh","tags":"","loc":"sourcefile/mesh_mod.f90.html","title":"Mesh_Mod.f90 – Fortran Program"},{"text":"Contents Modules Particles Source Code Particles.f90 Source Code Module Particles USE PrecisionVar USE MPI USE Mesh USE StateVariables USE Clsvof , ONLY : vofeps , SolidObject PRIVATE INTEGER ( kind = it4b ), PARAMETER :: itp = 10 REAL ( KIND = dp ), PARAMETER :: tol = 1.d-20 , Ca = 0.5d0 TYPE , PRIVATE :: ParVel REAL ( KIND = dp ) :: u , v End TYPE ParVel TYPE , PUBLIC :: Particle INTEGER ( kind = it4b ) :: np TYPE ( Point ), DIMENSION (:), allocatable :: Posp TYPE ( ParVel ), DIMENSION (:), allocatable :: uvp REAL ( KIND = dp ), DIMENSION (:), allocatable :: mp , dp , tp ! For secondary break up REAL ( KIND = dp ), DIMENSION (:), allocatable :: t REAL ( KIND = dp ), DIMENSION (:), allocatable :: VrelG , y , dydt End TYPE Particle PUBLIC :: TrackingParticles , InitializeParticles , ParticlePosition , Drag , ParticleInletCondition Interface TrackingParticles Module Procedure TrackingParticles End interface Interface InitializeParticels Module procedure InitializeParticles End interface Interface ParticlePosition Module procedure ParticlePosition End interface Interface ParticleInletCondition Module procedure ParticleInletCondition End interface Interface Drag Module procedure Drag End interface Contains Subroutine InitializeParticles ( Pgrid , Var , TraPar ) IMPLICIT NONE TYPE ( Grid ), INTENT ( IN ) :: PGrid TYPE ( Variables ), INTENT ( IN ) :: Var TYPE ( Particle ), INTENT ( INOUT ) :: TraPar INTEGER :: i REAL ( KIND = dp ) :: DragFC REAL ( KIND = dp ), DIMENSION (:), allocatable :: ranum allocate ( ranum ( TraPar % np )) call Random_Number ( ranum ) DragFC = 1 8.d0 do i = 1 , TraPar % np TraPar % dp ( i ) = 1.d-6 + 0.008d0 * ranum ( i ) end do call Random_Number ( ranum ) do i = 1 , TraPar % np TraPar % Posp ( i )% x = ( PGrid % x ( 10 , 1 ) + ( PGrid % x ( Isize , 1 ) - PGrid % x ( 350 , 1 )) * ranum ( i )) * Lref end do call Random_Number ( ranum ) do i = 1 , TraPar % np TraPar % Posp ( i )% y = ( PGrid % y ( 1 , 2 ) + ( PGrid % y ( 1 , Jsize ) - PGrid % y ( 1 , 80 )) * ranum ( i )) * Lref end do !  No contribution of particles !****************************** do i = 1 , TraPar % np TraPar % mp ( i ) = 1.d0 / 6.d0 * pi * ( TraPar % dp ( i )) ** 3.d0 * row TraPar % tp ( i ) = row * TraPar % dp ( i ) ** 2.d0 / DragFC / ( nua * roa ) TraPar % uvp ( i )% u = 2 0.d0 TraPar % uvp ( i )% v = 0.d0 end do deallocate ( ranum ) end subroutine InitializeParticles subroutine TrackingParticles ( PGrid , PCell , BoomCase , Var , dt , TraPar ) IMPLICIT NONE TYPE ( Grid ), INTENT ( IN ) :: PGrid TYPE ( Cell ), INTENT ( IN ) :: PCell TYPE ( SolidObject ), INTENT ( INOUT ) :: BoomCase TYPE ( Variables ), INTENT ( IN ) :: Var REAL ( KIND = dp ), INTENT ( IN ) :: dt TYPE ( Particle ), INTENT ( INOUT ) :: TraPar INTEGER ( kind = it4b ) :: i , ii , jj , itep REAL ( KIND = dp ), DIMENSION (:), allocatable :: Upo , Upn , Vpo , Vpn , axp , ayp TYPE ( Point ), DIMENSION (:), allocatable :: xyp REAL ( KIND = dp ) :: dudx , dvdy , ug , vg , ug0 , vg0 , VRel , Reyp , Cd REAL ( KIND = dp ) :: tp , FXT , EXPT , Spx , Spy , dtp , gama , nupp , ropp , beta , sig allocate ( Upo ( TraPar % np )) allocate ( Vpo ( TraPar % np )) allocate ( Upn ( TraPar % np )) allocate ( Vpn ( TraPar % np )) allocate ( xyp ( TraPar % np )) allocate ( axp ( TraPar % np )) allocate ( ayp ( TraPar % np )) dtp = dt * ( PGrid % Lref / Var % Uref ) / dble ( itp ) do i = 1 , TraPar % np xyp ( i )% x = TraPar % Posp ( i )% x xyp ( i )% y = TraPar % PosP ( i )% y Upo ( i ) = TraPar % uvp ( i )% u VPo ( i ) = TraPar % uvp ( i )% v end do do itep = 1 , itp do i = 1 , TraPar % np call ParticlePosition ( TraPar % Posp ( i ), PGrid , ii , jj ) if ( ii /=- 1. and . jj /=- 1 ) then if ( TraPar % PosP ( i )% x / Lref < PGrid % x ( Isize , 1 ). and . & TraPar % PosP ( i )% y / Lref < PGrid % y ( 1 , Jsize ). and . & PCell % vofS ( ii , jj ) < 1.d0 - epsi ) then ropp = row * PCell % vof ( ii , jj ) / ( 1.d0 - PCell % vofS ( ii , jj ) + tol ) + & roa * ( 1.d0 - PCell % vof ( ii , jj ) - PCell % vofS ( ii , jj )) / & ( 1.d0 - PCell % vofS ( ii , jj ) + tol ) gama = rop / ropp nupp = nuw * PCell % vof ( ii , jj ) / ( 1.d0 - PCell % vofS ( ii , jj ) + tol ) + & nua * ( 1.d0 - PCell % vof ( ii , jj ) - PCell % vofS ( ii , jj )) / & ( 1.d0 - PCell % vofS ( ii , jj ) + tol ) dudx = ( Var % u ( ii , jj ) - Var % u ( ii - 1 , jj )) / PGrid % dx ( ii , jj ) dvdy = ( Var % v ( ii , jj ) - Var % v ( ii , jj - 1 )) / PGrid % dy ( ii , jj ) ug0 = 0.5d0 * ( Var % u ( ii , jj ) + Var % u ( ii - 1 , jj )) vg0 = 0.5d0 * ( Var % v ( ii , jj ) + Var % v ( ii , jj - 1 )) ug = ( ug0 + dudx * ( TraPar % Posp ( i )% x / Lref - PGrid % x ( ii , jj ))) * Var % Uref vg = ( vg0 + dvdy * ( TraPar % Posp ( i )% y / Lref - PGrid % y ( ii , jj ))) * Var % Uref VRel = dsqrt (( upo ( i ) - ug ) ** 2.d0 + ( vpo ( i ) - vg ) ** 2.d0 ) if ( VRel < 1.d-7 ) VRel = 1.d-7 Reyp = TraPar % dp ( i ) * VRel / nupp Cd = Drag ( Reyp ) axp ( i ) = ( 1.d0 - gama ) / ( gama + Ca ) * gx - 3.d0 * Cd / 8.d0 / ( TraPar % dp ( i ) / 2.d0 ) / & ( gama + Ca ) * ( upo ( i ) - ug ) * dsqrt (( upo ( i ) - ug ) ** 2.d0 + ( vpo ( i ) - vg ) ** 2.d0 ) ayp ( i ) = ( 1.d0 - gama ) / ( gama + Ca ) * gy - 3.d0 * Cd / 8.d0 / ( TraPar % dp ( i ) / 2.d0 ) / & ( gama + Ca ) * ( vpo ( i ) - vg ) * dsqrt (( upo ( i ) - ug ) ** 2.d0 + ( vpo ( i ) - vg ) ** 2.d0 ) !   Upn(i)=Upo(i)+axp(i)*dtp !   Vpn(i)=Vpo(i)+ayp(i)*dtp sig = ( 1.d0 - gama ) / ( gama + Ca ) * gx beta = 3.d0 * Cd / 8.d0 / ( TraPar % dp ( i ) / 2.d0 ) / ( gama + Ca ) * & dsqrt (( upo ( i ) - ug ) ** 2.d0 + ( vpo ( i ) - vg ) ** 2.d0 ) Upn ( i ) = Upo ( i ) * exp ( - beta * dtp ) + ug * ( 1.d0 - exp ( - beta * dtp )) + & sig / beta * ( 1.d0 - exp ( - beta * dtp )) xyp ( i )% x = xyp ( i )% x + 0.5d0 * ( Upn ( i ) + Upo ( i )) * dtp sig = ( 1.d0 - gama ) / ( gama + Ca ) * gy Vpn ( i ) = Vpo ( i ) * exp ( - beta * dtp ) + vg * ( 1.d0 - exp ( - beta * dtp )) + & sig / beta * ( 1.d0 - exp ( - beta * dtp )) xyp ( i )% y = xyp ( i )% y + 0.5d0 * ( Vpn ( i ) + Vpo ( i )) * dtp if ( isnan ( Upo ( i )). or . dabs ( xyp ( i )% x ) > 1.d10 . or . dabs ( axp ( i )) > 1.d10 . or . & isnan ( upn ( i )). or . isnan ( vpn ( i ))) then print * , i print * , axp ( i ), dtp print * , print * ,( 1.d0 - gama ) / ( gama + Ca ) * gx , 3.d0 * Cd / 8.d0 / ( TraPar % dp ( i ) / 2.d0 ) / & ( gama + Ca ) * ( upo ( i ) - ug ) * dsqrt (( upo ( i ) - ug ) ** 2.d0 + ( vpo ( i ) - vg ) ** 2.d0 ) print * , 3.d0 * Cd / 8.d0 ,( TraPar % dp ( i ) / 2.d0 ) print * ,( gama + Ca ) * ( upo ( i ) - ug ) * dsqrt (( upo ( i ) - ug ) ** 2.d0 + ( vpo ( i ) - vg ) ** 2.d0 ) print * , print * , Reyp print * , print * , 'What the fuck' print * , TraPar % uvp ( i )% u , TraPar % uvp ( i )% v print * , nupp print * , PCell % vof ( ii , jj ) / ( 1.d0 - PCell % vofS ( ii , jj ) + tol ) print * ,( 1.d0 - PCell % vof ( ii , jj ) - PCell % vofS ( ii , jj )) / & ( 1.d0 - PCell % vofS ( ii , jj ) + tol ) print * , print * , Upo ( i ), exp ( - beta * dtp ), ug * ( 1.d0 - exp ( - beta * dtp )) print * , sig , beta ,( 1.d0 - exp ( - beta * dtp )) print * , upn ( i ), upo ( i ) print * , print * , dudx , dvdy print * , print * , beta , sig , exp ( - beta * dtp ) print * , print * ,( 1.d0 - gama ),( gama + Ca ) print * , gama , gx print * , Cd ,( TraPar % dp ( i ) / 2.d0 ) print * , upo ( i ), ug print * , ug0 , Var % u ( ii , jj ), Var % u ( ii - 1 , jj ) print * , print * , TraPar % Posp ( i )% x , TraPar % Posp ( i )% y print * , PCell % vof ( ii , jj ) pause 'Particle 127' end if Upo ( i ) = Upn ( i ) Vpo ( i ) = Vpn ( i ) elseif ( PCell % vofS ( ii , jj ) > 1.d0 - epsi ) then Upn ( i ) = BoomCase % us Vpn ( i ) = BoomCase % vs xyp ( i )% x = xyp ( i )% x + 0.5d0 * ( Upn ( i ) + Upo ( i )) * dtp xyp ( i )% y = xyp ( i )% y + 0.5d0 * ( Vpn ( i ) + Vpo ( i )) * dtp Upo ( i ) = Upn ( i ) Vpo ( i ) = Vpn ( i ) else Upn ( i ) = 0.d0 Vpn ( i ) = 0.d0 xyp ( i )% x = 1.d3 xyp ( i )% y = 1.d3 end if end if end do end do do i = 1 , TraPar % np TraPar % Posp ( i )% x = xyp ( i )% x TraPar % PosP ( i )% y = xyp ( i )% y TraPar % uvp ( i )% u = Upo ( i ) TraPar % uvp ( i )% v = VPo ( i ) if ( isnan ( TRaPar % uvp ( i )% u )) then pause 'Particle 149' end if end do deallocate ( Upo , Upn ) deallocate ( Vpo , Vpn ) deallocate ( xyp , axp , ayp ) end Subroutine TrackingParticles Function Drag ( Reyp ) result ( Cd ) !CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC! !                                                              ! !    'DRAG' CALCULATES DRAG COEFFICIENT                        ! !                                                              ! !CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC! REAL ( KIND = dp ) :: Cd , Reyp if ( Reyp < 1.d0 ) then Cd = 2 4.d0 / ( Reyp + tol ) return end if if ( Reyp <= 100 0.d0 ) then Cd = 2 4.d0 / ( Reyp + tol ) * ( 1.d0 + 0.15d0 * Reyp ** 0.687d0 ) return end if Cd = 0.44d0 return end function Drag !CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC! ! Calculate the position of particle                            ! ! The output is the cell number                                 ! !CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC! Subroutine ParticlePosition ( Posi , TGrid , ii , jj ) TYPE ( Point ), INTENT ( IN ) :: Posi TYPE ( Grid ), INTENT ( IN ) :: TGrid INTEGER ( kind = it4b ), INTENT ( OUT ) :: ii , jj INTEGER ( kind = it4b ) :: i , j ii =- 1 do i = 1 , Isize if ( Posi % x / TGrid % Lref >= TGrid % x ( i , 1 ) - TGrid % dx ( i , 1 ) / 2.d0 . and . & Posi % x / TGrid % Lref <= TGrid % x ( i , 1 ) + TGrid % dx ( i , 1 ) / 2.d0 ) then ii = i exit end if end do jj =- 1 do j = 1 , Jsize if ( Posi % y / TGrid % Lref >= TGrid % y ( 1 , j ) - TGrid % dy ( 1 , j ) / 2.d0 . and . & Posi % y / TGrid % Lref <= TGrid % y ( 1 , j ) + TGrid % dy ( 1 , j ) / 2.d0 ) then jj = j exit end if end do End subroutine ParticlePosition Subroutine ParticleInletCondition ( PGrid , PCell , TraPar ) IMPLICIT NONE TYPE ( Grid ), INTENT ( IN ) :: PGrid TYPE ( Cell ), INTENT ( IN ) :: PCell TYPE ( Particle ), INTENT ( INOUT ) :: TraPar INTEGER ( KIND = it4b ) :: i , j REAL ( KIND = dp ), DIMENSION (:), allocatable :: ranum allocate ( ranum ( NParInlet )) call Random_Number ( ranum ) do i = TraPar % np + 1 , TraPar % np + NParInlet TraPar % dp ( i ) = DParInlet * ( ranum ( i - TraPar % np ) + 1.d-3 ) end do call Random_Number ( ranum ) do i = TraPar % np + 1 , TraPar % np + NParInlet TraPar % Posp ( i )% x = PGrid % x ( 1 , 1 ) + PGrid % dx ( 1 , 1 ) / 3.d0 TraPar % Posp ( i )% y = Depthw - Amp0 * 2.d0 - HParInlet * ranum ( i - TraPar % np ) end do call Random_Number ( ranum ) do i = TraPar % np + 1 , TraPar % np + NParInlet TraPar % uvp ( i )% u = UParInlet * ( ranum ( i - TraPar % np ) + 0.5d0 ) TraPar % uvp ( i )% v = 0.d0 end do TraPar % np = TraPar % np + NParInlet End subroutine ParticleInletCondition End module Particles","tags":"","loc":"sourcefile/particles.f90.html","title":"Particles.f90 – Fortran Program"},{"text":"Contents Modules Clsvof Source Code Clsvof_Mod.f90 Source Code Module Clsvof !! Description: !! The module solves the coupled level set and volume of fluid method. !! Method: !! The interface tracking method is used to solve volume of fluid. !! The level set function is used to compute the normal vector which give a better !! accuracy than using volume fraction. When the new position of interface is !! determined the redistance for level set will be applied. ! Current Code Owner: SIMCOFlow ! Code Description: ! Language: Fortran 90. ! Software Standards: \"European Standards for Writing and ! Documenting Exchangeable Fortran 90 Code\". !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! Author : Son Tung Dang !        : NTNU,SINTEF ! Date : 20.09.2019 USE PrecisionVar USE Mesh USE Cutcell USE StateVariables USE Matrix IMPLICIT NONE PRIVATE INTEGER , PARAMETER :: band_width = 4 !! The number of layer from the interface for recomputing the level set function REAL ( KIND = dp ), PUBLIC , PARAMETER :: vofeps = 1.d-14 !! The tolerant value for volume of fluid REAL ( KIND = dp ), PUBLIC , PARAMETER :: tolp = 1.d-10 !! The tolerant value for boom case position REAL ( KIND = dp ), PUBLIC , PARAMETER :: TolDeno = 1.d-24 !! The tolerant value for denominator TYPE , PUBLIC :: SolidObject TYPE ( Point ) :: Posp !! The object position TYPE ( Point ) :: PospO !! The object previous position REAL ( KIND = dp ) :: us , vs !! The object velocity REAL ( KIND = dp ) :: asx , asy !! The object acceleration REAL ( KIND = dp ) :: Dobj !! The Boom diameter REAL ( KIND = dp ) :: Wobj !! The Boom width REAL ( KIND = dp ) :: Mobj !! The Boom Weight REAL ( KIND = dp ) :: Xbar1 !! The x position bottom left corner of boom REAL ( KIND = dp ) :: Xbar2 !! The x position bottom right corner of boom REAL ( KIND = dp ) :: Ybar !! The y position bottom of boom REAL ( KIND = dp ) :: Lbar !! The length of boom tail END TYPE REAL ( KIND = dp ), DIMENSION (:,:), pointer :: vfl !! The pointer for liquid volume fraction REAL ( KIND = dp ), DIMENSION (:,:), pointer :: vflS !! The pointer for solid volume fraction REAL ( KIND = dp ), DIMENSION (:,:), pointer :: nxs , nys !! The normal vector for solid interface REAL ( KIND = dp ), DIMENSION (:,:), pointer :: phi !! The pointer for liquid level set REAL ( KIND = dp ), DIMENSION (:,:), pointer :: phiS !! The pointer for solid level set REAL ( KIND = dp ), DIMENSION (:,:), allocatable :: nx , ny !! The pointer for liquid interface REAL ( KIND = dp ), DIMENSION ( 8 , 2 ) :: Vset !! The vector setup for normal computation PUBLIC :: Initial_Clsvof , Initial_ClsvofUV , Coupled_LS_VOF , ComputeForceObject ,& SolidVolumeFraction Interface Initial_Clsvof Module procedure Initial_Clsvof End interface Interface Initial_ClsvofUV Module procedure Initial_ClsvofUV End interface Interface Coupled_LS_VOF Module procedure Coupled_LS_VOF End interface Interface ComputeForceObject Module procedure ComputeForceObject End interface Interface SolidVolumeFraction Module procedure SolidVolumeFraction End interface Contains SUBROUTINE Initial_Clsvof ( TGrid , TCell , BoomCase ) !! The subroutine computes the initial condition for volume of fluid and !! level set function in the pressure cell. For computing the liquid !! volume fraction, the intersections between free surface and cell !! edge will be determined first. Then a special method will be !! used to compute the area. TYPE ( Grid ), INTENT ( IN ) :: TGrid !! The grid TYPE ( Cell ), INTENT ( INOUT ), target :: TCell !! The cell which contains level set, volume of fluid and normal vector TYPE ( SolidObject ), INTENT ( IN ) :: BoomCase !! The Boom position INTEGER ( kind = it4b ) :: i , j REAL ( KIND = dp ) :: dx , dy , dis , vol REAL ( KIND = dp ) :: dx2 , dy2 , tol , fx , dfx REAL ( KIND = dp ), DIMENSION (:,:) :: node ( 6 , 2 ), CutP ( 2 , 2 ), dpt ( 4 ) ! Information needed for computing the liquid volume fraction INTEGER ( kind = it4b ) :: temp , templ , k REAL ( KIND = dp ) :: epsil , nxx , nyy , nxy , vos , CylBar allocate ( nx ( Isize , Jsize )) allocate ( ny ( Isize , Jsize )) ! For wave only vfl => TCell % vof phi => TCell % phi phiS => TCell % phiS vflS => TCell % VofS epsil = 1.d-24 do j = 1 , Jsize do i = 1 , Isize !  for stay still wave as initial condition !   dis=TGrid%y(i,j)-Depthw !   nxx=0.d0 !   nyy=1.d0 !   call frac(nxx,nyy,dis,TGrid%dx(i,j),TGrid%dy(i,j),vol) ! ********* !   vfl(i,j)=vol !   phi(i,j)=dis !   TCell%nx(i,j)=nxx !   TCell%ny(i,j)=nyy !  for sinusoidal wave temp = 1 templ = 1 dx2 = TGrid % dx ( i , j ) / 2.d0 dy2 = TGrid % dy ( i , j ) / 2.d0 ! The height function from cell corner points to the interface dpt ( 1 ) = TGrid % y ( i , j ) - dy2 - Depthw - Amp0 * dsin ( kw * ( TGrid % x ( i , j ) + dx2 )) dpt ( 2 ) = TGrid % y ( i , j ) - dy2 - Depthw - Amp0 * dsin ( kw * ( TGrid % x ( i , j ) - dx2 )) dpt ( 3 ) = TGrid % y ( i , j ) + dy2 - Depthw - Amp0 * dsin ( kw * ( TGrid % x ( i , j ) - dx2 )) dpt ( 4 ) = TGrid % y ( i , j ) + dy2 - Depthw - Amp0 * dsin ( kw * ( TGrid % x ( i , j ) + dx2 )) if ( dpt ( 1 ) >= 0.d0 ) then node ( temp , 1 ) = dx2 node ( temp , 2 ) =- dy2 temp = temp + 1 end if ! The condition to check whether the interface will intersect with ! cell edges. if ( dpt ( 1 ) * dpt ( 2 ) < 0.d0 ) then node ( temp , 1 ) = TGrid % x ( i , j ) - dx2 + TGrid % dx ( i , j ) * dabs ( dpt ( 2 )) / & ( dabs ( dpt ( 2 )) + dabs ( dpt ( 1 ))) tol = 1.d0 do while ( tol > 1.d-12 ) fx = TGrid % y ( i , j ) - dy2 - ( Depthw + Amp0 * dsin ( kw * ( node ( temp , 1 )))) dfx =- Amp0 * kw * dcos ( kw * ( node ( temp , 1 ))) tol = dabs ( fx / dfx ) node ( temp , 1 ) = node ( temp , 1 ) - fx / dfx end do node ( temp , 1 ) = node ( temp , 1 ) - TGrid % x ( i , j ) node ( temp , 2 ) =- dy2 CutP ( templ , 1 ) = node ( temp , 1 ) CutP ( templ , 2 ) = node ( temp , 2 ) templ = templ + 1 temp = temp + 1 end if if ( dpt ( 2 ) >= 0.d0 ) then node ( temp , 1 ) =- dx2 node ( temp , 2 ) =- dy2 temp = temp + 1 end if if ( dpt ( 2 ) * dpt ( 3 ) < 0.d0 ) then node ( temp , 1 ) =- dx2 node ( temp , 2 ) = Depthw + Amp0 * dsin ( kw * ( node ( temp , 1 ) + TGrid % x ( i , j ))) - & TGrid % y ( i , j ) CutP ( templ , 1 ) = node ( temp , 1 ) CutP ( templ , 2 ) = node ( temp , 2 ) templ = templ + 1 temp = temp + 1 end if if ( dpt ( 3 ) >= 0.d0 ) then node ( temp , 1 ) =- dx2 node ( temp , 2 ) = dy2 temp = temp + 1 end if if ( dpt ( 3 ) * dpt ( 4 ) < 0.d0 ) then node ( temp , 1 ) = TGrid % x ( i , j ) - dx2 + TGrid % dx ( i , j ) * dabs ( dpt ( 3 )) / & ( dabs ( dpt ( 3 )) + dabs ( dpt ( 4 ))) tol = 1.d0 do while ( tol > 1.d-13 ) fx = TGrid % y ( i , j ) + dy2 - ( Depthw + Amp0 * dsin ( kw * ( node ( temp , 1 )))) dfx =- Amp0 * kw * dcos ( kw * ( node ( temp , 1 ))) tol = dabs ( fx / dfx ) node ( temp , 1 ) = node ( temp , 1 ) - fx / dfx end do node ( temp , 1 ) = node ( temp , 1 ) - TGrid % x ( i , j ) node ( temp , 2 ) = dy2 CutP ( templ , 1 ) = node ( temp , 1 ) CutP ( templ , 2 ) = node ( temp , 2 ) templ = templ + 1 temp = temp + 1 end if if ( dpt ( 4 ) >= 0.d0 ) then node ( temp , 1 ) = dx2 node ( temp , 2 ) = dy2 temp = temp + 1 end if if ( dpt ( 4 ) * dpt ( 1 ) < 0.d0 ) then node ( temp , 1 ) = dx2 node ( temp , 2 ) = Depthw + Amp0 * dsin ( kw * ( node ( temp , 1 ) + TGrid % x ( i , j ))) - & TGrid % y ( i , j ) CutP ( templ , 1 ) = node ( temp , 1 ) CutP ( templ , 2 ) = node ( temp , 2 ) templ = templ + 1 temp = temp + 1 end if node ( temp , 1 ) = node ( 1 , 1 ) node ( temp , 2 ) = node ( 1 , 2 ) vol = 0.d0 ! Using the Green theorem to compute the fluid volume inside cell. ! node is all points belong to gas field do k = 1 , temp - 1 vol = vol + 0.5d0 * ( node ( k , 1 ) * node ( k + 1 , 2 ) - node ( k + 1 , 1 ) * node ( k , 2 )) end do ! Liquid volume fraction vol = 1.d0 - dabs ( vol / ( TGrid % dx ( i , j ) * TGrid % dy ( i , j ))) ! The condition when the interface will pass a cell corner if ( templ == 3 ) then nxx = CutP ( 2 , 2 ) - CutP ( 1 , 2 ) nyy = CutP ( 2 , 1 ) - CutP ( 1 , 1 ) vos =- Amp0 * cw0 * kw * dcos ( kw * ( TGrid % x ( i , j ) + TGrid % dx ( i , j ))) nxy = dsqrt ( nxx ** 2.d0 + nyy ** 2.d0 ) if ( vos > 0.d0 ) then nxx =- nxx / nxy else nxx = nxx / nxy end if nyy = dabs ( nyy / nxy ) dis = dabs ( CutP ( 2 , 1 ) * CutP ( 1 , 2 ) - CutP ( 1 , 1 ) * CutP ( 2 , 2 )) / nxy * & dsign ( 1.d0 , 0.5d0 - vol ) else dis = TGrid % y ( i , j ) - ( Depthw + Amp0 * dsin ( kw * ( TGrid % x ( i , j )))) nxx = 0.d0 nyy = 1.d0 end if vfl ( i , j ) = vol phi ( i , j ) = dis TCell % nx ( i , j ) = nxx TCell % ny ( i , j ) = nyy end do end do CylBar = dsqrt (( BoomCase % Dobj / 2.d0 ) ** 2.d0 - ( BoomCase % Wobj / 2.d0 ) ** 2.d0 ) do i = 1 , Isize do j = 1 , Jsize !  For boom cylinder dx = TGrid % x ( i , j ) - BoomCase % Posp % x dy = TGrid % y ( i , j ) - BoomCase % Posp % y phiS ( i , j ) = ( dsqrt ( dx ** 2.d0 + dy ** 2.d0 ) - BoomCase % Dobj / 2.d0 ) nx ( i , j ) = dx / dsqrt ( dx ** 2.d0 + dy ** 2.d0 ) ny ( i , j ) = dy / dsqrt ( dx ** 2.d0 + dy ** 2.d0 ) !  For region at left side of boom if ( TGrid % x ( i , j ) <= BoomCase % XBar1 ) then !  For region under boom if ( TGrid % y ( i , j ) < BoomCase % YBar ) then dx = TGrid % x ( i , j ) - BoomCase % XBar1 dy = TGRid % y ( i , j ) - BoomCase % YBar PhiS ( i , j ) = dsqrt ( dx ** 2.d0 + dy ** 2.d0 ) nx ( i , j ) = dx / dsqrt ( dx ** 2.d0 + dy ** 2.d0 ) ny ( i , j ) = dy / dsqrt ( dx ** 2.d0 + dy ** 2.d0 ) !  For region have same altitude as Boom bar else if ( TGrid % y ( i , j ) < BoomCase % YBar + BoomCase % LBar ) then dis = BoomCase % XBar1 - TGrid % x ( i , j ) if ( dabs ( dis ) < dabs ( phiS ( i , j ))) then nx ( i , j ) =- 1.d0 ny ( i , j ) = 0.d0 phiS ( i , j ) = dis end if end if !  For region at right side of boom else if ( TGrid % x ( i , j ) >= BoomCase % XBar2 ) then !  For region under boom if ( TGrid % y ( i , j ) < BoomCase % YBar ) then dx = TGrid % x ( i , j ) - BoomCase % XBar2 dy = TGRid % y ( i , j ) - BoomCase % YBar PhiS ( i , j ) = dsqrt ( dx ** 2.d0 + dy ** 2.d0 ) nx ( i , j ) = dx / dsqrt ( dx ** 2.d0 + dy ** 2.d0 ) ny ( i , j ) = dy / dsqrt ( dx ** 2.d0 + dy ** 2.d0 ) !  For region have same altitude as Boom bar else if ( TGrid % y ( i , j ) < BoomCase % YBar + BoomCase % LBar ) then dis = TGrid % x ( i , j ) - BoomCase % XBar2 if ( dabs ( dis ) < dabs ( phiS ( i , j ))) then nx ( i , j ) = 1.d0 ny ( i , j ) = 0.d0 phiS ( i , j ) = dis end if end if !  For region in side boom else !  For region under boom if ( TGrid % y ( i , j ) <= BoomCase % YBar ) then PhiS ( i , j ) = BoomCase % YBar - TGrid % y ( i , j ) nx ( i , j ) = 0.d0 ny ( i , j ) =- 1.d0 !  For region inside boom bar elseif ( TGrid % y ( i , j ) < BoomCase % YBar + BoomCase % LBar ) then dpt ( 1 ) = BoomCase % YBar - TGrid % y ( i , j ) dpt ( 2 ) = BoomCase % XBar1 - TGrid % x ( i , j ) dpt ( 3 ) = TGrid % x ( i , j ) - BoomCase % XBar2 if ( dabs ( dpt ( 1 )) <= dabs ( dpt ( 2 )). and . dabs ( dpt ( 1 )) <= dabs ( dpt ( 3 ))) then PhiS ( i , j ) = dpt ( 1 ) nx ( i , j ) = 0.d0 ny ( i , j ) =- 1.d0 end if if ( dabs ( dpt ( 2 )) <= dabs ( dpt ( 1 )). and . dabs ( dpt ( 2 )) <= dabs ( dpt ( 3 ))) then PhiS ( i , j ) = dpt ( 2 ) nx ( i , j ) =- 1.d0 ny ( i , j ) = 0.d0 end if if ( dabs ( dpt ( 3 )) <= dabs ( dpt ( 1 )). and . dabs ( dpt ( 3 )) <= dabs ( dpt ( 2 ))) then PhiS ( i , j ) = dpt ( 3 ) nx ( i , j ) = 1.d0 ny ( i , j ) = 0.d0 end if !  For region inside cylinder elseif ( TGrid % y ( i , j ) < BoomCase % Posp % y ) then if ( dabs ( TGrid % x ( i , j ) - 0.5d0 * ( BoomCase % XBar1 + BoomCase % XBar2 )) / & dabs ( TGrid % y ( i , j ) - BoomCase % Posp % y ) < BoomCase % Wobj / 2.d0 / CylBar ) then dpt ( 1 ) =- dsqrt (( TGrid % x ( i , j ) - BoomCase % XBar1 ) ** 2.d0 + & ( TGrid % y ( i , j ) - BoomCase % YBar - BoomCase % LBar ) ** 2.d0 ) dpt ( 2 ) =- dsqrt (( TGrid % x ( i , j ) - BoomCase % XBar2 ) ** 2.d0 + & ( TGrid % y ( i , j ) - BoomCase % YBar - BoomCase % LBar ) ** 2.d0 ) if ( dabs ( dpt ( 1 )) < dabs ( dpt ( 2 ))) then PhiS ( i , j ) = dpt ( 1 ) nx ( i , j ) = ( BoomCase % XBar1 - TGrid % x ( i , j )) / dabs ( dpt ( 1 )) ny ( i , j ) =- ( TGrid % y ( i , j ) - BoomCase % YBar - BoomCase % LBar ) / dabs ( dpt ( 1 )) else PhiS ( i , j ) = dpt ( 2 ) nx ( i , j ) = ( BoomCase % XBar2 - TGrid % x ( i , j )) / dabs ( dpt ( 2 )) ny ( i , j ) =- ( TGrid % y ( i , j ) - BoomCase % YBar - BoomCase % LBar ) / dabs ( dpt ( 2 )) end if end if end if end if call frac ( nx ( i , j ), ny ( i , j ), phiS ( i , j ), TGrid % dx ( i , j ), TGrid % dy ( i , j ), vol ) vflS ( i , j ) = vol !  phiS(i,j)=1.d3 if ( vflS ( i , j ) < vofeps ) vflS ( i , j ) = 0.d0 if ( vflS ( i , j ) >= 1.d0 - vofeps ) vflS ( i , j ) = 1.d0 !  The specific case for the bottom of boom if ( vflS ( i , j ) > vofeps . and . vflS ( i , j ) < 1.d0 - vofeps ) then if ( TGrid % y ( i , j ) + TGrid % dy ( i , j ) / 2.d0 - tolp > BoomCase % YBar . and . & TGrid % y ( i , j ) - TGrid % dy ( i , j ) / 2.d0 + tolp < BoomCase % YBar ) then if ( TGrid % x ( i , j ) - TGrid % dx ( i , j ) / 2.d0 + tolp < BoomCase % XBar1 . and . & TGrid % x ( i , j ) + TGrid % dx ( i , j ) / 2.d0 - tolp > BoomCase % XBar1 ) then CutP ( 1 , 1 ) = BoomCase % XBar1 - TGrid % x ( i , j ) CutP ( 1 , 2 ) = TGrid % dy ( i , j ) / 2.d0 CutP ( 2 , 1 ) = TGrid % dx ( i , j ) / 2.d0 CutP ( 2 , 2 ) = BoomCase % YBar - TGrid % y ( i , j ) nxx = CutP ( 2 , 2 ) - CutP ( 1 , 2 ) nyy = CutP ( 2 , 1 ) - CutP ( 1 , 1 ) vflS ( i , j ) = 0.5d0 * dabs ( nxx * nyy ) / TGrid % dx ( i , j ) / TGrid % dy ( i , j ) nxy = dsqrt ( nxx ** 2.d0 + nyy ** 2.d0 ) nx ( i , j ) =- dabs ( nxx / nxy ) ny ( i , j ) =- dabs ( nyy / nxy ) phiS ( i , j ) = dabs ( CutP ( 2 , 1 ) * CutP ( 1 , 2 ) - CutP ( 1 , 1 ) * CutP ( 2 , 2 )) / nxy end if if ( TGrid % x ( i , j ) - TGrid % dx ( i , j ) / 2.d0 + tolp < BoomCase % XBar2 . and . & TGrid % x ( i , j ) + TGrid % dx ( i , j ) / 2.d0 - tolp > BoomCase % XBar2 ) then CutP ( 1 , 1 ) = BoomCase % XBar2 - TGrid % x ( i , j ) CutP ( 1 , 2 ) = TGrid % dy ( i , j ) / 2.d0 CutP ( 2 , 1 ) =- TGrid % dx ( i , j ) / 2.d0 CutP ( 2 , 2 ) = BoomCase % YBar - TGrid % y ( i , j ) nxx = CutP ( 2 , 2 ) - CutP ( 1 , 2 ) nyy = CutP ( 2 , 1 ) - CutP ( 1 , 1 ) vflS ( i , j ) = 0.5d0 * dabs ( nxx * nyy ) / TGrid % dx ( i , j ) / TGrid % dy ( i , j ) nxy = dsqrt ( nxx ** 2.d0 + nyy ** 2.d0 ) nx ( i , j ) = dabs ( nxx / nxy ) ny ( i , j ) =- dabs ( nyy / nxy ) phiS ( i , j ) = dabs ( CutP ( 2 , 1 ) * CutP ( 1 , 2 ) - CutP ( 1 , 1 ) * CutP ( 2 , 2 )) / nxy end if end if end if !  The specific area between boom cylinder and boom bar if ( vflS ( i , j ) > vofeps . and . vflS ( i , j ) < 1.d0 - vofeps ) then if ( TGrid % y ( i , j ) + TGrid % dy ( i , j ) / 2.d0 - tolp > BoomCase % Posp % y - CylBar . and . & TGrid % y ( i , j ) - TGrid % dy ( i , j ) / 2.d0 + tolp < BoomCase % Posp % y - CylBar ) then ! For the left side of object if ( TGrid % x ( i , j ) - TGrid % dx ( i , j ) / 2.d0 + tolp < BoomCase % XBar1 . and . & TGrid % x ( i , j ) + TGrid % dx ( i , j ) / 2.d0 - tolp > BoomCase % XBar1 ) then CutP ( 1 , 1 ) = BoomCase % XBar1 - TGrid % x ( i , j ) CutP ( 1 , 2 ) =- TGrid % dy ( i , j ) / 2.d0 if ( dsqrt (( TGrid % x ( i , j ) - TGrid % dx ( i , j ) / 2.d0 - BoomCase % Posp % x ) ** 2.d0 + & ( TGrid % y ( i , j ) + TGrid % dy ( i , j ) / 2.d0 - BoomCase % Posp % y ) ** 2.d0 ) < & BoomCase % Dobj / 2.d0 ) then CutP ( 2 , 1 ) =- TGrid % dx ( i , j ) / 2.d0 CutP ( 2 , 2 ) = dsqrt (( BoomCase % Dobj / 2.d0 ) ** 2.d0 - & ( BoomCase % Wobj / 2.d0 + TGrid % dx ( i , j ) / 2.d0 ) ** 2.d0 ) - & ( BoomCase % Posp % y - TGrid % y ( i , j )) nxx = CutP ( 2 , 2 ) - CutP ( 1 , 2 ) nyy = CutP ( 2 , 1 ) - CutP ( 1 , 1 ) vflS ( i , j ) = 1.d0 - 0.5d0 * dabs ( nxx * nyy ) / TGrid % dx ( i , j ) / TGrid % dy ( i , j ) nxy = dsqrt ( nxx ** 2.d0 + nyy ** 2.d0 ) nx ( i , j ) =- dabs ( nxx / nxy ) ny ( i , j ) =- dabs ( nyy / nxy ) phiS ( i , j ) = dabs ( CutP ( 2 , 1 ) * CutP ( 1 , 2 ) - CutP ( 1 , 1 ) * CutP ( 2 , 2 )) / nxy * & dsign ( 1.d0 , 0.5d0 - vflS ( i , j )) else CutP ( 2 , 1 ) = dsqrt (( BoomCase % Dobj / 2.d0 ) ** 2.d0 - & ( BoomCase % Posp % y - TGrid % y ( i , j ) - TGrid % dy ( i , j ) / 2.d0 ) ** 2.d0 ) - & ( BoomCase % Posp % x - TGrid % x ( i , j )) CutP ( 2 , 2 ) = TGrid % dy ( i , j ) / 2.d0 nxx = CutP ( 2 , 2 ) - CutP ( 1 , 2 ) nyy = CutP ( 2 , 1 ) - CutP ( 1 , 1 ) vflS ( i , j ) = 0.5d0 * dabs ( TGrid % dx ( i , j ) / 2.d0 - CutP ( 1 , 1 ) + & TGrid % dx ( i , j ) / 2.d0 - CutP ( 2 , 1 )) / TGrid % dx ( i , j ) nxy = dsqrt ( nxx ** 2.d0 + nyy ** 2.d0 ) nx ( i , j ) =- dabs ( nxx / nxy ) ny ( i , j ) =- dabs ( nyy / nxy ) phiS ( i , j ) = dabs ( CutP ( 2 , 1 ) * CutP ( 1 , 2 ) - CutP ( 1 , 1 ) * CutP ( 2 , 2 )) / nxy * & dsign ( 1.d0 , 0.5d0 - vflS ( i , j )) end if end if ! For the right side of object if ( TGrid % x ( i , j ) - TGrid % dx ( i , j ) / 2.d0 + tolp < BoomCase % XBar2 . and . & TGrid % x ( i , j ) + TGrid % dx ( i , j ) / 2.d0 - tolp > BoomCase % XBar2 ) then CutP ( 1 , 1 ) = BoomCase % XBar2 - TGrid % x ( i , j ) CutP ( 1 , 2 ) =- TGrid % dy ( i , j ) / 2.d0 if ( dsqrt (( TGrid % x ( i , j ) + TGrid % dx ( i , j ) / 2.d0 - BoomCase % Posp % x ) ** 2.d0 + & ( TGrid % y ( i , j ) + TGrid % dy ( i , j ) / 2.d0 - BoomCase % Posp % y ) ** 2.d0 ) < & BoomCase % Dobj / 2.d0 ) then CutP ( 2 , 1 ) = TGrid % dx ( i , j ) / 2.d0 CutP ( 2 , 2 ) = dsqrt (( BoomCase % Dobj / 2.d0 ) ** 2.d0 - & ( BoomCase % Wobj / 2.d0 + TGrid % dx ( i , j ) / 2.d0 ) ** 2.d0 ) - & ( BoomCase % Posp % y - TGrid % y ( i , j )) nxx = CutP ( 2 , 2 ) - CutP ( 1 , 2 ) nyy = CutP ( 2 , 1 ) - CutP ( 1 , 1 ) vflS ( i , j ) = 1.d0 - 0.5d0 * dabs ( nxx * nyy ) / TGrid % dx ( i , j ) / TGrid % dy ( i , j ) nxy = dsqrt ( nxx ** 2.d0 + nyy ** 2.d0 ) nx ( i , j ) = dabs ( nxx / nxy ) ny ( i , j ) =- dabs ( nyy / nxy ) phiS ( i , j ) = dabs ( CutP ( 2 , 1 ) * CutP ( 1 , 2 ) - CutP ( 1 , 1 ) * CutP ( 2 , 2 )) / nxy * & dsign ( 1.d0 , 0.5d0 - vflS ( i , j )) else CutP ( 2 , 1 ) = dsqrt (( BoomCase % Dobj / 2.d0 ) ** 2.d0 - & ( BoomCase % Posp % y - TGrid % y ( i , j ) - TGrid % dy ( i , j ) / 2.d0 ) ** 2.d0 ) - & ( BoomCase % Posp % x - TGrid % x ( i , j )) CutP ( 2 , 2 ) = TGrid % dy ( i , j ) / 2.d0 nxx = CutP ( 2 , 2 ) - CutP ( 1 , 2 ) nyy = CutP ( 2 , 1 ) - CutP ( 1 , 1 ) vflS ( i , j ) = 0.5d0 * dabs ( CutP ( 1 , 1 ) + TGrid % dx ( i , j ) + CutP ( 2 , 1 )) / & TGrid % dx ( i , j ) nxy = dsqrt ( nxx ** 2.d0 + nyy ** 2.d0 ) nx ( i , j ) = dabs ( nxx / nxy ) ny ( i , j ) =- dabs ( nyy / nxy ) phiS ( i , j ) = dabs ( CutP ( 2 , 1 ) * CutP ( 1 , 2 ) - CutP ( 1 , 1 ) * CutP ( 2 , 2 )) / nxy * & dsign ( 1.d0 , 0.5d0 - vflS ( i , j )) end if end if end if end if TCell % nxS ( i , j ) = nx ( i , j ) TCell % nyS ( i , j ) = ny ( i , j ) vfl ( i , j ) = vfl ( i , j ) * ( 1.d0 - vflS ( i , j )) end do end do nullify ( vfl ) nullify ( phi ) deallocate ( nx ) deallocate ( ny ) end subroutine Initial_Clsvof subroutine Initial_ClsVofUV ( PCell , PGrid , TCell , TGrid , BoomCase , uv ) !! The subroutine computes the initial condition for volume of fluid and !! level set function in velocity cells. The liquid volume fraction in the !! velocity cell is the combination of two half parts of two connecting pressure cells. IMPLICIT NONE TYPE ( Cell ), INTENT ( IN ) :: PCell !! The data from pressure cell TYPE ( Cell ), INTENT ( INOUT ) :: TCell !! The target cell which can be u cell or v cell TYPE ( Grid ), INTENT ( IN ) :: PGrid !! The pressure grid TYPE ( Grid ), INTENT ( IN ) :: TGrid !! The target grid TYPE ( SolidObject ), INTENT ( IN ) :: BoomCase !! The Boom position INTEGER ( kind = it4b ), INTENT ( IN ) :: uv !! The parameter to determine the target cell is Ucell or VCell INTEGER ( kind = it4b ) :: i , j REAL ( KIND = dp ) :: posi ( 4 ), valu ( 4 ), PosTar , temn , tol REAL ( KIND = dp ) :: volfl , volfr , volsl , volsr , phifl , phifr , phisl , phisr tol = 1.d-14 call SolidVolumeFraction ( TGrid , TCell , BoomCase ) if ( uv == 0 ) then do j = jbeg , jbeg + Jsize - 1 do i = ibeg , ibeg + Isize - 2 if ( i >= 3. and . i <= Isize - 2 ) then posi ( 1 ) = TGrid % x ( i , j ) - PGrid % x ( i - 1 , j ) posi ( 2 ) = TGrid % x ( i , j ) - PGrid % x ( i , j ) posi ( 3 ) = TGrid % x ( i , j ) - PGrid % x ( i + 1 , j ) posi ( 4 ) = TGrid % x ( i , j ) - PGrid % x ( i + 2 , j ) PosTar = 0.d0 ! for liquid part Valu ( 1 ) = PCell % phi ( i - 1 , j ); Valu ( 2 ) = PCell % phi ( i , j ) Valu ( 3 ) = PCell % phi ( i + 1 , j ); Valu ( 4 ) = PCell % phi ( i + 2 , j ) TCell % phi ( i , j ) = LagrangePoly ( posi , valu , PosTar ) ! for liquid part: normal vector Valu ( 1 ) = PCell % nx ( i - 1 , j ); Valu ( 2 ) = PCell % nx ( i , j ) Valu ( 3 ) = PCell % nx ( i + 1 , j ); Valu ( 4 ) = PCell % nx ( i + 2 , j ) TCell % nx ( i , j ) = LagrangePoly ( posi , valu , PosTar ) ! for liquid part: normal vector Valu ( 1 ) = PCell % ny ( i - 1 , j ); Valu ( 2 ) = PCell % ny ( i , j ) Valu ( 3 ) = PCell % ny ( i + 1 , j ); Valu ( 4 ) = PCell % ny ( i + 2 , j ) TCell % ny ( i , j ) = LagrangePoly ( posi , valu , PosTar ) else ! for liquid part TCell % phi ( i , j ) = 0.5d0 * ( PCell % phi ( i + 1 , j ) + PCell % phi ( i , j )) TCell % nx ( i , j ) = 0.5d0 * ( PCell % nx ( i + 1 , j ) + PCell % nx ( i , j )) TCell % ny ( i , j ) = 0.5d0 * ( PCell % ny ( i + 1 , j ) + PCell % ny ( i , j )) end if temn = dsqrt ( TCell % nx ( i , j ) ** 2.d0 + TCell % ny ( i , j ) ** 2.d0 ) + 1.d-14 TCell % nx ( i , j ) = TCell % nx ( i , j ) / temn TCell % ny ( i , j ) = TCell % ny ( i , j ) / temn phifl = PCell % phi ( i , j ) + PGrid % dx ( i , j ) / 4.d0 * PCell % nx ( i , j ) !   phisl=PCell%phiS(i,j)+PGrid%dx(i,j)/4.d0*PCell%nxS(i,j) phisl = TCell % phiS ( i , j ) ! for a cell with only fluid phase if ( PCell % vof ( i , j ) >= 1.d0 - vofeps . and . PCell % vofS ( i , j ) < epsi ) then volfl = 1.d0 !     volsl=0.d0 end if ! for a cell with fluid and air(gas) if ( PCell % vof ( i , j ) < 1.d0 - vofeps . and . PCell % vof ( i , j ) >= vofeps . and . & PCell % vofS ( i , j ) < epsi ) then call frac ( PCell % nx ( i , j ), PCell % ny ( i , j ), phifl , PGrid % dx ( i , j ) / 2.d0 , & PGrid % dy ( i , j ), volfl ) !    volsl=0.d0 end if ! for a cell with only air(gas) if ( PCell % vof ( i , j ) < vofeps . and . PCell % vofS ( i , j ) < epsi ) then volfl = 0.d0 !    volsl=0.d0 end if ! for a cell with only solid if ( PCell % vof ( i , j ) < vofeps . and . PCell % vofS ( i , j ) >= 1.d0 - epsi ) then volfl = 0.d0 !    volsl=1.d0 end if ! for a cell with air and solid if ( PCell % vof ( i , j ) < vofeps . and . PCell % vofS ( i , j ) < 1.d0 - vofeps . and . & PCell % vofS ( i , j ) >= epsi ) then call frac ( PCell % nxS ( i , j ), PCell % nyS ( i , j ), phisl , & PGrid % dx ( i , j ) / 2.d0 , PGrid % dy ( i , j ), volsl ) volfl = 0.d0 end if if ( PCell % vof ( i , j ) >= vofeps . and . PCell % vof ( i , j ) < 1.d0 - vofeps . and . & PCell % vofS ( i , j ) >= epsi . and . PCell % vofS ( i , j ) < 1.d0 - epsi ) then call CellGeoCal ( PCell % nxS ( i , j ), PCell % nyS ( i , j ), phisl , & PCell % nx ( i , j ), PCell % ny ( i , j ), phifl , & PGrid % dx ( i , j ) / 2.d0 , PGrid % dy ( i , j ), volsl , volfl ) end if if ( i < Isize ) then phifr = PCell % phi ( i + 1 , j ) - PGrid % dx ( i + 1 , j ) / 4.d0 * PCell % nx ( i + 1 , j ) !    phisr=PCell%phiS(i+1,j)-PGrid%dx(i+1,j)/4.d0*PCell%nxS(i+1,j) phisr = TCell % phiS ( i , j ) ! for a cell with only fluid phase if ( PCell % vof ( i + 1 , j ) >= 1.d0 - vofeps . and . PCell % vofS ( i + 1 , j ) < epsi ) then volfr = 1.d0 !      volsr=0.d0 end if ! for a cell with fluid and air(gas) if ( PCell % vof ( i + 1 , j ) < 1.d0 - vofeps . and . PCell % vof ( i + 1 , j ) >= vofeps . and . & PCell % vofS ( i + 1 , j ) < epsi ) then call frac ( PCell % nx ( i + 1 , j ), PCell % ny ( i + 1 , j ), phifr , & PGrid % dx ( i + 1 , j ) / 2.d0 , PGrid % dy ( i + 1 , j ), volfr ) !      volsr=0.d0 end if ! for a cell with only air(gas) if ( PCell % vof ( i + 1 , j ) < vofeps . and . PCell % vofS ( i + 1 , j ) < epsi ) then volfr = 0.d0 !      volsr=0.d0 end if ! for a cell with only solid if ( PCell % vof ( i + 1 , j ) < vofeps . and . PCell % vofS ( i + 1 , j ) >= 1.d0 - epsi ) then volfr = 0.d0 !      volsr=1.d0 end if ! for a cell with air and solid if ( PCell % vof ( i + 1 , j ) < vofeps . and . PCell % vofS ( i + 1 , j ) < 1.d0 - epsi . and . & PCell % vofS ( i + 1 , j ) >= epsi ) then call frac ( PCell % nxS ( i + 1 , j ), PCell % nyS ( i + 1 , j ), phisr , & PGrid % dx ( i + 1 , j ) / 2.d0 , PGrid % dy ( i + 1 , j ), volsr ) volfr = 0.d0 end if ! for a cell with air, fluid and solid if ( PCell % vof ( i + 1 , j ) >= vofeps . and . PCell % vof ( i + 1 , j ) < 1.d0 - vofeps . and . & PCell % vofS ( i + 1 , j ) >= epsi . and . PCell % vofS ( i + 1 , j ) < 1.d0 - epsi ) then call CellGeoCal ( PCell % nxS ( i + 1 , j ), PCell % nyS ( i + 1 , j ), phisr , & PCell % nx ( i + 1 , j ), PCell % ny ( i + 1 , j ), phifr , & PGrid % dx ( i + 1 , j ) / 2.d0 , PGrid % dy ( i + 1 , j ), volsr , volfr ) end if else volfr = volfl !     volsr=volsl end if TCell % vof ( i , j ) = 0.5d0 * ( volfl + volfr ) if ( TCell % vof ( i , j ) < vofeps ) TCell % vof ( i , j ) = 0.d0 if ( TCell % vof ( i , j ) > 1.d0 - vofeps - TCell % vofS ( i , j )) then TCell % vof ( i , j ) = 1.d0 - TCell % vofS ( i , j ) end if if ( i > 1 ) then if (( PCell % vof ( i - 1 , j ) >= 1.d0 - vofeps - PCell % vofS ( i - 1 , j ). and . & PCell % vof ( i + 1 , j ) >= 1.d0 - vofeps - PCell % vofS ( i + 1 , j ))) then TCell % vof ( i , j ) = 1.d0 - TCell % vofS ( i , j ) end if end if !    TCell%vofS(i,j)=0.5d0*(volsl+volsr) !    if(TCell%vofS(i,j)<epsi) TCell%VofS(i,j)=0.d0 !    if(TCell%vofS(i,j)>=1.d0-epsi) TCell%VofS(i,j)=1.d0 end do TCell % phi ( i , j ) = TCell % phi ( i - 1 , j ) TCell % nx ( i , j ) = TCell % nx ( i - 1 , j ) TCell % ny ( i , j ) = TCell % ny ( i - 1 , j ) TCell % vof ( i , j ) = TCell % vof ( i - 1 , j ) end do else do i = ibeg , ibeg + Isize - 1 do j = jbeg , jbeg + Jsize - 2 SPuv ( i , j ) = 0.d0 if ( j >= 3. and . j <= Jsize - 2 ) then posi ( 1 ) = TGrid % y ( i , j ) - PGrid % y ( i , j - 1 ) posi ( 2 ) = TGrid % y ( i , j ) - PGrid % y ( i , j ) posi ( 3 ) = TGrid % y ( i , j ) - PGrid % y ( i , j + 1 ) posi ( 4 ) = TGrid % y ( i , j ) - PGrid % y ( i , j + 2 ) PosTar = 0.d0 ! liquid level-set function for bottom half of cell Valu ( 1 ) = PCell % phi ( i , j - 1 ); Valu ( 2 ) = PCell % phi ( i , j ) Valu ( 3 ) = PCell % phi ( i , j + 1 ); Valu ( 4 ) = PCell % phi ( i , j + 2 ) TCell % phi ( i , j ) = LagrangePoly ( posi , valu , PosTar ) ! liquid normal vector for bottom half of cell Valu ( 1 ) = PCell % nx ( i , j - 1 ); Valu ( 2 ) = PCell % nx ( i , j ) Valu ( 3 ) = PCell % nx ( i , j + 1 ); Valu ( 4 ) = PCell % nx ( i , j + 2 ) TCell % nx ( i , j ) = LagrangePoly ( posi , valu , PosTar ) ! liquid normal vector for bottom half of cell Valu ( 1 ) = PCell % ny ( i , j - 1 ); Valu ( 2 ) = PCell % ny ( i , j ) Valu ( 3 ) = PCell % ny ( i , j + 1 ); Valu ( 4 ) = PCell % ny ( i , j + 2 ) TCell % ny ( i , j ) = LagrangePoly ( posi , valu , PosTar ) else TCell % phi ( i , j ) = 0.5d0 * ( PCell % phi ( i , j + 1 ) + PCell % phi ( i , j )) TCell % nx ( i , j ) = 0.5d0 * ( PCell % nx ( i , j + 1 ) + PCell % nx ( i , j )) TCell % ny ( i , j ) = 0.5d0 * ( PCell % ny ( i , j + 1 ) + PCell % ny ( i , j )) end if temn = dsqrt ( TCell % nx ( i , j ) ** 2.d0 + TCell % ny ( i , j ) ** 2.d0 + 1.d-30 ) TCell % nx ( i , j ) = TCell % nx ( i , j ) / temn TCell % ny ( i , j ) = TCell % ny ( i , j ) / temn phifl = PCell % phi ( i , j ) + PGrid % dy ( i , j ) / 4.d0 * PCell % ny ( i , j ) !  phisl=PCell%phiS(i,j)+PGrid%dy(i,j)/4.d0*PCell%nyS(i,j) phisl = TCell % phiS ( i , j ) ! for a cell with only fluid phase if ( PCell % vof ( i , j ) >= 1.d0 - vofeps . and . PCell % vofS ( i , j ) < epsi ) then volfl = 1.d0 !    volsl=0.d0 end if ! for a cell with fluid and air(gas) if ( PCell % vof ( i , j ) < 1.d0 - vofeps . and . PCell % vof ( i , j ) >= vofeps . and . & PCell % vofS ( i , j ) < epsi ) then call frac ( PCell % nx ( i , j ), PCell % ny ( i , j ), phifl , PGrid % dx ( i , j ), & PGrid % dy ( i , j ) / 2.d0 , volfl ) !    volsl=0.d0 end if ! for a cell with only air(gas) if ( PCell % vof ( i , j ) < vofeps . and . PCell % vofS ( i , j ) < epsi ) then volfl = 0.d0 !    volsl=0.d0 end if ! for a cell with only solid if ( PCell % vof ( i , j ) < vofeps . and . PCell % vofS ( i , j ) >= 1.d0 - epsi ) then volfl = 0.d0 !    volsl=1.d0 end if ! for a cell with air and solid if ( PCell % vof ( i , j ) < vofeps . and . PCell % vofS ( i , j ) < 1.d0 - epsi . and . & PCell % vofS ( i , j ) >= epsi ) then call frac ( PCell % nxS ( i , j ), PCell % nyS ( i , j ), phisl , & PGrid % dx ( i , j ), PGrid % dy ( i , j ) / 2.d0 , volsl ) volfl = 0.d0 end if ! for a cell with air, fluid, solid if ( PCell % vof ( i , j ) >= vofeps . and . PCell % vof ( i , j ) < 1.d0 - vofeps . and . & PCell % vofS ( i , j ) >= epsi . and . PCell % vofS ( i , j ) < 1.d0 - epsi ) then call CellGeoCal ( PCell % nxS ( i , j ), PCell % nyS ( i , j ), phisl , & PCell % nx ( i , j ), PCell % ny ( i , j ), phifl , & PGrid % dx ( i , j ), PGrid % dy ( i , j ) / 2.d0 , volsl , volfl ) end if if ( j < Jsize ) then phifr = PCell % phi ( i , j + 1 ) - PGrid % dy ( i , j + 1 ) / 4.d0 * PCell % ny ( i , j + 1 ) !    phisr=PCell%phiS(i,j+1)-PGrid%dy(i,j+1)/4.d0*PCell%nyS(i,j+1) phisr = TCell % phiS ( i , j ) ! for a cell with only fluid phase if ( PCell % vof ( i , j + 1 ) >= 1.d0 - vofeps . and . PCell % vofS ( i , j + 1 ) < epsi ) then volfr = 1.d0 !       volsr=0.d0 end if ! for a cell with fluid and air(gas) if ( PCell % vof ( i , j + 1 ) < 1.d0 - vofeps . and . PCell % vof ( i , j + 1 ) >= vofeps . and . & PCell % vofS ( i , j + 1 ) < epsi ) then call frac ( PCell % nx ( i , j + 1 ), PCell % ny ( i , j + 1 ), phifr , & PGrid % dx ( i , j + 1 ), PGrid % dy ( i , j + 1 ) / 2.d0 , volfr ) !      volsr=0.d0 end if ! for a cell with only air(gas) if ( PCell % vof ( i , j + 1 ) < vofeps . and . PCell % vofS ( i , j + 1 ) < epsi ) then volfr = 0.d0 !      volsr=0.d0 end if ! for a cell with only solid if ( PCell % vof ( i , j + 1 ) < vofeps . and . PCell % vofS ( i , j + 1 ) >= 1.d0 - epsi ) then volfr = 0.d0 !      volsr=1.d0 end if ! for a cell with air and solid if ( PCell % vof ( i , j + 1 ) < vofeps . and . PCell % vofS ( i , j + 1 ) < 1.d0 - epsi . and . & PCell % vofS ( i , j + 1 ) >= epsi ) then call frac ( PCell % nxS ( i , j + 1 ), PCell % nyS ( i , j + 1 ), phisr , & PGrid % dx ( i , j + 1 ), PGrid % dy ( i , j + 1 ) / 2.d0 , volsr ) volfr = 0.d0 end if ! for a cell with air, fluid and solid if ( PCell % vof ( i , j + 1 ) >= vofeps . and . PCell % vof ( i , j + 1 ) < 1.d0 - vofeps . and . & PCell % vofS ( i , j + 1 ) >= epsi . and . PCell % vofS ( i , j + 1 ) < 1.d0 - epsi ) then call CellGeoCal ( PCell % nxS ( i , j + 1 ), PCell % nyS ( i , j + 1 ), phisr , & PCell % nx ( i , j + 1 ), PCell % ny ( i , j + 1 ), phifr , & PGrid % dx ( i , j + 1 ), PGrid % dy ( i , j + 1 ) / 2.d0 , volsr , volfr ) end if else volfr = volfl !    volsr=volsl end if TCell % vof ( i , j ) = 0.5d0 * ( volfl + volfr ) if ( TCell % vof ( i , j ) < vofeps ) TCell % vof ( i , j ) = 0.d0 if ( TCell % vof ( i , j ) > 1.d0 - vofeps - TCell % vofS ( i , j )) then TCell % vof ( i , j ) = 1.d0 - TCell % vofS ( i , j ) end if if ( j > 1 ) then if (( PCell % vof ( i , j - 1 ) >= 1.d0 - vofeps - PCell % vofS ( i , j - 1 ). and . & PCell % vof ( i , j + 1 ) >= 1.d0 - vofeps - PCell % vofS ( i , j + 1 ))) then TCell % vof ( i , j ) = 1.d0 - TCell % vofS ( i , j ) end if end if !   TCell%vofS(i,j)=0.5d0*(volsl+volsr) !   if(TCell%vofS(i,j)<epsi) TCell%vofS(i,j)=0.d0 !    if(TCell%vofS(i,j)>=1.d0-epsi) TCell%VofS(i,j)=1.d0 end do ! Boundary condition for liquid part TCell % phi ( i , j ) = TCell % phi ( i , j - 1 ) TCell % nx ( i , j ) = TCell % nx ( i , j - 1 ) TCell % ny ( i , j ) = TCell % ny ( i , j - 1 ) TCell % vof ( i , j ) = TCell % vof ( i , j - 1 ) ! Boundary condition for solid part !    TCell%phiS(i,j)=TCell%phiS(i,j-1) !    TCell%nxS(i,j)=TCell%nxS(i,j-1) !    TCell%nyS(i,j)=TCell%nyS(i,j-1) !    TCell%vofS(i,j)=TCell%vofS(i,j-1) end do end if end subroutine Initial_ClsVofUV function LagrangePoly ( posi , valu , PosTar ) result ( ValTar ) IMPLICIT NONE REAL ( KIND = dp ) :: posi ( 4 ), valu ( 4 ), PosTar , ValTar , Mult INTEGER :: i , j ValTar = 0.d0 do i = 1 , 4 Mult = valu ( i ) do j = 1 , 4 if ( j /= i ) then Mult = Mult * ( PosTar - Posi ( j )) / ( Posi ( i ) - Posi ( j )) end if end do ValTar = ValTar + Mult end do end function LagrangePoly !*********************************************************** ! Coupled level set and volume of fluid !*********************************************************** subroutine Coupled_LS_VOF ( PGrid , PCell , UCell , VCell , TVar , BoomCase , NondiT , dt , itt ) !! The subroutine solves the coupling level set and volume of fluid to update !! the new position of interface IMPLICIT NONE TYPE ( Grid ), INTENT ( IN ) :: PGrid !! The pressure grid TYPE ( Cell ), INTENT ( IN ) :: UCell , VCell !! The velocity cell TYPE ( Cell ), INTENT ( INOUT ), target :: PCell !! The pressure cell TYPE ( Variables ), INTENT ( IN ) :: TVar !! The state variables TYPE ( SolidObject ), INTENT ( INOUT ) :: BoomCase !! The Boom position REAL ( KIND = dp ), INTENT ( IN ) :: dt , NondiT !! The time step and nondimensional time INTEGER ( kind = it8b ), INTENT ( IN ) :: itt !! The number of iterations INTEGER ( kind = it4b ) :: i , j , ii , jj , k , nv , UpdateNorVec , tempc REAL ( KIND = dp ) :: dtv , epsil REAL ( KIND = dp ), DIMENSION (:,:), allocatable :: dis , temvfx , temvfy , temlsx , temlsy REAL ( KIND = dp ), DIMENSION (:,:), allocatable :: ue , ve REAL ( KIND = dp ) :: weight ( 9 ), sumvol , sumweight , sumweight2 , neighvol , voldif REAL ( KIND = dp ) :: SumAllVolBig , SumAllVolSmall , ResVol REAL ( KIND = dp ) :: del_x , del_y , dttol , vb Vset ( 1 , 1 ) = 0.d0 ; Vset ( 1 , 2 ) =- 1.d0 Vset ( 2 , 1 ) = 0.d0 ; Vset ( 1 , 2 ) = 1.d0 Vset ( 3 , 1 ) =- 1.d0 ; Vset ( 3 , 2 ) = 0.d0 Vset ( 4 , 1 ) =- 1.d0 ; Vset ( 4 , 2 ) =- 1.d0 Vset ( 5 , 1 ) =- 1.d0 ; Vset ( 5 , 2 ) = 1.d0 Vset ( 6 , 1 ) = 1.d0 ; Vset ( 6 , 2 ) = 0.d0 Vset ( 7 , 1 ) = 1.d0 ; Vset ( 7 , 2 ) =- 1.d0 Vset ( 8 , 1 ) = 1.d0 ; Vset ( 8 , 2 ) = 1.d0 ! Set up vector for computing normal vector nv = 6 ! The number of sub steps for solving volume of fluid and level set vfl => PCell % vof phi => PCell % phi nxs => PCell % nxs nys => PCell % nys vflS => PCell % VofS phiS => PCell % phiS dtv = dt / dble ( nv ) dttol = dt !dtv del_x = PGrid % dx ( Isize / 2 , Jsize / 2 ) del_y = PGrid % dy ( Isize / 2 , Jsize / 2 ) epsil = dsqrt ( 2.d0 ) * del_x / 2.d-6 ResVol = 1.d0 allocate ( nx ( Isize , Jsize )) allocate ( ny ( Isize , Jsize )) allocate ( dis ( Isize , Jsize )) allocate ( ue ( 0 : Isize , Jsize )) allocate ( ve ( Isize , 0 : Jsize )) allocate ( temvfx ( Isize , Jsize )) allocate ( temvfy ( Isize , Jsize )) allocate ( temlsx ( Isize , Jsize )) allocate ( temlsy ( Isize , Jsize )) BoomCase % PospO = BoomCase % Posp vb = BoomCase % vs ! Assign velocity do j = 1 , JSize do i = 1 , ISize if ( UCell % MoExCell ( i , j ) /= 1. and . UCell % Posnu ( i , j ) /=- 1 ) then ue ( i , j ) = TVar % u ( i , j ) else ue ( i , j ) = 0.d0 end if end do ue ( 0 , j ) = TVar % u ( 0 , j ) end do do i = 1 , ISize do j = 1 , JSize if ( VCell % MoExCell ( i , j ) /= 1. and . VCell % Posnu ( i , j ) /=- 1 ) then ve ( i , j ) = TVar % v ( i , j ) else ve ( i , j ) = 0.d0 end if end do ve ( i , 0 ) = TVar % v ( i , 0 ) end do do k = 1 , nv ! Start with x-Sweep first then switch to y-Sweep in next sub step if ( mod ( k , 2 ) == 1 ) then temvfx (:,:) = vfl (:,:) temlsx (:,:) = phi (:,:) UpdateNorVec = 1 call X_Sweep ( PGrid , PCell , temvfx , temlsx , ue , ve , nx , ny , dis , dtv , itt , & UpdateNorVec , NondiT , k ) do i = 1 , ISize do j = 1 , JSize temvfx ( i , j ) = temvfx ( i , j ) / (( 1.d0 - PCell % vofS ( i , j ) + tolDeno ) - & dtv / PGrid % dx ( i , j ) * ( ue ( i , j ) * PCell % EEdge_Area ( i , j ) - & ue ( i - 1 , j ) * PCell % WEdge_Area ( i , j ))) temlsx ( i , j ) = temlsx ( i , j ) / (( 1.d0 - PCell % vofS ( i , j ) + tolDeno ) - & dtv / PGrid % dx ( i , j ) * ( ue ( i , j ) * PCell % EEdge_Area ( i , j ) - & ue ( i - 1 , j ) * PCell % WEdge_Area ( i , j ))) vfl ( i , j ) = temvfx ( i , j ) * ( 1.d0 - vflS ( i , j )) phi ( i , j ) = temlsx ( i , j ) if ( vfl ( i , j ) >= 1.d0 - vofeps - vfls ( i , j )) vfl ( i , j ) = 1.d0 - vfls ( i , j ) if ( vfl ( i , j ) < vofeps ) vfl ( i , j ) = 0.d0 end do end do call Boundary_Condition ( vfl ) call Boundary_Condition ( phi ) !    call Boundary_Condition_Vof_Phi(PGrid,NondiT+dble(k)*dtv) temvfy (:,:) = vfl (:,:) temlsy (:,:) = phi (:,:) UpdateNorVec = 1 call Y_Sweep ( PGrid , PCell , temvfy , temlsy , ue , ve , nx , ny , dis , dtv , itt , & UpdateNorVec ) do i = 1 , ISize do j = 1 , JSize temvfy ( i , j ) = temvfy ( i , j ) + dtv / PGrid % dy ( i , j ) * temvfx ( i , j ) * & ( ve ( i , j ) * PCell % NEdge_Area ( i , j ) - ve ( i , j - 1 ) * PCell % SEdge_Area ( i , j )) temlsy ( i , j ) = temlsy ( i , j ) + dtv / PGrid % dy ( i , j ) * temlsx ( i , j ) * & ( ve ( i , j ) * PCell % NEdge_Area ( i , j ) - ve ( i , j - 1 ) * PCell % SEdge_Area ( i , j )) vfl ( i , j ) = temvfy ( i , j ) if ( PCell % vofS ( i , j ) < 1.d0 - epsi ) then phi ( i , j ) = temlsy ( i , j ) / ( 1.d0 - PCell % vofS ( i , j )) end if end do end do else temvfy (:,:) = vfl (:,:) temlsy (:,:) = phi (:,:) UpdateNorVec = 1 call Y_Sweep ( PGrid , PCell , temvfy , temlsy , ue , ve , nx , ny , dis , dtv , itt , & UpdateNorVec ) do i = 1 , ISize do j = 1 , JSize temvfy ( i , j ) = temvfy ( i , j ) / (( 1.d0 - PCell % vofS ( i , j ) + TolDeno ) - & dtv / PGrid % dy ( i , j ) * ( ve ( i , j ) * PCell % NEdge_Area ( i , j ) - & ve ( i , j - 1 ) * PCell % SEdge_Area ( i , j ))) temlsy ( i , j ) = temlsy ( i , j ) / (( 1.d0 - PCell % vofS ( i , j ) + TolDeno ) - & dtv / PGrid % dy ( i , j ) * ( ve ( i , j ) * PCell % NEdge_Area ( i , j ) - & ve ( i , j - 1 ) * PCell % SEdge_Area ( i , j ))) vfl ( i , j ) = temvfy ( i , j ) * ( 1.d0 - vflS ( i , j )) phi ( i , j ) = temlsy ( i , j ) if ( vfl ( i , j ) >= 1.d0 - vofeps - vfls ( i , j )) vfl ( i , j ) = 1.d0 - vfls ( i , j ) if ( vfl ( i , j ) < vofeps ) vfl ( i , j ) = 0.d0 end do end do call Boundary_Condition ( vfl ) call Boundary_Condition ( phi ) temvfx (:,:) = vfl (:,:) temlsx (:,:) = phi (:,:) UpdateNorVec = 1 call X_Sweep ( PGrid , PCell , temvfx , temlsx , ue , ve , nx , ny , dis , dtv , itt , & UpdateNorVec , NondiT , k ) do i = 1 , ISize do j = 1 , JSize temvfx ( i , j ) = temvfx ( i , j ) + dtv / PGrid % dx ( i , j ) * temvfy ( i , j ) * & ( ue ( i , j ) * PCell % EEdge_Area ( i , j ) - ue ( i - 1 , j ) * PCell % WEdge_Area ( i , j )) temlsx ( i , j ) = temlsx ( i , j ) + dtv / PGrid % dx ( i , j ) * temlsy ( i , j ) * & ( ue ( i , j ) * PCell % EEdge_Area ( i , j ) - ue ( i - 1 , j ) * PCell % WEdge_Area ( i , j )) vfl ( i , j ) = temvfx ( i , j ) if ( PCell % vofS ( i , j ) < 1.d0 - epsi ) then phi ( i , j ) = temlsx ( i , j ) / ( 1.d0 - PCell % vofS ( i , j )) end if end do end do end if call ObjectMovement ( BoomCase , dtv ) call SolidVolumeFraction ( Pgrid , PCell , BoomCase ) call Boundary_Condition ( vfl ) call Boundary_Condition ( phi ) UpdateNorVec = 1 call Interface_Reconstruct ( PGrid , nx , ny , dis , UpdateNorVec ) PCell % nx (:,:) = nx (:,:) PCell % ny (:,:) = ny (:,:) call Redistance ( PGrid , nx , ny , dis ) do i = 1 , Isize do j = 1 , Jsize if ( isnan ( phi ( i , j ))) then print * , i , j print * , 'after resdistance' end if end do end do end do nullify ( vfl , phi , vflS , phiS , nxs , nys ) deallocate ( nx , ny ) deallocate ( dis ) deallocate ( temvfx ) deallocate ( temvfy ) deallocate ( temlsx ) deallocate ( temlsy ) deallocate ( ue ) deallocate ( ve ) end subroutine Coupled_LS_VOF subroutine Boundary_Condition ( vari ) IMPLICIT NONE REAL ( KIND = dp ), DIMENSION (:,:) :: vari INTEGER ( kind = it4b ) :: i , j do i = 1 , ISize vari ( i , 1 ) = vari ( i , 2 ) vari ( i , JSize ) = vari ( i , JSize - 1 ) end do do j = 1 , JSize vari ( 1 , j ) = vari ( 2 , j ) vari ( ISize , j ) = vari ( ISize - 1 , j ) end do end subroutine Boundary_Condition subroutine Boundary_Condition_Vof ( vari ) IMPLICIT NONE REAL ( KIND = dp ), DIMENSION (:,:), INTENT ( INOUT ) :: vari INTEGER :: i , j do i = 1 , ISize vari ( i , 1 ) = dmin1 ( vari ( i , 2 ) + vfls ( i , 1 ), 1.d0 ) - vfls ( i , 1 ) vari ( i , JSize ) = dmin1 ( vari ( i , JSize - 1 ) + vfls ( i , Jsize ), 1.d0 ) - vfls ( i , Jsize ) end do do j = 1 , JSize vari ( 1 , j ) = dmin1 ( vari ( 2 , j ) + vfls ( 1 , j ), 1.d0 ) - vfls ( 1 , j ) vari ( ISize , j ) = dmin1 ( vari ( Isize - 1 , j ) + vfls ( Isize , j ), 1.d0 ) - vfls ( ISize , j ) end do end subroutine Boundary_Condition_Vof SUBROUTINE X_Sweep ( PGrid , PCell , temvf , temls , ue , ve , nx , ny , dis , dtv , itt , & UpdateNorVec , NondiT , k ) !! The subroutine compute the advection equation in x direction IMPLICIT NONE TYPE ( Grid ) :: PGrid TYPE ( Cell ) :: PCell INTEGER ( kind = it4b ), INTENT ( IN ) :: UpdateNorVec !! Option for updating the normal vector INTEGER ( kind = it4b ), INTENT ( IN ) :: k !! The present sub-step. It is used for inlet boundary condition INTEGER ( kind = it8b ), INTENT ( IN ) :: itt !! The iteration number REAL ( KIND = dp ), INTENT ( IN ) :: dtv , NondiT REAL ( KIND = dp ), DIMENSION (:,:), allocatable , INTENT ( IN ) :: ue , ve !! The velocity field REAL ( KIND = dp ), DIMENSION (:,:), allocatable , INTENT ( INOUT ) :: nx , ny !! The normal vector of interface REAL ( KIND = dp ), DIMENSION (:,:), allocatable , INTENT ( INOUT ) :: dis !! The distance from cell centre to the interface REAL ( KIND = dp ), DIMENSION (:,:), allocatable :: temvf , temls !! The temporary volume of fluid and level set INTEGER ( kind = it4b ) :: i , j REAL ( KIND = dp ) :: flux , lsr , etau , ul1 , xwu call Interface_Reconstruct ( PGrid , nx , ny , dis , UpdateNorVec ) flux = 0.d0 !! volume of fluid xwu = PGrid % x ( 1 , 1 ) - PGrid % dx ( 1 , 1 ) / 2.d0 do j = 1 , JSize do i = 1 , ISize if ( vflS ( i , j ) < 1.d0 - vofeps ) temvf ( i , j ) = temvf ( i , j ) / ( 1.d0 - vflS ( i , j )) end do end do do j = 1 , JSize do i = 1 , ISize if ( ue ( i , j ) >= 0.d0 ) then if ( vfl ( i , j ) >= ( 1.d0 - vofeps ). or . vfl ( i , j ) <= vofeps ) then flux = vfl ( i , j ) * ue ( i , j ) * dtv else call rightflux ( nx ( i , j ), ny ( i , j ), dis ( i , j ), vfl ( i , j ), nxs ( i , j ), & nys ( i , j ), phiS ( i , j ), vfls ( i , j ), PGrid % dx ( i , j ), PGrid % dy ( i , j ), & ue ( i , j ) * dtv , flux ) end if if ( PCell % EEdge_Area ( i , j ) > 1.d0 - vofeps . and . & vfls ( i , j ) > 1.d0 - vofeps ) flux = 1.d0 * ue ( i , j ) * dtv else if ( i < Isize ) then if ( vfl ( i + 1 , j ) >= ( 1.d0 - vofeps ). or . vfl ( i + 1 , j ) <= vofeps ) then flux = vfl ( i + 1 , j ) * ue ( i , j ) * dtv else call leftflux ( nx ( i + 1 , j ), ny ( i + 1 , j ), dis ( i + 1 , j ), vfl ( i + 1 , j ), & nxs ( i + 1 , j ), nys ( i + 1 , j ), phis ( i + 1 , j ), vfls ( i + 1 , j ), & PGrid % dx ( i + 1 , j ), PGrid % dy ( i + 1 , j ), - ue ( i , j ) * dtv , flux ) flux =- flux end if if ( PCell % WEdge_Area ( i + 1 , j ) > 1.d0 - vofeps . and . & vfls ( i + 1 , j ) > 1.d0 - vofeps ) flux = 1.d0 * ue ( i , j ) * dtv else Flux = vfl ( i , j ) * ue ( i , j ) * dtv end if end if ! this may cause a problem when the solid object moves to the boundary ! when i=1 temvf(1,j) = 1 instead of (1-vfls) if ( i >= 1 ) temvf ( i , j ) = temvf ( i , j ) - flux * PCell % EEdge_Area ( i , j ) / PGrid % dx ( i , j ) if ( i <= ISize - 1 ) then temvf ( i + 1 , j ) = temvf ( i + 1 , j ) * ( 1.d0 - PCell % vofS ( i + 1 , j )) + & flux * PCell % WEdge_Area ( i + 1 , j ) / PGrid % dx ( i + 1 , j ) end if if ( isnan ( temvf ( i , j ))) then print * , flux print * , 'X-Sweep 1263' end if end do ! Boundary condition (it only is applied for inlet wave) etau = amp0 * dsin ( kw * xwu - omew * ( NondiT + dble ( k ) * dtv )) ! UwInlet-Amp0*kw*(UwInlet-cw0)*                   \t\t       & !         dsin(kw*(xwu-cw0*Time))*dcosh(kw*PGrid%y(1,j))/dsinh(kw*Hw) if ( PGrid % y ( 1 , j ) - PGrid % dy ( 1 , j ) / 2.d0 < Depthw + etau ) then ul1 = ue ( 0 , j ) !kw*cw0*etau*dcosh(kw*PGrid%y(1,j))/dsinh(kw*Hw)! ! Flux=dmin1(1.d0,dabs(Hw+etau-(PGrid%y(1,j)-PGrid%dy(1,j)/2.d0))/   & !            PGrid%dy(1,j))*ul1*dtv Flux = vfl ( 1 , j ) * ul1 * dtv else Flux = 0.d0 end if temvf ( 1 , j ) = temvf ( 1 , j ) + flux * PCell % WEdge_Area ( 1 , j ) / PGrid % dx ( 1 , j ) end do ! Level set lsr = 0.d0 flux = 0.d0 do j = 1 , JSize do i = 2 , ISize - 1 if ( ue ( i , j ) >= 0.d0 ) then !   lsr =  phi(i,j)+del_x/2.d0*(1.d0-ue(i,j)*dtv/del_x)*              & !         (phi(i+1,j)-phi(i-1,j))/(2.d0*del_x) lsr = ( phi ( i + 1 , j ) + phi ( i - 1 , j )) / 2.d0 else if ( i <= ISize - 2 ) then !    lsr = phi(i+1,j)-del_x/2.d0*(1.d0+ue(i,j)*dtv/del_x)*           & !          (phi(i+2,j)-phi(i,j))/(2.d0*del_x) lsr = ( phi ( i + 2 , j ) + phi ( i , j )) / 2.d0 else !    lsr = phi(i+1,j)-del_x/2.d0*(1.d0+ue(i,j)*dtv/del_x)*           & !          (phi(i+1,j)-phi(i,j))/(del_x) lsr = ( phi ( i + 1 , j ) + phi ( i - 1 , j )) / 2.d0 end if end if flux = ue ( i , j ) * lsr * dtv if ( i >= 2 ) temls ( i , j ) = temls ( i , j ) - flux * PCell % EEdge_Area ( i , j ) / PGrid % dx ( i , j ) if ( i <= ISize - 1 ) then temls ( i + 1 , j ) = temls ( i + 1 , j ) * ( 1.d0 - PCell % vofS ( i + 1 , j )) + & flux * PCell % WEdge_Area ( i + 1 , j ) / PGrid % dx ( i + 1 , j ) end if end do end do ! At boundary do j = 1 , Jsize if ( ue ( 1 , j ) >= 0.d0 ) then lsr = phi ( 1 , j ) + PGrid % dx ( 1 , j ) / 2.d0 * ( 1.d0 - ue ( 1 , j ) * dtv / PGrid % dx ( 1 , j )) * & ( phi ( 2 , j ) - phi ( 1 , j )) / ( PGrid % x ( 2 , j ) - PGrid % x ( 1 , j )) else lsr = phi ( 2 , j ) - PGrid % dx ( 2 , j ) / 2.d0 * ( 1.d0 + ue ( 1 , j ) * dtv / PGrid % dx ( 2 , j )) * & ( phi ( 3 , j ) - phi ( 1 , j )) / ( 2.d0 * PGrid % dx ( 2 , j )) end if flux = lsr * ue ( 1 , j ) * dtv temls ( 1 , j ) = temls ( 1 , j ) - flux * PCell % EEdge_Area ( 1 , j ) / PGrid % dx ( 1 , j ) temls ( 2 , j ) = temls ( 2 , j ) + flux * PCell % EEdge_Area ( 1 , j ) / PGrid % dx ( 2 , j ) temls ( 1 , j ) = temls ( 1 , j ) + phi ( 1 , j ) * ue ( 0 , j ) * dtv * PCell % WEdge_Area ( 1 , j ) / & PGrid % dx ( 1 , j ) if ( ue ( Isize , j ) > 0.d0 ) then lsr = phi ( Isize , j ) + PGrid % dx ( Isize , j ) / 2.d0 * ( 1.d0 - ue ( Isize , j ) * dtv / & PGrid % dx ( Isize , j )) * ( phi ( Isize , j ) - phi ( Isize - 1 , j )) / & ( PGrid % x ( Isize , j ) - PGrid % x ( Isize - 1 , j )) else lsr = phi ( Isize , j ) - PGrid % dx ( Isize - 1 , j ) / 2.d0 * ( 1.d0 + ue ( Isize , j ) * dtv / & PGrid % dx ( Isize - 1 , j )) * ( phi ( Isize , j ) - phi ( Isize - 1 , j )) / & ( PGrid % x ( Isize , j ) - PGrid % x ( Isize - 1 , j )) end if flux = lsr * ue ( Isize , j ) * dtv temls ( Isize , j ) = temls ( Isize , j ) - flux * PCell % EEdge_Area ( Isize , j ) / & PGrid % dx ( Isize , j ) end do end subroutine X_Sweep subroutine Y_Sweep ( PGrid , PCell , temvf , temls , ue , ve , nx , ny , dis , dtv , itt , & UpdateNorVec ) !! The subroutine compute the advection equation in y direction IMPLICIT NONE TYPE ( Grid ), INTENT ( IN ) :: PGrid TYPE ( Cell ), INTENT ( IN ) :: PCell INTEGER ( kind = it4b ), INTENT ( IN ) :: UpdateNorVec INTEGER ( kind = it8b ), INTENT ( IN ) :: itt REAL ( KIND = dp ), INTENT ( IN ) :: dtv REAL ( KIND = dp ), DIMENSION (:,:), allocatable , INTENT ( IN ) :: ue , ve REAL ( KIND = dp ), DIMENSION (:,:), allocatable , INTENT ( INOUT ) :: nx , ny , dis REAL ( KIND = dp ), DIMENSION (:,:), allocatable :: temvf , temls INTEGER ( kind = it4b ) :: i , j REAL ( KIND = dp ) :: flux , lst call Interface_Reconstruct ( PGrid , nx , ny , dis , UpdateNorVec ) flux = 0.d0 ! volume of fluid do j = 1 , JSize do i = 1 , ISize if ( vflS ( i , j ) < 1.d0 - vofeps ) temvf ( i , j ) = temvf ( i , j ) / ( 1.d0 - vflS ( i , j )) end do end do do i = 1 , ISize do j = 1 , JSize if ( ve ( i , j ) > 0.d0 ) then if ( vfl ( i , j ) >= ( 1.d0 - vofeps ). or . vfl ( i , j ) <= vofeps ) then flux = vfl ( i , j ) * ve ( i , j ) * dtv if ( vfl ( i , j ) >= 1.d0 ) flux = ve ( i , j ) * dtv if ( vfl ( i , j ) < 0.d0 ) flux = 0.d0 else call topflux ( nx ( i , j ), ny ( i , j ), dis ( i , j ), vfl ( i , j ), nxs ( i , j ), & nys ( i , j ), phis ( i , j ), vfls ( i , j ), PGrid % dx ( i , j ), PGrid % dy ( i , j ), & ve ( i , j ) * dtv , flux ) end if if ( PCell % NEdge_Area ( i , j ) > 1.d0 - vofeps . and . & vfls ( i , j ) > 1.d0 - vofeps ) flux = 1.d0 * ve ( i , j ) * dtv else if ( j < Jsize ) then if ( vfl ( i , j + 1 ) >= ( 1.d0 - vofeps ). or . vfl ( i , j + 1 ) <= vofeps ) then flux = vfl ( i , j + 1 ) * ve ( i , j ) * dtv if ( vfl ( i , j + 1 ) >= 1.d0 ) flux = ve ( i , j ) * dtv if ( vfl ( i , j + 1 ) < 0.d0 ) flux = 0.d0 else call bottomflux ( nx ( i , j + 1 ), ny ( i , j + 1 ), dis ( i , j + 1 ), vfl ( i , j + 1 ), & nxs ( i , j + 1 ), nys ( i , j + 1 ), phis ( i , j + 1 ), vfls ( i , j + 1 ), & PGrid % dx ( i , j + 1 ), PGrid % dy ( i , j + 1 ), - ve ( i , j ) * dtv , flux ) flux =- flux endif if ( PCell % SEdge_Area ( i , j + 1 ) > 1.d0 - vofeps . and . & vfls ( i , j + 1 ) > 1.d0 - vofeps ) flux = 1.d0 * ve ( i , j ) * dtv else flux = vfl ( i , j ) * ve ( i , j ) * dtv endif end if !****************************************************************** ! Note: this may cause a trouble when object moving to boundary when i=1 if ( j >= 1 ) temvf ( i , j ) = temvf ( i , j ) - flux * PCell % NEdge_Area ( i , j ) / PGrid % dy ( i , j ) if ( j <= JSize - 1 ) then temvf ( i , j + 1 ) = temvf ( i , j + 1 ) * ( 1.d0 - PCell % vofS ( i , j + 1 )) + & flux * PCell % SEdge_Area ( i , j + 1 ) / PGrid % dy ( i , j + 1 ) end if end do temvf ( i , 1 ) = temvf ( i , 1 ) + vfl ( i , 1 ) * ve ( i , 0 ) * dtv * PCell % SEdge_Area ( i , 1 ) / & PGrid % dy ( i , 1 ) end do lst = 0.d0 flux = 0.d0 ! level set do j = 2 , JSize - 1 do i = 1 , ISize if ( ve ( i , j ) >= 0.d0 ) then !     lst = phi(i,j)+del_y/2.d0*(1.d0-ve(i,j)*dtv/del_y)*               & !           (phi(i,j+1)-phi(i,j-1))/(2.d0*del_y) lst = ( phi ( i , j + 1 ) + phi ( i , j - 1 )) / 2.d0 else if ( j <= JSize - 2 ) then !     lst = phi(i,j+1)-del_y/2.d0*(1.d0+ve(i,j)*dtv/del_y)*           & !          (phi(i,j+2)-phi(i,j))/(2.d0*del_y) lst = ( phi ( i , j + 2 ) + phi ( i , j )) / 2.d0 else !    lst = phi(i,j+1)-del_y/2.d0*(1.d0+ve(i,j)*dtv/del_y)*           & !    (phi(i,j+1)-phi(i,j))/del_y lst = ( phi ( i , j + 1 ) + phi ( i , j - 1 )) / 2.d0 end if end if flux = lst * ve ( i , j ) * dtv if ( j >= 2 ) temls ( i , j ) = temls ( i , j ) - flux * PCell % NEdge_Area ( i , j ) / PGrid % dy ( i , j ) if ( j <= JSize - 1 ) then temls ( i , j + 1 ) = temls ( i , j + 1 ) * ( 1.d0 - PCell % vofS ( i , j + 1 )) + & flux * PCell % SEdge_Area ( i , j + 1 ) / PGrid % dy ( i , j + 1 ) end if end do end do do i = 1 , Isize if ( ve ( i , 1 ) >= 0.d0 ) then lst = phi ( i , 1 ) + PGrid % dy ( i , 1 ) / 2.d0 * ( 1.d0 - ve ( i , 1 ) * dtv / PGrid % dy ( i , 1 )) * & ( phi ( i , 2 ) - phi ( i , 1 )) / ( PGrid % y ( i , 2 ) - PGrid % y ( i , 1 )) else lst = phi ( i , 2 ) - PGrid % dy ( i , 2 ) / 2.d0 * ( 1.d0 + ve ( i , 1 ) * dtv / PGrid % dy ( i , 2 )) * & ( phi ( i , 3 ) - phi ( i , 1 )) / ( PGrid % y ( i , 3 ) - PGrid % y ( i , 1 )) end if flux = lst * ve ( i , 1 ) * dtv temls ( i , 1 ) = temls ( i , 1 ) - flux * PCell % NEdge_Area ( i , 1 ) / PGrid % dy ( i , 1 ) temls ( i , 2 ) = temls ( i , 2 ) + flux * PCell % NEdge_Area ( i , 1 ) / PGrid % dy ( i , 2 ) temls ( i , 1 ) = temls ( i , 1 ) + phi ( i , 1 ) * ve ( i , 0 ) * dtv * PCell % SEdge_Area ( i , 1 ) / & PGrid % dy ( i , 1 ) if ( ve ( i , Jsize ) > 0.d0 ) then lst = phi ( i , Jsize ) + PGrid % dy ( i , Jsize ) / 2.d0 * ( 1.d0 - ve ( i , Jsize ) * dtv / & PGrid % dy ( i , Jsize )) * ( phi ( i , Jsize ) - phi ( i , Jsize - 1 )) / & ( PGrid % y ( i , Jsize ) - PGrid % y ( i , Jsize - 1 )) else lst = phi ( i , Jsize ) - PGrid % dy ( i , Jsize - 1 ) / 2.d0 * ( 1.d0 + ve ( i , Jsize ) * dtv / & PGrid % dy ( i , Jsize - 1 )) * ( phi ( i , Jsize ) - phi ( i , Jsize - 1 )) / & ( PGrid % y ( i , Jsize ) - PGrid % y ( i , Jsize - 1 )) end if flux = lst * ve ( i , Jsize ) * dtv temls ( i , Jsize ) = temls ( i , Jsize ) - flux / PGrid % dy ( i , Jsize ) end do end subroutine Y_Sweep ! level set step ! build-up interface subroutine Interface_Reconstruct ( PGrid , nx , ny , dis , UpdateNorVec ) !! The subroutine will compute the interface normal vector and distance from !! the cell center to the interface. Basically, we need all information !! about the equation of a line. IMPLICIT NONE TYPE ( Grid ), INTENT ( IN ) :: PGrid INTEGER ( kind = it4b ), INTENT ( IN ) :: UpdateNorVec REAL ( KIND = dp ), DIMENSION (:,:), allocatable , INTENT ( INOUT ) :: nx , ny , dis REAL ( KIND = dp ) :: nxx , nyy , diss , temp INTEGER :: i , j , flag do i = 1 , ISize do j = 1 , JSize flag = 0 ! Set up flag for checking whether the cell contains two phases or three phases if ( vfl ( i , j ) >= vofeps . and . vfl ( i , j ) < ( 1.d0 - vofeps - vfls ( i , j )). and . & vfls ( i , j ) < epsi ) then flag = 1 end if if ( vfl ( i , j ) >= vofeps . and . vfl ( i , j ) < ( 1.d0 - vofeps - vfls ( i , j )). and . & vfls ( i , j ) >= epsi . and . vfls ( i , j ) < 1.d0 - epsi ) then flag = 2 end if if ( flag == 1. or . flag == 2 ) then if ( UpdateNorVec == 1 ) then if ( i > 1. and . i < Isize . and . j > 1. and . j < Jsize ) then call Normal_Vector_Irre ( PGrid , i , j , nxx , nyy ) else if ( i == 1 ) then nxx = ( phi ( i + 1 , j ) - phi ( i , j )) / ( PGrid % x ( i + 1 , j ) - PGrid % x ( i , j )) elseif ( i == Isize ) then nxx = ( phi ( i , j ) - phi ( i - 1 , j )) / ( PGrid % x ( i , j ) - PGrid % x ( i - 1 , j )) endif if ( j == 1 ) then nyy = ( phi ( i , j + 1 ) - phi ( i , j )) / ( PGrid % y ( i , j + 1 ) - PGrid % y ( i , j )) elseif ( j == Jsize ) then nyy = ( phi ( i , j ) - phi ( i , j - 1 )) / ( PGrid % y ( i , j ) - PGrid % y ( i , j - 1 )) endif endif ! Test the normal vector for cell containing all three phases if ( vfls ( i , j ) > epsi . and . vfls ( i , j ) < 1.d0 - epsi ) then ! nxx=dsign(1.d0,nxs(i,j))*dabs(nxx) end if if ( vfl ( i , j ) > epsi . and . vfl ( i , j ) < 1.d0 - epsi ) then ! nxx=dsign(1.d0,nxs(i,j))*dabs(nxx) end if ! *************************************************************** temp = dsqrt ( nxx ** 2.d0 + nyy ** 2.d0 ) if ( temp < 1.d-14 ) then nxx = 0.d0 nyy = 1.d0 else nxx = nxx / temp nyy = nyy / temp end if end if select case ( flag ) case ( 1 ) ! for 2 phases (gas and liquid) call distance ( i , j , PGrid % dx ( i , j ), PGrid % dy ( i , j ), nxx , nyy , diss ) case ( 2 ) ! for 3 phases (gas, liquid and solid) call DistanceFluidCalculate ( nxs ( i , j ), nys ( i , j ), phis ( i , j ), nxx , & nyy , vfl ( i , j ), PGrid % dx ( i , j ), PGrid % dy ( i , j ), diss ) end select else nxx = 0.d0 ; nyy = 1.d0 if ( 1.d0 - vfls ( i , j ) > vofeps ) then diss = ( 0.5d0 - vfl ( i , j ) / ( 1.d0 - vfls ( i , j ))) * PGrid % dy ( i , j ) else diss = ( 0.d0 - vfl ( i , j )) * PGrid % dy ( i , j ) end if end if nx ( i , j ) = nxx ny ( i , j ) = nyy dis ( i , j ) = diss end do end do end subroutine Interface_Reconstruct subroutine distance ( i , j , dx , dy , nxx , nyy , diss ) !! The subroutine will compute the distance from a point to the interface. !! It will compute based on the normal vector and volume of fluid. IMPLICIT NONE INTEGER i , j real ( dp ) slop_eps , nxx , nyy , nx , ny , diss , equal_eps real ( dp ) dll , dul , dlr , dur , vful , vflr , theta , dx , dy slop_eps = 1.d-20 equal_eps = 1.d-20 nx = dabs ( nxx ) ny = dabs ( nyy ) ! When the interface is parallel to x or y direction if ( nx < slop_eps ) then diss = ( 0.5d0 - vfl ( i , j )) * dy return end if if ( ny < slop_eps ) then diss = ( 0.5d0 - vfl ( i , j )) * dx return end if dll = 0.5d0 * ( nx * dx + ny * dy ) dul = 0.5d0 * ( nx * dx - ny * dy ) dlr = - dul dur = - dll call frac ( nx , ny , dul , dx , dy , vful ) call frac ( nx , ny , dlr , dx , dy , vflr ) if ( vfl ( i , j ) <= vful . and . vfl ( i , j ) <= vflr ) then if ( vful > vflr ) then call swap ( vful , vflr ) call swap ( dul , dlr ) end if diss = dll - dsqrt ((( dul - dll ) ** 2.d0 ) * vfl ( i , j ) / vful ) return elseif ( vfl ( i , j ) >= vful . and . vfl ( i , j ) >= vflr ) then if ( vflr < vful ) then call swap ( vful , vflr ) call swap ( dul , dlr ) end if diss = dur + dsqrt (( dlr - dur ) ** 2.d0 * ( 1.d0 - vfl ( i , j )) / ( 1.d0 - vflr )) return else if ( dabs ( vflr - vful ) < equal_eps ) THEN diss = 0.5d0 * ( dul + dlr ) return end if theta = ( vfl ( i , j ) - vful ) / ( vflr - vful ) diss = dlr * theta + dul * ( 1.0d0 - theta ) end if return end subroutine subroutine frac ( nx , ny , diss , dx , dy , vrt ) !! The subroutine computes the volume of fluid in a cell with height of dy !! and width of dx. IMPLICIT NONE real ( dp ) slop_eps , nx , ny , diss , vrt , tnx , tny , dx , dy real ( dp ) xx , yy , topvf , rightvf , totalarea slop_eps = 1.d-20 tnx = dabs ( nx ) tny = dabs ( ny ) if ( diss + 0.5d0 * ( tnx * dx + tny * dy ) <= 0.d0 ) then vrt = 1.d0 return end if if ( diss - 0.5d0 * ( tnx * dx + tny * dy ) >= 0.d0 ) then vrt = 0.d0 return end if if ( tnx <= slop_eps ) then vrt = 0.5d0 - diss / dy return end if if ( tny <= slop_eps ) then vrt = 0.5d0 - diss / dx return end if xx = ( 0.5d0 * tny * dy - diss ) / dx / tnx + 0.5d0 yy = ( 0.5d0 * tnx * dx - diss ) / dy / tny + 0.5d0 totalarea = 0.5d0 * xx * yy topvf = 0.d0 if ( yy > 1.d0 ) topvf = (( yy - 1.d0 ) / yy ) ** 2.d0 rightvf = 0.d0 if ( xx > 1.d0 ) rightvf = (( xx - 1.d0 ) / xx ) ** 2.d0 vrt = totalarea * ( 1.d0 - topvf - rightvf ) if ( vrt < 0.d0 ) write ( * , * ) 'vrt less than 0' return end subroutine subroutine swap ( a , b ) IMPLICIT NONE real ( dp ) a , b , t t = a a = b b = t return end subroutine subroutine topflux ( nxx , nyy , diss , volf , nxss , nyss , phiss , vols , dx , dy , vdt , flux ) !! The subroutine calculate flux through the top of cell IMPLICIT NONE REAL ( KIND = dp ), INTENT ( IN ) :: nxx , nyy , diss , volf , nxss , nyss , phiss , vols , vdt , dx , dy REAL ( KIND = dp ), INTENT ( OUT ) :: flux REAL ( KIND = dp ) :: eps , volss eps = 1.d-14 if ( vdt == 0.d0 ) then flux = 0.d0 return end if ! For cell contains two phases if ( vols < epsi ) then call frac ( nxx , nyy , diss - 0.5d0 * ( vdt - dy ) * nyy , dx , vdt , flux ) elseif ( vols >= 1.d0 - epsi ) then flux = volf return else ! For cell contains three phases call CellGeoCal ( nxss , nyss , phiss - 0.5d0 * ( vdt - dy ) * nyss , nxx , nyy , & diss - 0.5d0 * ( vdt - dy ) * nyy , dx , vdt , volss , flux ) if ( volf / ( 1.d0 - vols ) >= 1.d0 - vofeps ) flux = 1.d0 - volss ! Using the volume averaging value flux = flux / ( 1.d0 - volss + toldeno ) if ( volf + vols > 1.d0 - eps ) flux = 1.d0 end if flux = flux * vdt return end subroutine subroutine bottomflux ( nxx , nyy , diss , volf , nxss , nyss , phiss , vols , dx , dy , vdt , flux ) !! The subroutine calculates flux through the bottom of cell IMPLICIT NONE REAL ( KIND = dp ), INTENT ( IN ) :: nxx , nyy , diss , volf , nxss , nyss , phiss , vols , vdt , dx , dy REAL ( KIND = dp ), INTENT ( OUT ) :: flux REAL ( KIND = dp ) :: eps , volss eps = 1.d-14 if ( vdt == 0.d0 ) then flux = 0.d0 return end if if ( vols < epsi ) then call frac ( nxx , nyy , diss + 0.5d0 * ( vdt - dy ) * nyy , dx , vdt , flux ) elseif ( vols >= 1.d0 - epsi ) then flux = volf return else call CellGeoCal ( nxss , nyss , phiss + 0.5d0 * ( vdt - dy ) * nyss , nxx , nyy , & diss + 0.5d0 * ( vdt - dy ) * nyy , dx , vdt , volss , flux ) if ( volf / ( 1.d0 - vols ) >= 1.d0 - vofeps ) flux = 1.d0 - volss ! Using the volume averaging value flux = flux / ( 1.d0 - volss + toldeno ) if ( volf + vols > 1.d0 - eps ) flux = 1.d0 end if flux = flux * vdt end subroutine subroutine rightflux ( nxx , nyy , diss , volf , nxss , nyss , phiss , vols , dx , dy , udt , flux ) !! The subroutine calculates flux through the right of cell IMPLICIT NONE REAL ( KIND = dp ), INTENT ( IN ) :: nxx , nyy , diss , volf , nxss , nyss , phiss , vols , udt , dx , dy REAL ( KIND = dp ), INTENT ( OUT ) :: flux REAL ( KIND = dp ) :: eps , volss eps = 1.d-14 if ( udt == 0.d0 ) then flux = 0.d0 return end if if ( vols < epsi ) then call frac ( nxx , nyy , diss - 0.5d0 * ( udt - dx ) * nxx , udt , dy , flux ) elseif ( vols >= 1.d0 - epsi ) then flux = volf return else call CellGeoCal ( nxss , nyss , phiss - 0.5d0 * ( udt - dx ) * nxss , nxx , nyy , & diss - 0.5d0 * ( udt - dx ) * nxx , udt , dy , volss , flux ) if ( volf / ( 1.d0 - vols ) >= 1.d0 - vofeps ) flux = 1.d0 - volss ! Using the volume averaging value flux = flux / ( 1.d0 - volss + toldeno ) if ( volf + vols > 1.d0 - eps ) flux = 1.d0 end if flux = flux * udt end subroutine subroutine leftflux ( nxx , nyy , diss , volf , nxss , nyss , phiss , vols , dx , dy , udt , flux ) !! The subroutine calculates flux throught the left of cell IMPLICIT NONE REAL ( KIND = dp ), INTENT ( IN ) :: nxx , nyy , diss , volf , nxss , nyss , phiss , vols , udt , dx , dy REAL ( KIND = dp ), INTENT ( OUT ) :: flux REAL ( KIND = dp ) :: eps , volss eps = 1.d-14 if ( udt == 0.d0 ) then flux = 0.d0 return end if if ( vols < epsi ) then call frac ( nxx , nyy , diss + 0.5d0 * ( udt - dx ) * nxx , udt , dy , flux ) elseif ( vols >= 1.d0 - epsi ) then flux = volf return else call CellGeoCal ( nxss , nyss , phiss + 0.5d0 * ( udt - dx ) * nxss , nxx , nyy , & diss + 0.5d0 * ( udt - dx ) * nxx , udt , dy , volss , flux ) if ( volf / ( 1.d0 - vols ) >= 1.d0 - vofeps ) flux = 1.d0 - volss ! Using the volume averaging value flux = flux / ( 1.d0 - volss + toldeno ) if ( volf + vols > 1.d0 - eps ) flux = 1.d0 end if flux = flux * udt end subroutine subroutine Redistance ( PGrid , nxx1 , nyy1 , diss1 ) !! The subroutine will recompute level set from present interface configuration IMPLICIT NONE TYPE ( Grid ), INTENT ( IN ) :: PGrid REAL ( KIND = dp ), DIMENSION (:,:), allocatable , INTENT ( IN ) :: nxx1 , nyy1 , diss1 INTEGER ( kind = it4b ) :: i , j , ii , jj , l , m REAL ( KIND = dp ) :: xv , yv , dv , deuc , dij1 , dvs , del_x , del_y REAL ( KIND = dp ) :: xp , yp , xoff , yoff , xfc , yfc , xs , ys , tol logical :: pointp REAL ( KIND = dp ), DIMENSION (:,:), allocatable :: phiaux INTEGER , DIMENSION (:,:), allocatable :: fix allocate ( fix ( Isize , Jsize )) allocate ( phiaux ( Isize , Jsize )) fix (:,:) = 0 phiaux (:,:) = 1.d4 tol = 1.d-24 del_x = PGrid % dx ( Isize / 2 , Jsize / 2 ) del_y = PGrid % dy ( Isize / 2 , Jsize / 2 ) do i = 1 , ISize do j = 1 , JSize if (( 0.d0 + vofeps ) < vfl ( i , j ). and . vfl ( i , j ) < ( 1.d0 - vofeps - vflS ( i , j ))) then phiaux ( i , j ) = diss1 ( i , j ) fix ( i , j ) = 1 do ii =- band_width , band_width do jj =- band_width , band_width ! determine the point xv on the boundary cell(i,j,k) with the ! shortest distance to the cell center of (i+ii,j+jj) if ( i + ii >= 1. and . i + ii <= ISize . and . j + jj >= 1. and . j + jj <= JSize ) then if ( vfl ( i + ii , j + jj ) < 0.d0 + vofeps . or . & vfl ( i + ii , j + jj ) >= 1.d0 - vofeps - vflS ( i + ii , j + jj )) then fix ( i + ii , j + jj ) = 1 l = max ( - 1 , min ( 1 , ii )) m = max ( - 1 , min ( 1 , jj )) xv = PGrid % dx ( i , j ) * dble ( l ) / 2.d0 yv = PGrid % dy ( i , j ) * dble ( m ) / 2.d0 dvs = nxs ( i , j ) * xv + nys ( i , j ) * yv + phiS ( i , j ) ! Check whether the point(xv,yv) is inside the solid object if ( dvs < 0.d0 ) then if ( dabs ( yv ) < vofeps ) then yv = PGrid % dy ( i , j ) / 2.d0 dvs = nxs ( i , j ) * xv + nys ( i , j ) * yv + phiS ( i , j ) if ( dvs < 0.d0 ) then yv =- PGrid % dy ( i , j ) / 2.d0 dvs = nxs ( i , j ) * xv + nys ( i , j ) * yv + phiS ( i , j ) if ( dvs < 0.d0 ) then xv = PGrid % dx ( i , j ) * ( 0.d0 - dble ( l )) / 2.d0 dvs = nxs ( i , j ) * xv + nys ( i , j ) * yv + phiS ( i , j ) if ( dvs < 0.d0 ) yv = PGrid % dy ( i , j ) / 2.d0 end if end if elseif ( dabs ( xv ) < vofeps ) then xv = PGrid % dx ( i , j ) / 2.d0 dvs = nxs ( i , j ) * xv + nys ( i , j ) * yv + phiS ( i , j ) if ( dvs < 0.d0 ) then xv =- PGrid % dx ( i , j ) / 2.d0 dvs = nxs ( i , j ) * xv + nys ( i , j ) * yv + phiS ( i , j ) if ( dvs < 0.d0 ) then yv = PGrid % dy ( i , j ) * ( 0.d0 - dble ( m )) / 2.d0 dvs = nxs ( i , j ) * xv + nys ( i , j ) * yv + phiS ( i , j ) if ( dvs < 0.d0 ) xv = PGrid % dx ( i , j ) / 2.d0 end if end if else yv = PGrid % dy ( i , j ) * ( 0.d0 - dble ( m )) / 2.d0 dvs = nxs ( i , j ) * xv + nys ( i , j ) * yv + phiS ( i , j ) if ( dvs < 0.d0 ) then xv = PGrid % dx ( i , j ) * ( 0.d0 - dble ( l )) / 2.d0 yv = PGrid % dy ( i , j ) * dble ( m ) / 2.d0 dvs = nxs ( i , j ) * xv + nys ( i , j ) * yv + phiS ( i , j ) if ( dvs < 0.d0 ) yv = PGrid % dy ( i , j ) * ( 0.d0 - dble ( m )) / 2.d0 end if end if end if ! Distance from a point to the interface dv = nxx1 ( i , j ) * xv + nyy1 ( i , j ) * yv + diss1 ( i , j ) if ( dv * dsign ( 1.d0 , phi ( i + ii , j + jj )) <= 0.d0 ) then deuc = dsqrt ((( PGrid % x ( i + ii , j + jj ) - PGrid % x ( i , j )) - xv ) ** 2.d0 + & (( PGrid % y ( i + ii , j + jj ) - PGrid % y ( i , j )) - yv ) ** 2.d0 ) if ( vfls ( i + ii , j + jj ) < epsi ) then phiaux ( i + ii , j + jj ) = dsign ( 1.d0 , 0.5d0 - vfl ( i + ii , j + jj )) * & dmin1 ( deuc , dabs ( phiaux ( i + ii , j + jj ))) else if ( dabs ( deuc ) < dabs ( phiaux ( i + ii , j + jj )). and . & vfl ( i + ii , j + jj ) >= 1.d0 - vofeps - vflS ( i + ii , j + jj )) & phiaux ( i + ii , j + jj ) =- dabs ( deuc ) if ( dabs ( deuc ) < dabs ( phiaux ( i + ii , j + jj )). and . & vfl ( i + ii , j + jj ) < vofeps ) & phiaux ( i + ii , j + jj ) = dabs ( deuc ) end if ! Third step: find the projection of x' onto the interface else dij1 = nxx1 ( i , j ) * ( PGrid % x ( i + ii , j + jj ) - PGrid % x ( i , j )) + & nyy1 ( i , j ) * ( PGrid % y ( i + ii , j + jj ) - PGrid % y ( i , j )) + diss1 ( i , j ) xp = ( PGrid % x ( i + ii , j + jj ) - PGrid % x ( i , j )) - dij1 * nxx1 ( i , j ) yp = ( PGrid % y ( i + ii , j + jj ) - PGrid % y ( i , j )) - dij1 * nyy1 ( i , j ) pointp = isinsiderect ( xp , yp , PGrid % dx ( i , j ), PGrid % dy ( i , j )) if (( pointp . eqv .. true .). and . vfls ( i + ii , j + jj ) < epsi ) then deuc = dsqrt ((( PGrid % x ( i + ii , j + jj ) - PGrid % x ( i , j )) - xp ) ** 2.d0 + & (( PGrid % y ( i + ii , j + jj ) - PGrid % y ( i , j )) - yp ) ** 2.d0 ) ! deuc = dij1 phiaux ( i + ii , j + jj ) = dsign ( 1.d0 , 0.5d0 - vfl ( i + ii , j + jj )) * & dmin1 ( deuc , dabs ( phiaux ( i + ii , j + jj ))) elseif (( pointp . eqv .. true .). and . vfls ( i + ii , j + jj ) >= epsi . and . & vfls ( i + ii , j + jj ) < 1.d0 - epsi ) then deuc = dsqrt ((( PGrid % x ( i + ii , j + jj ) - PGrid % x ( i , j )) - xp ) ** 2.d0 + & (( PGrid % y ( i + ii , j + jj ) - PGrid % y ( i , j )) - yp ) ** 2.d0 ) if ( dabs ( deuc ) < dabs ( phiaux ( i + ii , j + jj )). and . & vfl ( i + ii , j + jj ) >= 1.d0 - vofeps - vfls ( i + ii , j + jj ))& phiaux ( i + ii , j + jj ) =- dabs ( deuc ) if ( dabs ( deuc ) < dabs ( phiaux ( i + ii , j + jj )). and . & vfl ( i + ii , j + jj ) < vofeps ) & phiaux ( i + ii , j + jj ) = dabs ( deuc ) elseif ( vfls ( i + ii , j + jj ) >= 1.d0 - epsi ) then if ( vfls ( i , j ) < epsi ) then deuc = dsqrt ((( PGrid % x ( i + ii , j + jj ) - PGrid % x ( i , j )) - xp ) ** 2.d0 + & (( PGrid % y ( i + ii , j + jj ) - PGrid % y ( i , j )) - yp ) ** 2.d0 ) if ( dabs ( deuc ) < dabs ( phiaux ( i + ii , j + jj ))) & phiaux ( i + ii , j + jj ) = dsign ( 1.d0 , dij1 ) * deuc end if else ! Forth step: find the corner xoff = dmax1 ( dabs ( xp ) - 0.5d0 * PGrid % dx ( i , j ), 0.d0 ) yoff = dmax1 ( dabs ( yp ) - 0.5d0 * PGrid % dy ( i , j ), 0.d0 ) xfc = dsign ( 1.d0 , xp ) * 0.5d0 * PGrid % dx ( i , j ) yfc = dsign ( 1.d0 , yp ) * 0.5d0 * PGrid % dy ( i , j ) if ( xoff * dabs ( nxx1 ( i , j ) + tol ) >= yoff * dabs ( nyy1 ( i , j ) + tol )) then xs = xfc ys = ( diss1 ( i , j ) + nxx1 ( i , j ) * xs ) / ( - nyy1 ( i , j ) + tol ) else ys = yfc xs = ( diss1 ( i , j ) + nyy1 ( i , j ) * ys ) / ( - nxx1 ( i , j ) + tol ) endif deuc = dsqrt ((( PGrid % x ( i + ii , j + jj ) - PGrid % x ( i , j )) - xs ) ** 2.d0 + & (( PGrid % y ( i + ii , j + jj ) - PGrid % y ( i , j )) - ys ) ** 2.d0 ) dvs = nxs ( i , j ) * xs + nys ( i , j ) * ys + phis ( i , j ) if ( dvs >= 0.d0 ) then if ( vfls ( i + ii , j + jj ) < epsi ) then phiaux ( i + ii , j + jj ) = dsign ( 1.d0 , 0.5d0 - vfl ( i + ii , j + jj )) * & dmin1 ( deuc , dabs ( phiaux ( i + ii , j + jj ))) else if ( dabs ( deuc ) < dabs ( phiaux ( i + ii , j + jj )). and . & vfl ( i + ii , j + jj ) >= 1.d0 - vofeps - vfls ( i + ii , j + jj )) & phiaux ( i + ii , j + jj ) =- dabs ( deuc ) if ( dabs ( deuc ) < dabs ( phiaux ( i + ii , j + jj )). and . & vfl ( i + ii , j + jj ) < vofeps ) & phiaux ( i + ii , j + jj ) = dabs ( deuc ) end if end if endif endif endif ! this condition will eliminate bugs in the case that ! interface is vertical or horizontal if ( phiaux ( i + ii , j + jj ) > 9.999d3 ) fix ( i + ii , j + jj ) = 0 end if end do end do end if end do end do ! Update the level set do i = 1 , ISize do j = 1 , JSize if ( fix ( i , j ) == 1 ) then phi ( i , j ) = phiaux ( i , j ) else if ( vfl ( i , j ) <= vofeps ) then phi ( i , j ) = dble ( band_width + 1 ) * dsqrt ( PGrid % dx ( i , j ) ** 2.d0 + & PGrid % dy ( i , j ) ** 2.d0 ) elseif ( vfl ( i , j ) >= ( 1.d0 - vofeps - vfls ( i , j ))) then phi ( i , j ) =- dble ( band_width + 1 ) * dsqrt ( PGrid % dx ( i , j ) ** 2.d0 + & PGrid % dy ( i , j ) ** 2.d0 ) end if end if if ( vfl ( i , j ) < vofeps . and . phi ( i , j ) <- vofeps . and . vfls ( i , j ) < 1.d0 - epsi ) then print * , i , j print * , vfl ( i , j ), fix ( i , j ) print * , phi ( i , j ), phiaux ( i , j ) pause 'clsvof 1095' end if end do end do end subroutine subroutine Normal_Vector_Irre ( PGrid , i , j , nx , ny ) !! The subroutine computes normal vector based on level set IMPLICIT NONE TYPE ( Grid ), INTENT ( IN ) :: PGrid INTEGER , INTENT ( IN ) :: i , j real ( dp ), INTENT ( OUT ) :: nx , ny real ( dp ), PARAMETER :: eta = 0.075d0 INTEGER :: dx , dy , Imv , ii real ( dp ) :: qi ( - 1 : 1 ), qj ( - 1 : 1 ), nuy real ( dp ) :: vx , vy , vx1 , vx2 , vy1 , vy2 , qv1 , qv2 , V1 ( 2 ), V2 ( 2 ), MaxVect , CosPar nuy = eta / 8.d0 ! define qi for Dx if ( vfls ( i , j ) >= epsi ) then if ( vfls ( i + 1 , j ) < 1.d0 - epsi . and . vfls ( i - 1 , j ) < 1.d0 - epsi ) then nx = ( phi ( i + 1 , j ) - phi ( i - 1 , j )) / ( PGrid % x ( i + 1 , j ) - PGrid % x ( i - 1 , j )) elseif ( vfls ( i + 1 , j ) >= 1.d0 - epsi ) then nx = ( phi ( i , j ) - phi ( i - 1 , j )) / ( PGrid % x ( i , j ) - PGrid % x ( i - 1 , j )) else nx = ( phi ( i + 1 , j ) - phi ( i , j )) / ( PGrid % x ( i + 1 , j ) - PGrid % x ( i , j )) end if if ( vfls ( i , j + 1 ) < 1.d0 - epsi . and . vfls ( i , j - 1 ) < 1.d0 - epsi ) then ny = ( phi ( i , j + 1 ) - phi ( i , j - 1 )) / ( PGrid % y ( i , j + 1 ) - PGrid % y ( i , j - 1 )) elseif ( vfls ( i , j + 1 ) > 1.d0 - epsi ) then ny = ( phi ( i , j ) - phi ( i , j - 1 )) / ( PGrid % y ( i , j ) - PGrid % y ( i , j - 1 )) else ny = ( phi ( i , j + 1 ) - phi ( i , j )) / ( PGrid % y ( i , j + 1 ) - PGrid % y ( i , j )) end if return end if if ( i >= 3 ) then ! for q(-1) vx = ( phi ( i , j ) - phi ( i - 2 , j )) / ( PGrid % x ( i , j ) - PGrid % x ( i - 2 , j )) else vx = ( phi ( i , j ) - phi ( i - 1 , j )) / ( PGrid % x ( i , j ) - PGrid % x ( i - 1 , j )) end if vy = ( phi ( i - 1 , j + 1 ) - phi ( i - 1 , j - 1 )) / ( PGrid % y ( i - 1 , j + 1 ) - PGrid % y ( i - 1 , j - 1 )) qi ( - 1 ) = dabs ( 1.d0 - dsqrt ( vx ** 2.d0 + vy ** 2.d0 )) ! for q(0) vx = ( phi ( i + 1 , j ) - phi ( i - 1 , j )) / ( PGrid % x ( i + 1 , j ) - PGrid % x ( i - 1 , j )) vy = ( phi ( i , j + 1 ) - phi ( i , j - 1 )) / ( PGrid % y ( i , j + 1 ) - PGrid % y ( i , j - 1 )) qi ( 0 ) = dabs ( 1.d0 - dsqrt ( vx ** 2.d0 + vy ** 2.d0 )) ! for q(1) if ( i <= ISize - 2 ) then vx = ( phi ( i + 2 , j ) - phi ( i , j )) / ( PGrid % x ( i + 2 , j ) - PGrid % x ( i , j )) else vx = ( phi ( i + 1 , j ) - phi ( i , j )) / ( PGrid % x ( i + 1 , j ) - PGrid % x ( i , j )) end if vy = ( phi ( i + 1 , j + 1 ) - phi ( i + 1 , j - 1 )) / ( PGrid % y ( i + 1 , j + 1 ) - PGrid % y ( i + 1 , j - 1 )) qi ( 1 ) = dabs ( 1.d0 - dsqrt ( vx ** 2.d0 + vy ** 2.d0 )) if ( qi ( - 1 ) < eta . and . qi ( 1 ) >= eta ) then dx =- 1 !     pause 'normal_vector_irre 790' elseif ( qi ( - 1 ) >= eta . and . qi ( 1 ) < eta ) then dx = 1 elseif ( qi ( - 1 ) < eta . and . qi ( 0 ) < eta . and . qi ( 1 ) < eta ) then dx = 0 elseif ( qi ( - 1 ) >= eta . and . qi ( 0 ) >= eta . and . qi ( 1 ) >= eta ) then dx = 0 else vx = ( phi ( i + 1 , j ) - phi ( i - 1 , j )) / ( PGrid % x ( i + 1 , j ) - PGrid % x ( i - 1 , j )) vy = ( phi ( i , j + 1 ) - phi ( i , j - 1 )) / ( PGrid % y ( i , j + 1 ) - PGrid % y ( i , j - 1 )) MaxVect = 0.d0 Imv = 0 !    Find the most parallel vector to  normal vector do ii = 1 , 8 CosPar = dabs ( Vset ( ii , 1 ) * vx + Vset ( ii , 2 ) * vy ) / ( dsqrt ( Vset ( ii , 1 ) ** 2.d0 + & Vset ( ii , 2 ) ** 2.d0 ) * dsqrt ( vx ** 2.d0 + vy ** 2.d0 )) if ( CosPar >= MaxVect ) then MaxVect = CosPar Imv = ii end if end do if ( Imv == 0 ) then print * , i , j print * ,( PGrid % x ( i + 1 , j ) - PGrid % x ( i - 1 , j )) print * ,( PGrid % y ( i , j + 1 ) - PGrid % y ( i , j - 1 )) print * ,( phi ( i + 1 , j ) - phi ( i - 1 , j )) print * ,( phi ( i , j + 1 ) - phi ( i , j - 1 )) print * , 'NormalCalculation_ClsVof_1860' Do ii = 1 , 8 CosPar = dabs ( Vset ( ii , 1 ) * vx + Vset ( ii , 2 ) * vy ) / ( dsqrt ( Vset ( ii , 1 ) ** 2.d0 + & Vset ( ii , 2 ) ** 2.d0 ) * dsqrt ( vx ** 2.d0 + vy ** 2.d0 )) print * , vx , vy print * , if ( CosPar >= MaxVect ) then MaxVect = CosPar Imv = ii end if end do end if V1 ( 1 ) =- Vset ( Imv , 2 ) V1 ( 2 ) = Vset ( Imv , 1 ) V2 ( 1 ) =- V1 ( 1 ) V2 ( 2 ) =- V1 ( 2 ) if ( V1 ( 1 ) ==- 1 ) then vx1 = ( phi ( i , j ) - phi ( i - 1 , j )) / ( PGrid % x ( i , j ) - PGrid % x ( i - 1 , j )) vx2 = ( phi ( i + 1 , j ) - phi ( i , j )) / ( PGrid % x ( i + 1 , j ) - PGrid % x ( i , j )) elseIf ( V1 ( 1 ) == 0 ) then vx1 = ( phi ( i + 1 , j ) - phi ( i - 1 , j )) / ( PGrid % x ( i + 1 , j ) - PGrid % x ( i - 1 , j )) vx2 = ( phi ( i + 1 , j ) - phi ( i - 1 , j )) / ( PGrid % x ( i + 1 , j ) - PGrid % x ( i - 1 , j )) else vx1 = ( phi ( i + 1 , j ) - phi ( i , j )) / ( PGrid % x ( i + 1 , j ) - PGrid % x ( i , j )) vx2 = ( phi ( i , j ) - phi ( i - 1 , j )) / ( PGrid % x ( i , j ) - PGrid % x ( i - 1 , j )) end if if ( V1 ( 2 ) ==- 1 ) then vy1 = ( phi ( i , j ) - phi ( i , j - 1 )) / ( PGrid % y ( i , j ) - PGrid % y ( i , j - 1 )) vy2 = ( phi ( i , j + 1 ) - phi ( i , j )) / ( PGrid % y ( i , j + 1 ) - PGrid % y ( i , j )) elseIf ( V1 ( 2 ) == 0 ) then vy1 = ( phi ( i , j + 1 ) - phi ( i , j - 1 )) / ( PGrid % y ( i , j + 1 ) - PGrid % y ( i , j - 1 )) vy2 = ( phi ( i , j + 1 ) - phi ( i , j - 1 )) / ( PGrid % y ( i , j + 1 ) - PGrid % y ( i , j - 1 )) else vy1 = ( phi ( i , j + 1 ) - phi ( i , j )) / ( PGrid % y ( i , j + 1 ) - PGrid % y ( i , j )) vy2 = ( phi ( i , j ) - phi ( i , j - 1 )) / ( PGrid % y ( i , j ) - PGrid % y ( i , j - 1 )) end if qv1 = dabs ( 1.d0 - dsqrt ( vx1 ** 2.d0 + vy1 ** 2.d0 )) qv2 = dabs ( 1.d0 - dsqrt ( vx2 ** 2.d0 + vy2 ** 2.d0 )) if ( qv1 < qv2 + nuy ) then nx = vx1 ny = vy1 return else nx = vx2 ny = vy2 return end if end if ! define qj for Dy if ( j >= 3 ) then vy = ( phi ( i , j ) - phi ( i , j - 2 )) / ( PGrid % y ( i , j ) - PGrid % y ( i , j - 2 )) else vy = ( phi ( i , j ) - phi ( i , j - 1 )) / ( PGrid % y ( i , j ) - PGrid % y ( i , j - 1 )) end if vx = ( phi ( i + 1 , j - 1 ) - phi ( i - 1 , j - 1 )) / ( PGrid % x ( i + 1 , j - 1 ) - PGrid % x ( i - 1 , j - 1 )) qj ( - 1 ) = dabs ( 1.d0 - dsqrt ( vx ** 2.d0 + vy ** 2.d0 )) ! define qj(0) vx = ( phi ( i + 1 , j ) - phi ( i - 1 , j )) / ( PGrid % x ( i + 1 , j ) - PGrid % x ( i - 1 , j )) vy = ( phi ( i , j + 1 ) - phi ( i , j - 1 )) / ( PGrid % y ( i , j + 1 ) - PGrid % y ( i , j - 1 )) qj ( 0 ) = dabs ( 1.d0 - dsqrt ( vx ** 2.d0 + vy ** 2.d0 )) ! define qj(1) vx = ( phi ( i + 1 , j + 1 ) - phi ( i - 1 , j + 1 )) / ( PGrid % x ( i + 1 , j + 1 ) - PGrid % x ( i - 1 , j + 1 )) if ( j <= JSize - 2 ) then vy = ( phi ( i , j + 2 ) - phi ( i , j )) / ( PGrid % y ( i , j + 2 ) - PGrid % y ( i , j )) else vy = ( phi ( i , j + 1 ) - phi ( i , j )) / ( PGrid % y ( i , j + 1 ) - PGrid % y ( i , j )) end if qj ( 1 ) = dabs ( 1.d0 - dsqrt ( vx ** 2.d0 + vy ** 2.d0 )) if ( qj ( - 1 ) < eta . and . qj ( 1 ) >= eta ) then dy =- 1 elseif ( qj ( - 1 ) >= eta . and . qj ( 1 ) < eta ) then dy = 1 elseif ( qj ( - 1 ) < eta . and . qj ( 0 ) < eta . and . qj ( 1 ) < eta ) then dy = 0 elseif ( qj ( - 1 ) >= eta . and . qj ( 0 ) >= eta . and . qj ( 1 ) >= eta ) then dy = 0 else vx = ( phi ( i + 1 , j ) - phi ( i - 1 , j )) / ( PGrid % x ( i + 1 , j ) - PGrid % x ( i - 1 , j )) vy = ( phi ( i , j + 1 ) - phi ( i , j - 1 )) / ( PGrid % y ( i , j + 1 ) - PGrid % y ( i , j - 1 )) MaxVect = 0.d0 imv = 1 ! Find the most parallel vector to  normal vector do ii = 1 , 8 CosPar = dabs ( Vset ( ii , 1 ) * vx + Vset ( ii , 2 ) * vy ) / ( dsqrt ( Vset ( ii , 1 ) ** 2.d0 + & Vset ( ii , 2 ) ** 2.d0 ) * dsqrt ( vx ** 2.d0 + vy ** 2.d0 )) if ( CosPar >= MaxVect ) then MaxVect = CosPar Imv = ii end if end do V1 ( 1 ) =- Vset ( Imv , 2 ) V1 ( 2 ) = Vset ( Imv , 1 ) V2 ( 1 ) =- V1 ( 1 ) V2 ( 2 ) =- V1 ( 2 ) if ( V1 ( 1 ) ==- 1 ) then vx1 = ( phi ( i , j ) - phi ( i - 1 , j )) / ( PGrid % x ( i , j ) - PGrid % x ( i - 1 , j )) vx2 = ( phi ( i + 1 , j ) - phi ( i , j )) / ( PGrid % x ( i + 1 , j ) - PGrid % x ( i , j )) elseif ( V1 ( 1 ) == 0 ) then vx1 = ( phi ( i + 1 , j ) - phi ( i - 1 , j )) / ( PGrid % x ( i + 1 , j ) - PGrid % x ( i - 1 , j )) vx2 = ( phi ( i + 1 , j ) - phi ( i - 1 , j )) / ( PGrid % x ( i + 1 , j ) - PGrid % x ( i - 1 , j )) else vx1 = ( phi ( i + 1 , j ) - phi ( i , j )) / ( PGrid % x ( i + 1 , j ) - PGrid % x ( i , j )) vx2 = ( phi ( i , j ) - phi ( i - 1 , j )) / ( PGrid % x ( i , j ) - PGrid % x ( i - 1 , j )) end if if ( V1 ( 2 ) ==- 1 ) then vy1 = ( phi ( i , j ) - phi ( i , j - 1 )) / ( PGrid % y ( i , j ) - PGrid % y ( i , j - 1 )) vy2 = ( phi ( i , j + 1 ) - phi ( i , j )) / ( PGrid % y ( i , j + 1 ) - PGrid % y ( i , j )) elseif ( V1 ( 2 ) == 0 ) then vy1 = ( phi ( i , j + 1 ) - phi ( i , j - 1 )) / ( PGrid % y ( i , j + 1 ) - PGrid % y ( i , j - 1 )) vy2 = ( phi ( i , j + 1 ) - phi ( i , j - 1 )) / ( PGrid % y ( i , j + 1 ) - PGrid % y ( i , j - 1 )) else vy1 = ( phi ( i , j + 1 ) - phi ( i , j )) / ( PGrid % y ( i , j + 1 ) - PGrid % y ( i , j )) vy2 = ( phi ( i , j ) - phi ( i , j - 1 )) / ( PGrid % y ( i , j ) - PGrid % y ( i , j - 1 )) end if qv1 = dabs ( 1.d0 - dsqrt ( vx1 ** 2.d0 + vy1 ** 2.d0 )) qv2 = dabs ( 1.d0 - dsqrt ( vx2 ** 2.d0 + vy2 ** 2.d0 )) if ( qv1 < qv2 + nuy ) then nx = vx1 ny = vy1 return else nx = vx2 ny = vy2 return end if end if if ( dx ==- 1 ) nx = ( phi ( i , j ) - phi ( i - 1 , j )) / ( PGrid % x ( i , j ) - PGrid % x ( i - 1 , j )) if ( dx == 1 ) nx = ( phi ( i + 1 , j ) - phi ( i , j )) / ( PGrid % x ( i + 1 , j ) - PGrid % x ( i , j )) if ( dx == 0 ) nx = ( phi ( i + 1 , j ) - phi ( i - 1 , j )) / ( PGrid % x ( i + 1 , j ) - PGrid % x ( i - 1 , j )) if ( dy ==- 1 ) ny = ( phi ( i , j ) - phi ( i , j - 1 )) / ( PGrid % y ( i , j ) - PGrid % y ( i , j - 1 )) if ( dy == 1 ) ny = ( phi ( i , j + 1 ) - phi ( i , j )) / ( PGrid % y ( i , j + 1 ) - PGrid % y ( i , j )) if ( dy == 0 ) ny = ( phi ( i , j + 1 ) - phi ( i , j - 1 )) / ( PGrid % y ( i , j + 1 ) - PGrid % y ( i , j - 1 )) end subroutine Normal_Vector_Irre function isinsiderect ( xp , yp , del_x , del_y ) result ( logic ) IMPLICIT NONE REAL ( KIND = dp ), INTENT ( IN ) :: xp , yp , del_x , del_y real ( dp ) :: x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 real ( dp ) :: b1 , b2 , b3 , b4 , u1 , u2 , u3 , u4 , area , areasum real ( dp ) :: area1 , area2 , area3 , area4 logical :: logic x1 = - 0.5 * del_x y1 = 0.5 * del_y x2 = 0.5 * del_x y2 = 0.5 * del_y x3 = 0.5 * del_x y3 = - 0.5 * del_y x4 = - 0.5 * del_x y4 = - 0.5 * del_y b1 = dsqrt (( x1 - xp ) ** 2.d0 + ( y1 - yp ) ** 2.d0 ) b2 = dsqrt (( x2 - xp ) ** 2.d0 + ( y2 - yp ) ** 2.d0 ) b3 = dsqrt (( x3 - xp ) ** 2.d0 + ( y3 - yp ) ** 2.d0 ) b4 = dsqrt (( x4 - xp ) ** 2.d0 + ( y4 - yp ) ** 2.d0 ) u1 = 0.5d0 * ( del_x + b1 + b2 ) u2 = 0.5d0 * ( del_y + b2 + b3 ) u3 = 0.5d0 * ( del_x + b3 + b4 ) u4 = 0.5d0 * ( del_y + b4 + b1 ) area = del_x * del_y area1 = dsqrt ( u1 * ( u1 - del_x ) * ( u1 - b1 ) * ( u1 - b2 )) area2 = dsqrt ( u2 * ( u2 - del_y ) * ( u2 - b2 ) * ( u2 - b3 )) area3 = dsqrt ( u3 * ( u3 - del_x ) * ( u3 - b3 ) * ( u3 - b4 )) area4 = dsqrt ( u4 * ( u4 - del_y ) * ( u4 - b4 ) * ( u4 - b1 )) areasum = area1 + area2 + area3 + area4 if ( dabs ( areasum - area ) < 1.d-10 ) then logic = . true . else logic = . false . end if end function subroutine DistanceFluidCalculate ( nxss , nyss , phiss , nxf , nyf , volf , dx , dy , phif ) IMPLICIT NONE REAL ( KIND = dp ), INTENT ( IN ) :: nxss , nyss , phiss , nxf , nyf , dx , dy , volf REAL ( KIND = dp ), INTENT ( INOUT ) :: phif REAL ( KIND = dp ), DIMENSION (:,:) :: node ( 6 , 2 ) INTEGER * 4 :: temp , k REAL ( KIND = dp ) :: dx2 , dy2 , dpt ( 4 ), epsil , dt23 REAL ( KIND = dp ) :: MinVer ( 2 ), MaxVer ( 2 ), Mindis , Maxdis epsil = 1.d-10 dx2 = dx / 2.d0 dy2 = dy / 2.d0 temp = 1 node = 0.d0 dpt ( 1 ) = dx2 * nxss - dy2 * nyss + phiss dpt ( 2 ) =- dx2 * nxss - dy2 * nyss + phiss dpt ( 3 ) =- dx2 * nxss + dy2 * nyss + phiss dpt ( 4 ) = dx2 * nxss + dy2 * nyss + phiss if ( dpt ( 1 ) >= 0.d0 ) then node ( temp , 1 ) = dx2 node ( temp , 2 ) =- dy2 temp = temp + 1 end if if ( dpt ( 1 ) * dpt ( 2 ) < 0.d0 ) then node ( temp , 1 ) = ( dy2 * nyss - phiss ) / nxss node ( temp , 2 ) =- dy2 temp = temp + 1 end if if ( dpt ( 2 ) >= 0.d0 ) then node ( temp , 1 ) =- dx2 node ( temp , 2 ) =- dy2 temp = temp + 1 end if if ( dpt ( 2 ) * dpt ( 3 ) < 0.d0 ) then node ( temp , 1 ) =- dx2 node ( temp , 2 ) = ( dx2 * nxss - phiss ) / nyss temp = temp + 1 end if if ( dpt ( 3 ) >= 0.d0 ) then node ( temp , 1 ) =- dx2 node ( temp , 2 ) = dy2 temp = temp + 1 end if if ( dpt ( 3 ) * dpt ( 4 ) < 0.d0 ) then node ( temp , 1 ) = ( - dy2 * nyss - phiss ) / nxss node ( temp , 2 ) = dy2 temp = temp + 1 end if if ( dpt ( 4 ) >= 0.d0 ) then node ( temp , 1 ) = dx2 node ( temp , 2 ) = dy2 temp = temp + 1 end if if ( dpt ( 4 ) * dpt ( 1 ) < 0.d0 ) then node ( temp , 1 ) = dx2 node ( temp , 2 ) = ( - dx2 * nxss - phiss ) / nyss temp = temp + 1 end if node ( temp , 1 ) = node ( 1 , 1 ) node ( temp , 2 ) = node ( 1 , 2 ) Maxdis =- 2.d0 * dsqrt ( dx ** 2.d0 + dy ** 2.d0 ) Mindis = 2.d0 * dsqrt ( dx ** 2.d0 + dy ** 2.d0 ) do k = 1 , temp - 1 dt23 = nxf * node ( k , 1 ) + nyf * node ( k , 2 ) if ( dt23 > Maxdis ) then Maxdis = dt23 MaxVer ( 1 ) = node ( k , 1 ) MaxVer ( 2 ) = node ( k , 2 ) end if if ( dt23 < Mindis ) then Mindis = dt23 MinVer ( 1 ) = node ( k , 1 ) MinVer ( 2 ) = node ( k , 2 ) end if end do MaxVer ( 1 ) = MaxVer ( 1 ) + MaxVer ( 1 ) * nxf * epsi MaxVer ( 2 ) = MaxVer ( 2 ) + MaxVer ( 2 ) * nyf * epsi MinVer ( 1 ) = MinVer ( 1 ) - MinVer ( 1 ) * nxf * epsi MinVer ( 2 ) = MinVer ( 2 ) - MinVer ( 2 ) * nyf * epsi if ( temp == 1. or . dabs ( Node ( 1 , 1 )) < 1.d-14 . and . dabs ( Node ( 1 , 2 )) < 1.d-14 ) then print * , 'problem 1266' print * , temp print * , nxss , nyss , phiss pause 'fuck you bugs' end if call zriddr ( nxf , nyf , volf , dx , dy , phif , node , MinVer , MaxVer , 1.d-14 , 1000 ) end subroutine DistanceFluidCalculate subroutine zriddr ( nxf , nyf , volf , dx , dy , phif , node , x1 , x2 , tol , ITMAX ) REAL ( KIND = dp ), INTENT ( IN ) :: nxf , nyf , volf , dx , dy , node ( 6 , 2 ), x1 ( 2 ), x2 ( 2 ), tol REAL ( KIND = dp ), INTENT ( INOUT ) :: phif INTEGER ( kind = it4b ), INTENT ( IN ) :: ITMAX INTEGER * 4 :: iter REAL ( KIND = dp ) :: ans ( 2 ), fh , fl , fm , fnew , s , xh ( 2 ), xl ( 2 ), xm ( 2 ), xnew ( 2 ), UNUSED UNUSED =- 1.11d-30 call LiqFuncVol ( nxf , nyf , volf , dx , dy , node , x1 , fl ) call LiqFuncVol ( nxf , nyf , volf , dx , dy , node , x2 , fh ) if (( fl > tol . and . fh <- tol ). or .( fl <- tol . and . fh > tol )) then xl (:) = x1 (:) xh (:) = x2 (:) ans (:) = UNUSED do iter = 1 , ITMAX xm (:) = 0.5d0 * ( xl (:) + xh (:)) ! first of two function evaluation per iteration call LiqFuncVol ( nxf , nyf , volf , dx , dy , node , xm , fm ) s = dsqrt ( fm * fm - fl * fh ) if ( s == 0.d0 ) pause 'fuck you zriddr method' xnew (:) = xm (:) + ( xm (:) - xl (:)) * dsign ( 1.d0 , fl - fh ) * fm / s if ( dsqrt (( xnew ( 1 ) - ans ( 1 )) ** 2.d0 + ( xnew ( 2 ) - ans ( 2 )) ** 2.d0 ) <= tol ) then phif =- ( nxf * ans ( 1 ) + nyf * ans ( 2 )) return end if ans (:) = xnew (:) call LiqFuncVol ( nxf , nyf , volf , dx , dy , node , xnew , fnew ) if ( dabs ( fnew ) <= tol ) then phif =- ( nxf * ans ( 1 ) + nyf * ans ( 2 )) return endif if ( dsign ( fm , fnew ) /= fm ) then xl (:) = xm (:) fl = fm xh (:) = ans (:) fh = fnew elseif ( dsign ( fl , fnew ) /= fl ) then xh (:) = ans (:) fh = fnew elseif ( dsign ( fh , fnew ) /= fh ) then xl = ans (:) fl = fnew end if if ( dsqrt (( xh ( 1 ) - xl ( 1 )) ** 2.d0 + ( xh ( 2 ) - xl ( 2 )) ** 2.d0 ) <= tol ) then phif =- ( nxf * ans ( 1 ) + nyf * ans ( 2 )) return end if end do phif =- ( nxf * ans ( 1 ) + nyf * ans ( 2 )) return else if ( fl < tol . and . fl >- tol ) then phif =- ( nxf * x1 ( 1 ) + nyf * x1 ( 2 )) return end if if ( fh < tol . and . fh >- tol ) then phif =- ( nxf * x2 ( 1 ) + nyf * x2 ( 2 )) return end if end if end subroutine zriddr subroutine LiqFuncVol ( nxf , nyf , volf , dx , dy , node , xf , fvol ) REAL ( KIND = dp ), INTENT ( IN ) :: nxf , nyf , volf , dx , dy , node ( 6 , 2 ), xf ( 2 ) REAL ( KIND = dp ) :: fvol , phil , nodel ( 7 , 2 ), pdt ( 6 ), vol INTEGER :: k , temp , templ phil =- ( nxf * xf ( 1 ) + nyf * xf ( 2 )) temp = 0 do k = 1 , 6 if ( dabs ( node ( k , 1 )) > 1.d-14 . or . dabs ( node ( k , 2 )) > 1.d-14 ) then temp = k end if end do do k = 1 , temp - 1 if ( k > 6 ) then print * , temp pause 'bugs Clsvof_Mod 1468' end if pdt ( k ) = node ( k , 1 ) * nxf + node ( k , 2 ) * nyf + phil end do if ( temp == 0 ) then print * , node ( 1 , 1 ), node ( 1 , 2 ) print * , nxf , nyf , volf pause 'bugs Clsvof_Mod 1475' end if pdt ( temp ) = pdt ( 1 ) !   find the volume of liquid inside cell templ = 1 do k = 1 , temp - 1 if ( pdt ( k ) <= 0.d0 ) then nodel ( templ , 1 ) = node ( k , 1 ) nodel ( templ , 2 ) = node ( k , 2 ) templ = templ + 1 end if if ( pdt ( k ) * pdt ( k + 1 ) < 0.d0 ) then nodel ( templ , 1 ) = node ( k , 1 ) + ( node ( k + 1 , 1 ) - node ( k , 1 )) * dabs ( pdt ( k )) / & ( dabs ( pdt ( k )) + dabs ( pdt ( k + 1 ))) nodel ( templ , 2 ) = node ( k , 2 ) + ( node ( k + 1 , 2 ) - node ( k , 2 )) * dabs ( pdt ( k )) / & ( dabs ( pdt ( k )) + dabs ( pdt ( k + 1 ))) templ = templ + 1 end if end do nodel ( templ , 1 ) = nodel ( 1 , 1 ) nodel ( templ , 2 ) = nodel ( 1 , 2 ) vol = 0.d0 do k = 1 , templ - 1 vol = vol + 0.5d0 * ( nodel ( k , 1 ) * nodel ( k + 1 , 2 ) - nodel ( k + 1 , 1 ) * nodel ( k , 2 )) end do fvol = volf - dabs ( vol / ( dx * dy )) end subroutine LiqFuncVol ! This subroutine is used to calculate the volume fraction of liquid and solid in given cell ! This subroutine uses the Green theorem to calculate the volume of solid and liquid subroutine CellGeoCal ( nxs , nys , phis , nxl , nyl , phil , dx , dy , vols , volf ) IMPLICIT NONE REAL ( KIND = dp ), INTENT ( IN ) :: nxs , nys , phis , nxl , nyl , phil , dx , dy REAL ( KIND = dp ), INTENT ( OUT ) :: vols , volf REAL ( KIND = dp ), DIMENSION (:,:) :: node ( 6 , 2 ), nodel ( 7 , 2 ) INTEGER ( kind = it4b ) :: temp , templ , k REAL ( KIND = dp ) :: dx2 , dy2 , pdt ( 6 ), dpt ( 4 ), vol , epsil epsil = 1.d-24 dx2 = dx / 2.d0 dy2 = dy / 2.d0 temp = 1 node = 0.d0 !  calculate the distance of all cell's nodes to interface dpt ( 1 ) = dx2 * nxs - dy2 * nys + phis dpt ( 2 ) = - dx2 * nxs - dy2 * nys + phis dpt ( 3 ) = - dx2 * nxs + dy2 * nys + phis dpt ( 4 ) = dx2 * nxs + dy2 * nys + phis !  find nodes those belong to fluid field(including the cutting nodes between !  interface and cell edges) If ( dpt ( 1 ) >= 0.d0 ) then node ( temp , 1 ) = dx2 node ( temp , 2 ) = - dy2 temp = temp + 1 End if If ( dpt ( 1 ) * dpt ( 2 ) < 0.d0 ) then node ( temp , 1 ) = ( dy2 * nys - phis ) / nxs node ( temp , 2 ) = - dy2 temp = temp + 1 End if If ( dpt ( 2 ) >= 0.d0 ) then node ( temp , 1 ) = - dx2 node ( temp , 2 ) = - dy2 temp = temp + 1 End if If ( dpt ( 2 ) * dpt ( 3 ) < 0.d0 ) then node ( temp , 1 ) = - dx2 node ( temp , 2 ) = ( dx2 * nxs - phis ) / nys temp = temp + 1 End if If ( dpt ( 3 ) >= 0.d0 ) then node ( temp , 1 ) = - dx2 node ( temp , 2 ) = dy2 temp = temp + 1 End if If ( dpt ( 3 ) * dpt ( 4 ) < 0.d0 ) then node ( temp , 1 ) = ( - dy2 * nys - phis ) / nxs node ( temp , 2 ) = dy2 temp = temp + 1 End if If ( dpt ( 4 ) >= 0.d0 ) then node ( temp , 1 ) = dx2 node ( temp , 2 ) = dy2 temp = temp + 1 End if If ( dpt ( 4 ) * dpt ( 1 ) < 0.d0 ) then node ( temp , 1 ) = dx2 node ( temp , 2 ) = ( - dx2 * nxs - phis ) / nys temp = temp + 1 End if node ( temp , 1 ) = node ( 1 , 1 ) node ( temp , 2 ) = node ( 1 , 2 ) vol = 0.d0 ! applying Gauss theorem to find the volume of both fluid and gas do k = 1 , temp - 1 vol = vol + 0.5d0 * ( node ( k , 1 ) * node ( k + 1 , 2 ) - node ( k + 1 , 1 ) * node ( k , 2 )) pdt ( k ) = node ( k , 1 ) * nxl + node ( k , 2 ) * nyl + phil end do ! Volume fraction of solid in given cell vols = 1.d0 - dabs ( vol / ( dx * dy )) pdt ( temp ) = pdt ( 1 ) ! find the volume of liquid inside cell templ = 1 do k = 1 , temp - 1 if ( pdt ( k ) <= 0.d0 ) then nodel ( templ , 1 ) = node ( k , 1 ) nodel ( templ , 2 ) = node ( k , 2 ) templ = templ + 1 end if if ( pdt ( k ) * pdt ( k + 1 ) < 0.d0 ) then nodel ( templ , 1 ) = node ( k , 1 ) + ( node ( k + 1 , 1 ) - node ( k , 1 )) * dabs ( pdt ( k )) / & ( dabs ( pdt ( k )) + dabs ( pdt ( k + 1 ))) nodel ( templ , 2 ) = node ( k , 2 ) + ( node ( k + 1 , 2 ) - node ( k , 2 )) * dabs ( pdt ( k )) / & ( dabs ( pdt ( k )) + dabs ( pdt ( k + 1 ))) templ = templ + 1 end if end do nodel ( templ , 1 ) = nodel ( 1 , 1 ) nodel ( templ , 2 ) = nodel ( 1 , 2 ) vol = 0.d0 do k = 1 , templ - 1 vol = vol + 0.5d0 * ( nodel ( k , 1 ) * nodel ( k + 1 , 2 ) - nodel ( k + 1 , 1 ) * nodel ( k , 2 )) end do volf = dabs ( vol / ( dx * dy )) end subroutine CellGeoCal SUBROUTINE Boundary_Condition_Vof_Phi ( TGrid , Time ) !! The subroutine computes the volume fraction and the level set at !! the inlet and outlet boundary. The subroutine will be applied for !! the sinusoidal wave. IMPLICIT NONE TYPE ( Grid ), INTENT ( IN ) :: TGrid REAL ( KIND = dp ), INTENT ( IN ) :: Time REAL ( KIND = dp ), DIMENSION (:,:) :: node ( 6 , 2 ), CutP ( 2 , 2 ), dpt ( 4 ) REAL ( KIND = dp ) :: fx , dfx , nxx , nyy , dis , nxy , dx2 , dy2 , tol , vol , vos INTEGER ( kind = it4b ) :: j , k , temp , templ do j = 1 , Jsize temp = 1 templ = 1 dx2 = TGrid % dx ( 1 , j ) / 2.d0 dy2 = TGrid % dy ( 1 , j ) / 2.d0 dpt ( 1 ) = TGrid % y ( 1 , j ) - dy2 - Depthw - Amp0 * dsin ( kw * ( TGrid % x ( 1 , j ) + dx2 - cw0 * Time )) dpt ( 2 ) = TGrid % y ( 1 , j ) - dy2 - Depthw - Amp0 * dsin ( kw * ( TGrid % x ( 1 , j ) - dx2 - cw0 * Time )) dpt ( 3 ) = TGrid % y ( 1 , j ) + dy2 - Depthw - Amp0 * dsin ( kw * ( TGrid % x ( 1 , j ) - dx2 - cw0 * Time )) dpt ( 4 ) = TGrid % y ( 1 , j ) + dy2 - Depthw - Amp0 * dsin ( kw * ( TGrid % x ( 1 , j ) + dx2 - cw0 * Time )) if ( dpt ( 1 ) >= 0.d0 ) then node ( temp , 1 ) = dx2 node ( temp , 2 ) =- dy2 temp = temp + 1 end if if ( dpt ( 1 ) * dpt ( 2 ) < 0.d0 ) then node ( temp , 1 ) = TGrid % x ( 1 , j ) - dx2 + TGrid % dx ( 1 , j ) * dabs ( dpt ( 2 )) / & ( dabs ( dpt ( 2 )) + dabs ( dpt ( 1 ))) tol = 1.d0 do while ( tol > 1.d-13 ) fx = TGrid % y ( 1 , j ) - dy2 - ( Depthw + Amp0 * dsin ( kw * ( node ( temp , 1 ) - cw0 * Time ))) dfx =- Amp0 * kw * dcos ( kw * ( node ( temp , 1 ) - cw0 * Time )) tol = dabs ( fx / dfx ) node ( temp , 1 ) = node ( temp , 1 ) - fx / dfx end do node ( temp , 1 ) = node ( temp , 1 ) - TGrid % x ( 1 , j ) node ( temp , 2 ) =- dy2 CutP ( templ , 1 ) = node ( temp , 1 ) CutP ( templ , 2 ) = node ( temp , 2 ) templ = templ + 1 temp = temp + 1 end if if ( dpt ( 2 ) >= 0.d0 ) then node ( temp , 1 ) =- dx2 node ( temp , 2 ) =- dy2 temp = temp + 1 end if if ( dpt ( 2 ) * dpt ( 3 ) < 0.d0 ) then node ( temp , 1 ) =- dx2 node ( temp , 2 ) = Depthw + Amp0 * dsin ( kw * ( node ( temp , 1 ) + TGrid % x ( 1 , j ) - cw0 * Time )) - & TGrid % y ( 1 , j ) CutP ( templ , 1 ) = node ( temp , 1 ) CutP ( templ , 2 ) = node ( temp , 2 ) templ = templ + 1 temp = temp + 1 end if if ( dpt ( 3 ) >= 0.d0 ) then node ( temp , 1 ) =- dx2 node ( temp , 2 ) = dy2 temp = temp + 1 end if if ( dpt ( 3 ) * dpt ( 4 ) < 0.d0 ) then node ( temp , 1 ) = TGrid % x ( 1 , j ) - dx2 + TGrid % dx ( 1 , j ) * dabs ( dpt ( 3 )) / & ( dabs ( dpt ( 3 )) + dabs ( dpt ( 4 ))) tol = 1.d0 do while ( tol > 1.d-13 ) fx = TGrid % y ( 1 , j ) + dy2 - ( Depthw + Amp0 * dsin ( kw * ( node ( temp , 1 ) - cw0 * Time ))) dfx =- Amp0 * kw * dcos ( kw * ( node ( temp , 1 ) - cw0 * Time )) tol = dabs ( fx / dfx ) node ( temp , 1 ) = node ( temp , 1 ) - fx / dfx end do node ( temp , 1 ) = node ( temp , 1 ) - TGrid % x ( 1 , j ) node ( temp , 2 ) = dy2 CutP ( templ , 1 ) = node ( temp , 1 ) CutP ( templ , 2 ) = node ( temp , 2 ) templ = templ + 1 temp = temp + 1 end if if ( dpt ( 4 ) >= 0.d0 ) then node ( temp , 1 ) = dx2 node ( temp , 2 ) = dy2 temp = temp + 1 end if if ( dpt ( 4 ) * dpt ( 1 ) < 0.d0 ) then node ( temp , 1 ) = dx2 node ( temp , 2 ) = Depthw + Amp0 * dsin ( kw * ( node ( temp , 1 ) + TGrid % x ( 1 , j ) - & cw0 * Time )) - TGrid % y ( 1 , j ) CutP ( templ , 1 ) = node ( temp , 1 ) CutP ( templ , 2 ) = node ( temp , 2 ) templ = templ + 1 temp = temp + 1 end if node ( temp , 1 ) = node ( 1 , 1 ) node ( temp , 2 ) = node ( 1 , 2 ) vol = 0.d0 do k = 1 , temp - 1 vol = vol + 0.5d0 * ( node ( k , 1 ) * node ( k + 1 , 2 ) - node ( k + 1 , 1 ) * node ( k , 2 )) end do vol = 1.d0 - dabs ( vol / ( TGrid % dx ( 1 , j ) * TGrid % dy ( 1 , j ))) if ( templ == 3 ) then nxx = CutP ( 2 , 2 ) - CutP ( 1 , 2 ) nyy = CutP ( 2 , 1 ) - CutP ( 1 , 1 ) vos =- Amp0 * cw0 * kw * dcos ( kw * ( TGrid % x ( 1 , j ) + TGrid % dx ( 1 , j ) - cw0 * Time )) nxy = dsqrt ( nxx ** 2.d0 + nyy ** 2.d0 ) if ( vos > 0.d0 ) then nxx =- nxx / nxy else nxx = nxx / nxy end if nyy = dabs ( nyy / nxy ) dis = dabs ( CutP ( 2 , 1 ) * CutP ( 1 , 2 ) - CutP ( 1 , 1 ) * CutP ( 2 , 2 )) / nxy * & dsign ( 1.d0 , 0.5d0 - vol ) else dis = TGrid % y ( 1 , j ) - ( Depthw + Amp0 * dsin ( kw * ( TGrid % x ( 1 , j ) - cw0 * Time ))) nxx = 0.d0 nyy = 1.d0 end if if ( vol > vofeps . and . vol <- 1.d0 - vofeps ) then print * , j print * , vol print * , dis print * , nxx , nyy print * , end if vfl ( 1 , j ) = vol phi ( 1 , j ) = dis nx ( 1 , j ) = nxx ny ( 1 , j ) = nyy end do END SUBROUTINE Boundary_Condition_Vof_Phi SUBROUTINE ObjectMovement ( BoomCase , dtv ) !! The subroutine compute the Boom position and its velocity IMPLICIT NONE TYPE ( SolidObject ), INTENT ( INOUT ) :: BoomCase REAL ( KIND = dp ), INTENT ( IN ) :: dtv BoomCase % Posp % y = BoomCase % Posp % y + 0.5d0 * BoomCase % asy * dtv ** 2.d0 + & BoomCase % vs * dtv BoomCase % Posp % x = BoomCase % Posp % x + 0.5d0 * BoomCase % asx * dtv ** 2.d0 + & BoomCase % us * dtv BoomCase % us = BoomCase % us + BoomCase % asx * dtv BoomCase % vs = BoomCase % vs + BoomCase % asy * dtv BoomCase % XBar1 = BoomCase % Posp % x - BoomCase % Wobj / 2.d0 BoomCase % XBar2 = BoomCase % Posp % x + BoomCase % Wobj / 2.d0 BoomCase % YBar = BoomCase % Posp % y - dsqrt (( BoomCase % Dobj / 2.d0 ) ** 2.d0 - & ( BoomCase % Wobj / 2.d0 ) ** 2.d0 ) - BoomCase % LBar END SUBROUTINE ObjectMovement SUBROUTINE ComputeForceObject ( BoomCase , PGrid , PCell , VCell , TVar , ForceObj ) !! The subroutine calculates the force acting on object IMPLICIT NONE TYPE ( SolidObject ), INTENT ( INOUT ) :: BoomCase TYPE ( Grid ), INTENT ( IN ) :: PGrid TYPE ( Cell ), INTENT ( IN ) :: PCell , VCell TYPE ( Variables ), INTENT ( IN ) :: TVar REAL ( KIND = dp ), INTENT ( OUT ) :: ForceObj REAL ( KIND = dp ) :: Clp , Clf , eta , Area , Pr , Pres , Strf , nyfp , & testArea , Maxforce , MaxP , MaxA , Maxny , & Areatemp , SForce INTEGER ( KIND = it4b ) :: i , j , ii , jj , temp Pr = 0.d0 Clp = 0.d0 Area = 0.d0 TestArea = 0.d0 Maxforce = 0.d0 ! Calculate the Cdp ! For upper half of cylinder do i = ibeg , ibeg + Isize - 1 do j = jbeg , jbeg + Jsize - 1 if ( PCell % vofS ( i , j ) < 1.d0 - epsi . and . PCell % vofS ( i , j ) > epsi ) then SForce = 0.d0 temp = 0 Areatemp = 0.d0 if ( PCell % vofS ( i - 1 , j ) > epsi . and . PCell % vofS ( i - 1 , j ) < 1.d0 - epsi ) then eta = dabs ( PCell % phiS ( i - 1 , j ) / ( PCell % phiS ( i , j ) + TolDeno )) Pres = ( TVar % p ( i - 1 , j ) + TVar % p ( i , j ) * eta ) / ( eta + 1.d0 ) Area = PCell % WlLh ( i , j ) nyfp = PCell % nyS ( i , j ) !0.5d0*(PCell%nyS(i,j)+PCell%nyS(i-1,j)) SForce = SForce + Pres * Area * nyfp Areatemp = Areatemp + Area temp = temp + 1 end if if ( PCell % vofS ( i + 1 , j ) > epsi . and . PCell % vofS ( i + 1 , j ) < 1.d0 - epsi ) then eta = dabs ( PCell % phiS ( i + 1 , j ) / ( PCell % phiS ( i , j ) + TolDeno )) Pres = ( TVar % p ( i + 1 , j ) + TVar % p ( i , j ) * eta ) / ( eta + 1.d0 ) Area = PCell % WlLh ( i , j ) nyfp = PCell % nyS ( i , j ) !0.5d0*(PCell%nyS(i,j)+PCell%nyS(i+1,j)) SForce = SForce + Pres * Area * nyfp Areatemp = Areatemp + Area temp = temp + 1 end if if ( PCell % vofS ( i , j - 1 ) > epsi . and . PCell % vofS ( i , j - 1 ) < 1.d0 - epsi ) then eta = dabs ( PCell % phiS ( i , j - 1 ) / ( PCell % phiS ( i , j ) + TolDeno )) Pres = ( TVar % p ( i , j - 1 ) + TVar % p ( i , j ) * eta ) / ( eta + 1.d0 ) Area = PCell % WlLh ( i , j ) nyfp = PCell % nyS ( i , j ) !0.5d0*(PCell%nyS(i,j)+PCell%nyS(i,j-1)) SForce = SForce + Pres * Area * nyfp Areatemp = Areatemp + Area temp = temp + 1 end if if ( PCell % vofS ( i , j + 1 ) > epsi . and . PCell % vofS ( i , j + 1 ) < 1.d0 - epsi ) then eta = dabs ( PCell % phiS ( i , j + 1 ) / ( PCell % phiS ( i , j ) + TolDeno )) Pres = ( TVar % p ( i , j + 1 ) + TVar % p ( i , j ) * eta ) / ( eta + 1.d0 ) Area = PCell % WlLh ( i , j ) nyfp = PCell % nyS ( i , j ) !0.5d0*(PCell%nyS(i,j)+PCell%nyS(i,j+1)) SForce = SForce + Pres * Area * nyfp Areatemp = Areatemp + Area temp = temp + 1 end if SForce = TVar % p ( i , j ) * PCell % WlLh ( i , j ) * PCell % nyS ( i , j ) Areatemp = PCell % WlLh ( i , j ) Clp = Clp + SForce testArea = testArea + Areatemp end if end do end do ! Some problems with bottom cells do i = 1 , Isize do j = 1 , Jsize - 1 if ( PCell % vofS ( i , j ) < 1.d0 - epsi . and . PCell % EEdge_ARea ( i , j ) < epsiF . and . & PCell % WEDge_Area ( i , j ) < epsiF ) then if ( PCell % vofS ( i , j + 1 ) < 1.d0 + epsi . and . PCell % vofS ( i , j + 1 ) > 1.d0 - epsi ) then Pres = TVar % p ( i , j - 1 ) Area = PGrid % dx ( i , j ) !PCell%WlLh(i,j) TestArea = TestArea + Area nyfp =- 1.d0 !PCell%nyS(i,j) Clp = Clp + Pres * Area * nyfp - TVar % p ( i , j ) * Area * nyfp end if end if if ( PCell % VofS ( i , j ) >- epsi . and . PCell % vofS ( i , j ) < epsi ) then if ( PCell % vofS ( i , j + 1 ) < 1.d0 + epsi . and . PCell % vofS ( i , j + 1 ) > 1.d0 - epsi ) then Pres = TVar % p ( i , j ) Area = PGrid % dx ( i , j ) !PCell%WlLh(i,j) TestArea = TestArea + Area nyfp =- 1.d0 !PCell%nyS(i,j) Clp = Clp + Pres * Area * nyfp end if ! 0.6d0 is the volume of solid inside a cell containing boom bar if ( ICorProb . eqv .. TRUE .) then if ( PCell % vofS ( i , j + 1 ) > 0.6d0 - epsi . and . PCell % vofS ( i , j + 1 ) < 0.6d0 + & epsi . and . j < Jsize - 1 ) then if ( PCell % vofS ( i , j + 2 ) > 0.6d0 - epsi . and . PCell % vofS ( i , j + 2 ) < 0.6d0 + & epsi ) then print * , 'This is for compute force' print * , 'There is problem with corner of boom bar' Pres = TVar % p ( i , j ) Area = 0.6d0 * PGrid % dx ( i , j ) !PCell%WlLh(i,j) TestArea = TestArea + Area nyfp =- 1.d0 !PCell%nyS(i,j) Clp = Clp + Pres * Area * nyfp end if end if end if end if end do end do !  print*,'clp 2:',clp,TestArea ! Wall shear stress to calculate the clf ! Upper half of cylinder clf = 0.d0 do i = ibeg , ibeg + Isize - 1 do j = jbeg , jbeg + Jsize - 1 if ( VCell % VofS ( i , j ) > epsi . and . VCell % VofS ( i , j ) < 1.d0 - epsi . and . & VCell % MoExCell ( i , j ) /= 1 ) then Strf = ( TVar % v ( i , j ) - BoomCase % vs ) / Rey / VCell % delh ( i , j ) Area = PCell % WlLh ( i , j ) Clf = Clf + Strf * area end if end do end do ForceObj = clf - clp END SUBROUTINE ComputeForceObject SUBROUTINE SolidVolumeFraction ( TGrid , TCell , BoomCase ) !! The subroutine computes solid volume fraction in the next sub-steps IMPLICIT NONE TYPE ( Grid ), INTENT ( IN ) :: TGrid TYPE ( Cell ), INTENT ( INOUT ) :: TCell TYPE ( SolidObject ), INTENT ( IN ) :: BoomCase TYPE ( Point ) :: Pt ( 0 : 1 , 0 : 1 ) TYPE ( Point ), DIMENSION ( 4 ) :: CutP INTEGER ( kind = it4b ) :: i , j , ii , jj , ctr REAL ( KIND = dp ) :: x1 , y1 , dx , dy , dis , vol REAL ( KIND = dp ) :: tol , dpt ( 4 ) REAL ( KIND = dp ), DIMENSION (:,:), ALLOCATABLE :: nxx , nyy , VofsOld REAL ( KIND = dp ) :: dx1 , dy1 , dx2 , dy2 , epsil , dr1 , dr2 ,& nxx1 , nyy1 , nxy , CylBar allocate ( nxx ( Isize , Jsize )) allocate ( nyy ( Isize , Jsize )) allocate ( VofsOld ( Isize , Jsize )) ! for wave only epsil = 1.d-24 CylBar = dsqrt (( BoomCase % Dobj / 2.d0 ) ** 2.d0 - ( BoomCase % Wobj / 2.d0 ) ** 2.d0 ) VofsOld (:,:) = TCell % vofS (:,:) do i = 1 , Isize do j = 1 , Jsize if ( isnan ( TCell % vof ( i , j ))) then pause 'ClsVof_2668' end if !     For boom cylinder do ii = 0 , 1 do jj = 0 , 1 Pt ( ii , jj )% x = - TGrid % dx ( i , j ) * ( 0.5d0 - dble ( ii )) + TGrid % x ( i , j ) Pt ( ii , jj )% y = - TGrid % dy ( i , j ) * ( 0.5d0 - dble ( jj )) + TGrid % y ( i , j ) end do end do ctr = 1 CutP (:)% x = 0.d0 CutP (:)% y = 0.d0 call EdgeGeoCalCyl ( BoomCase , Pt ( 0 , 0 ), Pt ( 0 , 1 ), CutP , ctr ) call EdgeGeoCalCyl ( BoomCase , Pt ( 0 , 1 ), Pt ( 1 , 1 ), CutP , ctr ) call EdgeGeoCalCyl ( BoomCase , Pt ( 1 , 1 ), Pt ( 1 , 0 ), CutP , ctr ) call EdgeGeoCalCyl ( BoomCase , Pt ( 1 , 0 ), Pt ( 0 , 0 ), CutP , ctr ) if ( ctr == 3 ) then dx = dabs ( CutP ( 1 )% x - CutP ( 2 )% x ) dy = dabs ( CutP ( 1 )% y - CutP ( 2 )% y ) nxx ( i , j ) = dsign ( 1.d0 , TGrid % x ( i , j ) - BoomCase % Posp % x ) * dy / & dsqrt ( dx ** 2.d0 + dy ** 2.d0 ) nyy ( i , j ) = dsign ( 1.d0 , TGrid % y ( i , j ) - BoomCase % Posp % y ) * dx / & dsqrt ( dx ** 2.d0 + dy ** 2.d0 ) dx1 = CutP ( 1 )% x - TGrid % x ( i , j ) dy1 = CutP ( 1 )% y - TGrid % y ( i , j ) dx2 = CutP ( 2 )% x - TGrid % x ( i , j ) dy2 = CutP ( 2 )% y - TGrid % y ( i , j ) dis = dabs ( dx1 * dy2 - dx2 * dy1 ) / dsqrt ( dx ** 2.d0 + dy ** 2.d0 ) x1 = 0.5d0 * ( CutP ( 1 )% x + CutP ( 2 )% x ) y1 = 0.5d0 * ( CutP ( 1 )% y + CutP ( 2 )% y ) dr1 = dsqrt (( x1 - BoomCase % Posp % x ) ** 2.d0 + ( y1 - BoomCase % Posp % y ) ** 2.d0 ) dr2 = dsqrt (( TGrid % x ( i , j ) - BoomCase % Posp % x ) ** 2.d0 + & ( TGrid % y ( i , j ) - BoomCase % Posp % y ) ** 2.d0 ) if ( dr2 < dr1 ) dis = - dis else dx = TGrid % x ( i , j ) - BoomCase % Posp % x dy = TGrid % y ( i , j ) - BoomCase % Posp % y + epsil dis = ( dsqrt ( dx ** 2.d0 + dy ** 2.d0 ) - BoomCase % Dobj / 2.d0 ) nxx ( i , j ) = dx / dsqrt ( dx ** 2.d0 + dy ** 2.d0 ) nyy ( i , j ) = dy / dsqrt ( dx ** 2.d0 + dy ** 2.d0 ) dis = dsign ( 1.d0 , dis ) * dmax1 ( dabs ( dis ), dabs ( nxx ( i , j )) * TGrid % dx ( i , j ) / & 2.d0 + dabs ( nyy ( i , j )) * TGrid % dy ( i , j ) / 2.d0 + 1.d-10 ) end if if ( ctr == 3. and . dsqrt ( dx ** 2.d0 + dy ** 2.d0 ) < 1.d-12 ) then dx = TGrid % x ( i , j ) - BoomCase % Posp % x dy = TGrid % y ( i , j ) - BoomCase % Posp % y + epsil dis = ( dsqrt ( dx ** 2.d0 + dy ** 2.d0 ) - ( BoomCase % Dobj / 2.d0 )) nxx ( i , j ) = dx / dsqrt ( dx ** 2.d0 + dy ** 2.d0 ) nyy ( i , j ) = dy / dsqrt ( dx ** 2.d0 + dy ** 2.d0 ) dis = dsign ( 1.d0 , dis ) * dmax1 ( dabs ( dis ), dabs ( nxx ( i , j )) * TGrid % dx ( i , j ) & / 2.d0 + dabs ( nyy ( i , j )) * TGrid % dy ( i , j ) / 2.d0 + 1.d-10 ) end if TCell % phiS ( i , j ) = dis !  For region at left side of boom if ( TGrid % x ( i , j ) <= BoomCase % XBar1 ) then !  For region under boom if ( TGrid % y ( i , j ) < BoomCase % YBar ) then dx = TGrid % x ( i , j ) - BoomCase % XBar1 dy = TGRid % y ( i , j ) - BoomCase % YBar TCell % PhiS ( i , j ) = dsqrt ( dx ** 2.d0 + dy ** 2.d0 ) nxx ( i , j ) = dx / dsqrt ( dx ** 2.d0 + dy ** 2.d0 ) nyy ( i , j ) = dy / dsqrt ( dx ** 2.d0 + dy ** 2.d0 ) !  For region have same altitude as Boom bar else if ( TGrid % y ( i , j ) < BoomCase % YBar + BoomCase % LBar ) then dis = BoomCase % XBar1 - TGrid % x ( i , j ) if ( dabs ( dis ) < dabs ( TCell % phiS ( i , j ))) then nxx ( i , j ) =- 1.d0 nyy ( i , j ) = 0.d0 TCell % phiS ( i , j ) = dis end if end if !  For region at right side of boom else if ( TGrid % x ( i , j ) >= BoomCase % XBar2 ) then !  For region under boom if ( TGrid % y ( i , j ) < BoomCase % YBar ) then dx = TGrid % x ( i , j ) - BoomCase % XBar2 dy = TGRid % y ( i , j ) - BoomCase % YBar TCell % PhiS ( i , j ) = dsqrt ( dx ** 2.d0 + dy ** 2.d0 ) nxx ( i , j ) = dx / dsqrt ( dx ** 2.d0 + dy ** 2.d0 ) nyy ( i , j ) = dy / dsqrt ( dx ** 2.d0 + dy ** 2.d0 ) !  For region have same altitude as Boom bar else if ( TGrid % y ( i , j ) < BoomCase % YBar + BoomCase % LBar ) then dis = TGrid % x ( i , j ) - BoomCase % XBar2 if ( dabs ( dis ) < dabs ( TCell % phiS ( i , j ))) then nxx ( i , j ) = 1.d0 nyy ( i , j ) = 0.d0 TCell % phiS ( i , j ) = dis end if end if !  For region inside boom else !  For region under boom if ( TGrid % y ( i , j ) <= BoomCase % YBar ) then TCell % PhiS ( i , j ) = BoomCase % YBar - TGrid % y ( i , j ) nxx ( i , j ) = 0.d0 nyy ( i , j ) =- 1.d0 !  For region inside boom bar elseif ( TGrid % y ( i , j ) < BoomCase % YBar + BoomCase % LBar ) then dpt ( 1 ) = BoomCase % YBar - TGrid % y ( i , j ) dpt ( 2 ) = BoomCase % XBar1 - TGrid % x ( i , j ) dpt ( 3 ) = TGrid % x ( i , j ) - BoomCase % XBar2 if ( dabs ( dpt ( 1 )) <= dabs ( dpt ( 2 )). and . dabs ( dpt ( 1 )) <= dabs ( dpt ( 3 ))) then TCell % PhiS ( i , j ) = dpt ( 1 ) nxx ( i , j ) = 0.d0 nyy ( i , j ) =- 1.d0 end if if ( dabs ( dpt ( 2 )) <= dabs ( dpt ( 1 )). and . dabs ( dpt ( 2 )) <= dabs ( dpt ( 3 ))) then TCell % PhiS ( i , j ) = dpt ( 2 ) nxx ( i , j ) =- 1.d0 nyy ( i , j ) = 0.d0 end if if ( dabs ( dpt ( 3 )) <= dabs ( dpt ( 1 )). and . dabs ( dpt ( 3 )) <= dabs ( dpt ( 2 ))) then TCell % PhiS ( i , j ) = dpt ( 3 ) nxx ( i , j ) = 1.d0 nyy ( i , j ) = 0.d0 end if !  For region inside cylinder elseif ( TGrid % y ( i , j ) < BoomCase % Posp % y ) then if ( dabs ( TGrid % x ( i , j ) - 0.5d0 * ( BoomCase % XBar1 + BoomCase % XBar2 )) / & dabs ( TGrid % y ( i , j ) - BoomCase % Posp % y ) < BoomCase % Wobj / 2.d0 / & dsqrt (( BoomCase % Dobj / 2.d0 ) ** 2.d0 - ( BoomCase % Wobj / 2.d0 ) ** 2.d0 )) then dpt ( 1 ) =- dsqrt (( TGrid % x ( i , j ) - BoomCase % XBar1 ) ** 2.d0 + & ( TGrid % y ( i , j ) - BoomCase % YBar - BoomCase % LBar ) ** 2.d0 ) dpt ( 2 ) =- dsqrt (( TGrid % x ( i , j ) - BoomCase % XBar2 ) ** 2.d0 + & ( TGrid % y ( i , j ) - BoomCase % YBar - BoomCase % LBar ) ** 2.d0 ) if ( dabs ( dpt ( 1 )) < dabs ( dpt ( 2 ))) then TCell % PhiS ( i , j ) = dpt ( 1 ) nxx ( i , j ) = ( BoomCase % XBar1 - TGrid % x ( i , j )) / dabs ( dpt ( 1 )) nyy ( i , j ) =- ( TGrid % y ( i , j ) - BoomCase % YBar - BoomCase % LBar ) / dabs ( dpt ( 1 )) else TCell % PhiS ( i , j ) = dpt ( 2 ) nxx ( i , j ) = ( BoomCase % XBar2 - TGrid % x ( i , j )) / dabs ( dpt ( 2 )) nyy ( i , j ) =- ( TGrid % y ( i , j ) - BoomCase % YBar - BoomCase % LBar ) / dabs ( dpt ( 2 )) end if end if end if end if if ( isnan ( TCell % vof ( i , j ))) then print * , 'test' print * , vofsOld ( i , j ), TCell % VofS ( i , j ) print * , TCell % PhiS ( i , j ) print * , nxx ( i , j ), nyy ( i , j ) pause 'ClsVof_2804' end if call frac ( nxx ( i , j ), nyy ( i , j ), TCell % phiS ( i , j ), TGrid % dx ( i , j ), & TGrid % dy ( i , j ), vol ) TCell % vofS ( i , j ) = vol if ( TCell % vofS ( i , j ) < epsi ) TCell % vofS ( i , j ) = 0.d0 if ( TCell % vofS ( i , j ) >= 1.d0 - epsi ) TCell % vofS ( i , j ) = 1.d0 ! Correct VofS for bottom region of boom if ( TCell % vofS ( i , j ) > epsi . and . TCell % vofS ( i , j ) < 1.d0 - epsi ) then if ( TGrid % y ( i , j ) + TGrid % dy ( i , j ) / 2.d0 - tolp > BoomCase % YBar . and . & TGrid % y ( i , j ) - TGrid % dy ( i , j ) / 2.d0 + tolp < BoomCase % YBar ) then if ( TGrid % x ( i , j ) - TGrid % dx ( i , j ) / 2.d0 + tolp < BoomCase % XBar1 . and . & TGrid % x ( i , j ) + TGrid % dx ( i , j ) / 2.d0 - tolp > BoomCase % XBar1 ) then CutP ( 1 )% x = BoomCase % XBar1 - TGrid % x ( i , j ) CutP ( 1 )% y = TGrid % dy ( i , j ) / 2.d0 CutP ( 2 )% x = TGrid % dx ( i , j ) / 2.d0 CutP ( 2 )% y = BoomCase % YBar - TGrid % y ( i , j ) nxx1 = CutP ( 2 )% y - CutP ( 1 )% y nyy1 = CutP ( 2 )% x - CutP ( 1 )% x TCell % vofS ( i , j ) = 0.5d0 * dabs ( nxx1 * nyy1 ) / TGrid % dx ( i , j ) / TGrid % dy ( i , j ) nxy = dsqrt ( nxx1 ** 2.d0 + nyy1 ** 2.d0 ) nxx ( i , j ) =- dabs ( nxx1 / nxy ) nyy ( i , j ) =- dabs ( nyy1 / nxy ) TCell % phiS ( i , j ) = dabs ( CutP ( 2 )% x * CutP ( 1 )% y - CutP ( 1 )% x * CutP ( 2 )% y ) / nxy end if if ( TGrid % x ( i , j ) - TGrid % dx ( i , j ) / 2.d0 + tolp < BoomCase % XBar2 . and . & TGrid % x ( i , j ) + TGrid % dx ( i , j ) / 2.d0 - tolp > BoomCase % XBar2 ) then CutP ( 1 )% x = BoomCase % XBar2 - TGrid % x ( i , j ) CutP ( 1 )% y = TGrid % dy ( i , j ) / 2.d0 CutP ( 2 )% x =- TGrid % dx ( i , j ) / 2.d0 CutP ( 2 )% y = BoomCase % YBar - TGrid % y ( i , j ) nxx1 = CutP ( 2 )% y - CutP ( 1 )% y nyy1 = CutP ( 2 )% x - CutP ( 1 )% x TCell % vofS ( i , j ) = 0.5d0 * dabs ( nxx1 * nyy1 ) / TGrid % dx ( i , j ) / TGrid % dy ( i , j ) nxy = dsqrt ( nxx1 ** 2.d0 + nyy1 ** 2.d0 ) nxx ( i , j ) = dabs ( nxx1 / nxy ) nyy ( i , j ) =- dabs ( nyy1 / nxy ) TCell % phiS ( i , j ) = dabs ( CutP ( 2 )% x * CutP ( 1 )% y - CutP ( 1 )% x * CutP ( 2 )% y ) / nxy end if end if end if ! Correct VofS for region containing cylinder and bar if ( TCell % vofS ( i , j ) > epsi . and . TCell % vofS ( i , j ) < 1.d0 - epsi ) then if ( TGrid % y ( i , j ) + TGrid % dy ( i , j ) / 2.d0 - tolp > BoomCase % Posp % y - CylBar . and . & TGrid % y ( i , j ) - TGrid % dy ( i , j ) / 2.d0 + tolp < BoomCase % Posp % y - CylBar ) then if ( TGrid % x ( i , j ) - TGrid % dx ( i , j ) / 2.d0 + tolp < BoomCase % XBar1 . and . & TGrid % x ( i , j ) + TGrid % dx ( i , j ) / 2.d0 - tolp > BoomCase % XBar1 ) then CutP ( 1 )% x = BoomCase % XBar1 - TGrid % x ( i , j ) CutP ( 1 )% y =- TGrid % dy ( i , j ) / 2.d0 if ( dsqrt (( TGrid % x ( i , j ) - TGrid % dx ( i , j ) / 2.d0 - BoomCase % Posp % x ) ** 2.d0 + & ( TGrid % y ( i , j ) + TGrid % dy ( i , j ) / 2.d0 - BoomCase % Posp % y ) ** 2.d0 ) < & BoomCase % Dobj / 2.d0 ) then CutP ( 2 )% x =- TGrid % dx ( i , j ) / 2.d0 CutP ( 2 )% y =- dsqrt (( BoomCase % Dobj / 2.d0 ) ** 2.d0 - & ( TGrid % x ( i , j ) - BoomCase % Posp % x - TGrid % dx ( i , j ) / 2.d0 ) ** 2.d0 ) - & ( TGrid % y ( i , j ) - BoomCase % Posp % y ) nxx1 = CutP ( 2 )% y - CutP ( 1 )% y nyy1 = CutP ( 2 )% x - CutP ( 1 )% x TCell % vofS ( i , j ) = 1.d0 - 0.5d0 * dabs ( nxx1 * nyy1 ) / TGrid % dx ( i , j ) / & TGrid % dy ( i , j ) nxy = dsqrt ( nxx1 ** 2.d0 + nyy1 ** 2.d0 ) nxx ( i , j ) =- dabs ( nxx1 / nxy ) nyy ( i , j ) =- dabs ( nyy1 / nxy ) TCell % phiS ( i , j ) = dabs ( CutP ( 2 )% x * CutP ( 1 )% y - & CutP ( 1 )% x * CutP ( 2 )% y ) / nxy * dsign ( 1.d0 , 0.5d0 - TCell % vofS ( i , j )) else CutP ( 2 )% x =- dsqrt (( BoomCase % Dobj / 2.d0 ) ** 2.d0 - & ( BoomCase % Posp % y - TGrid % y ( i , j ) - TGrid % dy ( i , j ) / 2.d0 ) ** 2.d0 ) - & ( TGrid % x ( i , j ) - BoomCase % Posp % x ) CutP ( 2 )% y = TGrid % dy ( i , j ) / 2.d0 nxx1 = CutP ( 2 )% y - CutP ( 1 )% y nyy1 = CutP ( 2 )% x - CutP ( 1 )% x TCell % vofS ( i , j ) = 0.5d0 * dabs ( TGrid % dx ( i , j ) - CutP ( 1 )% x - CutP ( 2 )% x )& / TGrid % dx ( i , j ) nxy = dsqrt ( nxx1 ** 2.d0 + nyy1 ** 2.d0 ) nxx ( i , j ) =- dabs ( nxx1 / nxy ) nyy ( i , j ) =- dabs ( nyy1 / nxy ) TCell % phiS ( i , j ) = dabs ( CutP ( 2 )% x * CutP ( 1 )% y - & CutP ( 1 )% x * CutP ( 2 )% y ) / nxy * dsign ( 1.d0 , 0.5d0 - TCell % vofS ( i , j )) end if end if if ( TGrid % x ( i , j ) - TGrid % dx ( i , j ) / 2.d0 + tolp < BoomCase % XBar2 . and . & TGrid % x ( i , j ) + TGrid % dx ( i , j ) / 2.d0 - tolp > BoomCase % XBar2 ) then CutP ( 1 )% x = BoomCase % XBar2 - TGrid % x ( i , j ) CutP ( 1 )% y =- TGrid % dy ( i , j ) / 2.d0 if ( dsqrt (( TGrid % x ( i , j ) + TGrid % dx ( i , j ) / 2.d0 - BoomCase % Posp % x ) ** 2.d0 + & ( TGrid % y ( i , j ) + TGrid % dy ( i , j ) / 2.d0 - BoomCase % Posp % y ) ** 2.d0 ) < & BoomCase % Dobj / 2.d0 ) then CutP ( 2 )% x = TGrid % dx ( i , j ) / 2.d0 CutP ( 2 )% y =- dsqrt (( BoomCase % Dobj / 2.d0 ) ** 2.d0 - & ( TGrid % x ( i , j ) - BoomCase % Posp % x + TGrid % dx ( i , j ) / 2.d0 ) ** 2.d0 ) - & ( TGrid % y ( i , j ) - BoomCase % Posp % y ) nxx1 = CutP ( 2 )% y - CutP ( 1 )% y nyy1 = CutP ( 2 )% x - CutP ( 1 )% x TCell % vofS ( i , j ) = 1.d0 - 0.5d0 * dabs ( nxx1 * nyy1 ) / TGrid % dx ( i , j ) / & TGrid % dy ( i , j ) nxy = dsqrt ( nxx1 ** 2.d0 + nyy1 ** 2.d0 ) nxx ( i , j ) = dabs ( nxx1 / nxy ) nyy ( i , j ) =- dabs ( nyy1 / nxy ) TCell % phiS ( i , j ) = dabs ( CutP ( 2 )% x * CutP ( 1 )% y - & CutP ( 1 )% x * CutP ( 2 )% y ) / nxy * dsign ( 1.d0 , 0.5d0 - TCell % vofS ( i , j )) else CutP ( 2 )% x = dsqrt (( BoomCase % Dobj / 2.d0 ) ** 2.d0 - & ( BoomCase % Posp % y - TGrid % y ( i , j ) - TGrid % dy ( i , j ) / 2.d0 ) ** 2.d0 ) - & ( TGrid % x ( i , j ) - BoomCase % Posp % x ) CutP ( 2 )% y = TGrid % dy ( i , j ) / 2.d0 nxx1 = CutP ( 2 )% y - CutP ( 1 )% y nyy1 = CutP ( 2 )% x - CutP ( 1 )% x TCell % vofS ( i , j ) = 0.5d0 * dabs ( CutP ( 1 )% x + CutP ( 2 )% x + TGrid % dx ( i , j ))& / TGrid % dx ( i , j ) nxy = dsqrt ( nxx1 ** 2.d0 + nyy1 ** 2.d0 ) nxx ( i , j ) = dabs ( nxx1 / nxy ) nyy ( i , j ) =- dabs ( nyy1 / nxy ) TCell % phiS ( i , j ) = dabs ( CutP ( 2 )% x * CutP ( 1 )% y - & CutP ( 1 )% x * CutP ( 2 )% y ) / nxy * dsign ( 1.d0 , 0.5d0 - TCell % vofS ( i , j )) end if end if end if end if TCell % nxS ( i , j ) = nxx ( i , j ) TCell % nyS ( i , j ) = nyy ( i , j ) if ( TCell % vofS ( i , j ) < epsi ) TCell % vofS ( i , j ) = 0.d0 if ( TCell % vofS ( i , j ) >= 1.d0 - epsi ) TCell % vofS ( i , j ) = 1.d0 if (( TCell % Vof ( i , j ) + VofsOld ( i , j ) >= 1.d0 - epsi ). or . & ( TCell % Vof ( i , j ) + TCell % VofS ( i , j )) >= 1.d0 - epsi ) then TCell % Vof ( i , j ) = 1.d0 - TCell % VofS ( i , j ) end if if ( VofsOld ( i , j ) < 1.d0 - epsi . and . & TCell % Vof ( i , j ) + VofsOld ( i , j ) < 1.d0 - epsi . and . & TCell % Vof ( i , j ) + TCell % VofS ( i , j ) < 1.d0 - epsi ) then TCell % Vof ( i , j ) = TCell % Vof ( i , j ) / ( 1.d0 - VofsOld ( i , j ) + TolDeno ) * & ( 1.d0 - TCell % VofS ( i , j )) end if if ( isnan ( TCell % vof ( i , j ))) then print * , 'test' print * , vofsOld ( i , j ), TCell % VofS ( i , j ) print * , TCell % PhiS ( i , j ) print * , nxx ( i , j ), nyy ( i , j ) pause 'ClsVof_2875' end if end do end do deallocate ( nxx ) deallocate ( nyy ) END SUBROUTINE SolidVolumeFraction SUBROUTINE EdgeGeoCalCyl ( BoomCase , Pt1 , Pt2 , CutP , ctr ) !! The subroutine calculates the intersection between the interface and !! the cell edges in the case of cylinder. IMPLICIT NONE TYPE ( SolidObject ), INTENT ( IN ) :: BoomCase TYPE ( point ), INTENT ( IN ) :: Pt1 , Pt2 TYPE ( point ), DIMENSION ( 4 ), INTENT ( INOUT ) :: CutP INTEGER ( KIND = it4b ), INTENT ( INOUT ) :: ctr REAL ( KIND = dp ) :: epsil , Lvs_Pt1 , Lvs_Pt2 , EdAr Lvs_Pt1 = dsqrt (( Pt1 % x - BoomCase % Posp % x ) ** 2.d0 + & ( Pt1 % y - BoomCase % Posp % y ) ** 2.d0 ) - BoomCase % Dobj / 2.d0 Lvs_Pt2 = dsqrt (( Pt2 % x - BoomCase % Posp % x ) ** 2.d0 + & ( Pt2 % y - BoomCase % Posp % y ) ** 2.d0 ) - BoomCase % Dobj / 2.d0 epsil = 1.d-20 if ( Lvs_Pt1 >= epsil . and . Lvs_Pt2 < epsil ) then if ( dabs ( pt1 % x - pt2 % x ) <= 1.d-10 ) then EdAr = pt1 % y - dsign ( 1.d0 , pt1 % y - BoomCase % Posp % y ) * & dsqrt (( BoomCase % Dobj / 2.d0 ) ** 2.d0 - ( pt1 % x - BoomCase % Posp % x ) ** 2.d0 )& - BoomCase % Posp % y CutP ( ctr )% y = pt1 % y - EdAr CutP ( ctr )% x = pt1 % x ctr = ctr + 1 else EdAr = pt1 % x - dsign ( 1.d0 , pt1 % x - BoomCase % Posp % x ) * & dsqrt (( BoomCase % Dobj / 2.d0 ) ** 2.d0 - ( pt1 % y - BoomCase % Posp % y ) ** 2.d0 )& - BoomCase % Posp % x CutP ( ctr )% x = pt1 % x - EdAr CutP ( ctr )% y = pt1 % y ctr = ctr + 1 end if elseIf ( Lvs_Pt1 < epsil . and . Lvs_Pt2 >= epsil ) then if ( dabs ( pt1 % x - pt2 % x ) <= 1.d-10 ) then EdAr = pt2 % y - dsign ( 1.d0 , pt2 % y - BoomCase % Posp % y ) * & dsqrt (( BoomCase % Dobj / 2.d0 ) ** 2.d0 - ( pt2 % x - BoomCase % Posp % x ) ** 2.d0 )& - BoomCase % Posp % y CutP ( ctr )% y = pt2 % y - EdAr CutP ( ctr )% x = pt1 % x ctr = ctr + 1 else EdAr = pt2 % x - dsign ( 1.d0 , pt2 % x - BoomCase % Posp % x ) * & dsqrt (( BoomCase % Dobj / 2.d0 ) ** 2.d0 - ( pt2 % y - BoomCase % Posp % y ) ** 2.d0 )& - BoomCase % Posp % x CutP ( ctr )% x = pt2 % x - EdAr CutP ( ctr )% y = pt2 % y ctr = ctr + 1 end if end if END SUBROUTINE EdgeGeoCalCyl End module Clsvof","tags":"","loc":"sourcefile/clsvof_mod.f90.html","title":"Clsvof_Mod.f90 – Fortran Program"},{"text":"Contents Modules StateVariables Source Code StateVariables.f90 Source Code Module StateVariables USE PrecisionVar USE Mesh USE Matrix IMPLICIT NONE PRIVATE INTEGER ( kind = it4b ), PUBLIC :: ight = 1 , jght = 1 INTEGER ( kind = it4b ), PUBLIC :: ite TYPE ( Point ), PUBLIC :: Start_Point , End_Point REAL ( KIND = dp ), PARAMETER , PUBLIC :: pi = 4.d0 * datan ( 1.d0 ), Cp = 1.005d3 , & kT = 0.0271d0 , kTw = 0.0271d0 , g = 9.81d0 , factor = 0.5d0 REAL ( KIND = dp ), PUBLIC :: Lref , Rey , Fr , wa , Ta , xc , yc , UwInlet , UgInlet , & xmax , Roref , Hw , Ha , VofInlet , nuref !   for run again from INTEGER ( KIND = it8b ), PUBLIC :: IttRun , IttBegin LOGICAL , PUBLIC :: RunAgain , ICorProb !   For particles from 3D to 2D REAL ( KIND = dp ), PUBLIC :: zp , UParInlet , HParInlet , DParInlet , rop , gx , gy !   For number of particles into system INTEGER ( kind = it4b ), PUBLIC :: NParInlet , IParInlet !   For Water Entry problem REAL ( KIND = dp ), PUBLIC :: y0 , y1 !   For Wave Braking on vertical wall REAL ( KIND = dp ), PUBLIC :: t0 , cw0 , Amp0 , Depthw , Lamdaw , twp , HChannel , & LChannel , kw , omew , HDomain REAL ( KIND = dp ), PUBLIC , PARAMETER :: nuw = 1.0034d-6 , nua = 1.506d-5 , & roa = 1.225d0 , row = 99 8.2d0 ! At T = 20oC REAL ( KIND = dp ), PUBLIC , PARAMETER :: epsi = 1.d-3 , epsiF = 1.d-2 , BetaVis = 0.5d0 CHARACTER * 70 , PUBLIC :: dir TYPE , PUBLIC :: Variables REAL ( KIND = dp ), DIMENSION (:,:), allocatable :: u , v , p , t , Gpu , Gpv , ures , vres , pres , mres REAL ( KIND = dp ) :: Uint , Vint , Pint , Tint , Uref , Roref , Pref , Tref END TYPE PUBLIC :: Initial_Var , Boundary_Condition_Var interface Initial_Var module procedure Initial_Var end interface Initial_Var interface Boundary_Condition_Var module procedure Boundary_Condition_Var end interface Boundary_Condition_Var contains subroutine Initial_Var ( PCell , PGrid , Vari , Uint , Vint , Pint , Tint , Uref , Tref , Roref , Lref ) REAL ( KIND = dp ), INTENT ( IN ) :: Uint , Vint , Pint , Tint , Uref , Tref , Roref , Lref TYPE ( Cell ), INTENT ( IN ) :: PCell TYPE ( Grid ), INTENT ( IN ) :: PGrid TYPE ( Variables ), INTENT ( INOUT ) :: Vari INTEGER ( kind = it4b ) :: i , j REAL ( KIND = dp ) :: Hwt0 , xu0 , Amp , cw , tw , delta , xwu , xwv , ywu , ywv Vari % Uint = Uint Vari % Vint = Vint Vari % Pint = Pint Vari % Tint = Tint Vari % Uref = Uref Vari % Roref = Roref Vari % Pref = Roref * Uref ** 2.d0 Vari % Tref = Tref do i = ibeg , Isize + ibeg - 1 do j = jbeg , Jsize + jbeg - 1 ! for sinusoidal wave Vari % u ( i , j ) = 0.d0 Vari % v ( i , j ) = 0.d0 Hwt0 = Depthw if ( PGrid % y ( i , j ) >= Hwt0 ) then Vari % p ( i , j ) = roa / roref * g * ( PGrid % y ( 1 , Jsize ) + PGrid % dy ( 1 , Jsize ) / 2.d0 - & PGrid % y ( i , j )) else Vari % p ( i , j ) = roa / Roref * g * ( PGrid % y ( 1 , Jsize ) + PGrid % dy ( 1 , Jsize ) / 2.d0 - & Hwt0 ) + row / Roref * g * ( Hwt0 - PGrid % y ( i , j )) endif Vari % Gpu ( i , j ) = 0.d0 Vari % Gpv ( i , j ) = 0.d0 Vari % t ( i , j ) = Tint / Tref end do end do do i = 1 , Isize do j = 1 , Jsize xwu = PGrid % x ( i , j ) + PGrid % dx ( i , j ) / 2.d0 xwv = PGrid % x ( i , j ) ywu = Amp0 * dsin ( kw * xwu ) ywv = Amp0 * dsin ( kw * xwv ) if ( PGrid % y ( i , j ) - Depthw < ywu ) then Vari % u ( i , j ) = UwInlet - Amp0 * kw * ( UwInlet - cw0 ) * dsin ( kw * xwu ) * & dcosh ( kw * PGrid % y ( i , j )) / dsinh ( kw * Depthw ) else Vari % u ( i , j ) = UgInlet + Amp0 * kw * ( UgInlet - cw0 ) * dsin ( kw * xwu ) * & dcosh ( kw * ( PGrid % y ( i , j ) - HChannel )) / dsinh ( kw * Ha ) end if if ( PGrid % y ( i , j ) - Depthw < ywv ) then Vari % v ( i , j ) = Amp0 * kw * ( UwInlet - cw0 ) * dcos ( kw * xwv ) * & dsinh ( kw * ( PGrid % y ( i , j ) + 0.5d0 * PGrid % dy ( i , j ))) / dsinh ( kw * Depthw ) else Vari % v ( i , j ) =- Amp0 * kw * ( UgInlet - cw0 ) * dcos ( kw * xwv ) * & dsinh ( kw * ( PGrid % y ( i , j ) + 0.5d0 * PGrid % dy ( i , j ) - HChannel )) / dsinh ( kw * Ha ) end if end do end do Rey = Uref * Lref / nuref Fr = Uref / dsqrt ( g * Lref ) print * , \"Reynolds number:\" , Rey print * , \"Froude number:\" , Fr !   call Boundary_Condition_Var(PGrid,PCell,Vari,0.d0) end subroutine Initial_Var !******************************************************* ! ! !      ________Slip Wall_______ ! Inlet ! Air !      ________________________ ! Inlet........................Outlet ! Water........................Water !      ........................ !      ........................ !      __________Slip Wall_____ ! !******************************************************* subroutine Boundary_Condition_Var ( PGrid , PCell , Vari , Time ) TYPE ( Grid ), INTENT ( IN ) :: PGrid TYPE ( Cell ), INTENT ( IN ) :: PCell TYPE ( Variables ), INTENT ( INOUT ) :: Vari REAL ( KIND = dp ), INTENT ( IN ) :: Time INTEGER ( kind = it4b ) :: i , j , temp REAL ( KIND = dp ), PARAMETER :: Twall = 30 0.d0 REAL ( KIND = dp ) :: ywu , ywv , xwu , xwv , ywuout , ywvout , xwuout , xwvout , & Hwin , Hwout , Hain , Haout temp = 0 do j = 1 , Jsize if ( PCell % vof ( 1 , j ) > epsi ) Hwin = PGrid % y ( 1 , j ) - & ( 0.5d0 - PCell % vof ( 1 , j )) * PGrid % dy ( 1 , j ) if ( PCell % vof ( Isize , j ) > epsi . and . PCell % vof ( Isize , j ) < 1.d0 - epsi ) then Hwout = PGrid % y ( Isize , j ) - ( 0.5d0 - PCell % vof ( Isize , j )) * PGrid % dy ( Isize , j ) temp = temp + 1 end if end do xwu = PGrid % x ( 1 , 1 ) - PGrid % dx ( 1 , 1 ) / 2.d0 xwv = PGrid % x ( 1 , 1 ) - PGrid % dx ( 1 , 1 ) ywu = Amp0 * dsin ( kw * ( xwu - cw0 * Time )) ywv = Amp0 * dsin ( kw * ( xwv - cw0 * Time )) xwuout = PGrid % x ( Isize , 1 ) + PGrid % dx ( Isize , 1 ) / 2.d0 xwvout = PGrid % x ( Isize , 1 ) + PGrid % dx ( Isize , 1 ) ywuout = Amp0 * dsin ( kw * ( xwuout - cw0 * Time )) ywvout = Amp0 * dsin ( kw * ( xwvout - cw0 * Time )) if ( temp == 2 ) Hwout = Depthw Hain = HChannel - Hwin Haout = HChannel - Hwout do j = jbeg , Jsize + jbeg - 1 ! Left inlet water Vari % p ( ibeg - ight , j ) = Vari % p ( ibeg , j ) !Vari%Pint/(Vari%Pref) Vari % t ( ibeg - ight , j ) = Vari % t ( ibeg , j ) if ( PGrid % y ( 1 , j ) - Hwin < ywu ) then Vari % u ( ibeg - ight , j ) = UwInlet - Amp0 * kw * ( UwInlet - cw0 ) * & dsin ( kw * ( xwu - cw0 * Time )) * dcosh ( kw * PGrid % y ( 1 , j )) / dsinh ( kw * Hwin ) else Vari % u ( ibeg - ight , j ) = UgInlet + Amp0 * kw * ( UgInlet - cw0 ) * & dsin ( kw * ( xwu - cw0 * Time )) * dcosh ( kw * ( PGrid % y ( 1 , j ) - HChannel )) / dsinh ( kw * Hain ) end if if ( PGrid % y ( 1 , j ) - Hwin < ywv ) then Vari % v ( ibeg - ight , j ) = Amp0 * kw * ( UwInlet - cw0 ) * dcos ( kw * ( xwv - cw0 * Time )) * & dsinh ( kw * ( PGrid % y ( 1 , j ) + 0.5d0 * PGrid % dy ( 1 , j ))) / dsinh ( kw * Hwin ) else Vari % v ( ibeg - ight , j ) =- Amp0 * kw * ( UgInlet - cw0 ) * dcos ( kw * ( xwv - cw0 * Time )) * & dsinh ( kw * ( PGrid % y ( 1 , j ) + 0.5d0 * PGrid % dy ( 1 , j ) - HChannel )) / dsinh ( kw * Hain ) end if ! Right outlet water !  if(PGrid%y(Isize,j)-Hwout<ywuout) then if ( PCell % vof ( isize , j ) > 0.5d0 ) then Vari % u ( Isize , j ) = UwInlet !-Amp0*kw*(UwInlet-cw0)*                       & ! dsin(kw*(xwuout-cw0*Time))*dcosh(kw*PGrid%y(Isize,j))/dsinh(kw*Hwout) else Vari % u ( Isize , j ) = UgInlet !+Amp0*kw*(UgInlet-cw0)*                       & ! dsin(kw*(xwuout-cw0*Time))*dcosh(kw*(PGrid%y(Isize,j)-HChannel))/ & !                                                     dsinh(kw*Haout) end if if ( PGrid % y ( Isize , j ) - Hwout < ywvout ) then Vari % v ( Isize + 1 , j ) = Amp0 * kw * ( UwInlet - cw0 ) * dcos ( kw * ( xwvout - cw0 * Time )) * & dsinh ( kw * ( PGrid % y ( Isize , j ) + 0.5d0 * PGrid % dy ( Isize , j ))) / dsinh ( kw * Hwout ) else Vari % v ( Isize + 1 , j ) =- Amp0 * kw * ( UgInlet - cw0 ) * dcos ( kw * ( xwvout - cw0 * Time )) * & dsinh ( kw * ( PGrid % y ( Isize , j ) + 0.5d0 * PGrid % dy ( Isize , j ) - HChannel )) / & dsinh ( kw * Haout ) end if Vari % p ( Isize + ibeg + ight - 1 , j ) = Vari % p ( Isize + ibeg - 1 , j ) Vari % u ( Isize + ibeg + ight - 1 , j ) = Vari % u ( Isize + ibeg - 1 , j ) !Vari%Uint/Vari%Uref Vari % v ( Isize + 1 , j ) = Vari % v ( Isize + ibeg - 1 , j ) !  Vari%v(Isize+1,j)=0.d0 end do do i = ibeg , Isize + ibeg - 1 ! Bottom boundary Vari % p ( i , jbeg - jght ) = Vari % p ( i , jbeg ) Vari % t ( i , jbeg - jght ) = Vari % t ( i , jbeg ) Vari % u ( i , jbeg - jght ) = Vari % u ( i , jbeg ) xwu = PGrid % x ( i , 1 ) + PGrid % dx ( i , 1 ) / 2.d0 Vari % u ( i , jbeg - jght ) =- Amp0 * kw * ( UwInlet - cw0 ) * dsin ( kw * ( xwu - cw0 * Time )) * & dcosh ( kw * ( PGrid % y ( i , 1 ) - PGrid % dy ( i , 1 ))) / dsinh ( kw * Depthw ) xwv = PGrid % x ( i , 1 ) Vari % v ( i , jbeg - jght ) = Amp0 * kw * ( UwInlet - cw0 ) * dcos ( kw * ( xwv - cw0 * Time )) * & dsinh ( kw * ( PGrid % y ( i , 1 ) - 0.5d0 * PGrid % dy ( i , 1 ))) / dsinh ( kw * Depthw ) !0.d0 !Vari%Vint/Vari%Uref ! Open air Vari % p ( i , Jsize + jbeg + jght - 1 ) = 0.d0 Vari % t ( i , jbeg + Jsize + jght - 1 ) = Vari % t ( i , jbeg + Jsize - 1 ) Vari % u ( i , Jsize + jbeg + jght - 1 ) = Vari % u ( i , Jsize + jbeg - 1 ) !   Vari%v(i,Jsize+jbeg-1) = Vari%v(i,Jsize+jbeg-2) Vari % v ( i , Jsize + jght ) = Vari % v ( i , Jsize ) end do end subroutine Boundary_Condition_Var End Module StateVariables","tags":"","loc":"sourcefile/statevariables.f90.html","title":"StateVariables.f90 – Fortran Program"},{"text":"Contents Modules PredictorUV Source Code PredictorUV_mod.f90 Source Code Module PredictorUV !! Description: !! The module compute the predictor step for velocities !! Method: !! Adam-Bashforth for convective flux and Crank-Nicolson or fully implicit !! for diffusive flux (it is decided by BetaVis). All extra !! The first order upwind will be applied for convective flux in the first time step. !! Then, high order 3rd MUSCL will be applied. For the cells near solid boundary, !! first order upwind will be applied. The density-based convective will be applied !! for cell containing only liquid and gas. !! The source term will be handled implicitly ! Current Code Owner: SIMCOFlow ! Code Description: ! Language: Fortran 90. ! Software Standards: \"European Standards for Writing and ! Documenting Exchangeable Fortran 90 Code\". !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! Author : Son Tung Dang !        : NTNU,SINTEF ! Date : 20.09.2019 USE PrecisionVar USE Mesh USE Cutcell USE Clsvof USE StateVariables USE Matrix USE Printresult USE MPI USE Particles IMPLICIT NONE PRIVATE real ( kind = dp ), DIMENSION (:,:), pointer :: u , Uvolf real ( kind = dp ), DIMENSION (:,:), pointer :: v , Vvolf Real ( kind = dp ), DIMENSION (:,:), pointer :: p Real ( kind = dp ), PARAMETER , PRIVATE :: tol = 1.d-14 TYPE , PUBLIC :: Predictor REAL ( KIND = dp ), DIMENSION (:,:), allocatable :: u , v End TYPE TYPE , PUBLIC :: PoissonCoefficient REAL ( KIND = dp ), DIMENSION (:,:), allocatable :: Dp End TYPE PUBLIC :: Predictor_UV Interface Predictor_UV Module Procedure Predictor_UV End interface Contains Subroutine Predictor_UV ( PGrid , UGrid , VGrid , PCellO , UCellO , VCellO , PCell , & UCell , VCell , TVar , PU , PV , Pred , Flux_n1 , TraPar , & BoomCase , dt , itt ) !! The subroutine is the predictor step for velocities IMPLICIT NONE INTEGER ( kind = it8b ), INTENT ( IN ) :: itt !! The iterations number REAL ( KIND = dp ), INTENT ( IN ) :: dt !! The time step TYPE ( Grid ), INTENT ( IN ) :: PGrid , UGrid , VGrid !! The grid TYPE ( Cell ), INTENT ( IN ) :: PCell !! The pressure cell at next time step (n+1) TYPE ( Cell ), INTENT ( IN ) :: PCellO !! The pressure cell at current time step (n) TYPE ( Cell ), INTENT ( IN ), target :: UCell , VCell !! The velocities cell at next time step (n+1) TYPE ( Cell ), INTENT ( IN ), target :: UCellO , VCellO !! The velocities cell at next time step (n) TYPE ( Variables ), INTENT ( IN ), target :: TVar !! The state variables TYPE ( Predictor ), INTENT ( INOUT ) :: Pred !! The predictor velocity TYPE ( PoissonCoefficient ), INTENT ( INOUT ) :: PU , PV !! The cofficient for solving Poisson equation REAL ( KIND = dp ), DIMENSION (:,:,:), allocatable , INTENT ( INOUT ) :: Flux_n1 !! The total flux from the previous time step TYPE ( Particle ), INTENT ( INOUT ) :: TraPar !! The particles information TYPE ( SolidObject ), INTENT ( IN ) :: BoomCase !! The Boom INTEGER ( kind = it4b ) :: i , j , ii , jj INTEGER * 8 :: A , parcsr_A , b , par_b , x , par_x , solver , precond INTEGER ( kind = it4b ), DIMENSION (:,:), allocatable :: MoParExIJU , MoParExIJV !! The indexes to indicate the position of particles in the velocity grid REAL ( KIND = dp ), DIMENSION (:,:,:), allocatable :: ConFluxEW , ConFluxNS !! The convective flux REAL ( KIND = dp ), DIMENSION (:,:,:), allocatable :: DifFluxEW , DifFluxNS !! The diffusive flux REAL ( KIND = dp ), DIMENSION (:,:,:), allocatable :: ExEDFluxEW , ExEDFluxNS , EDFluxEW , EDFluxNS !! The extra diffusive flux for cutcell REAL ( KIND = dp ), DIMENSION (:,:,:), allocatable :: CFluxEW , CFluxNS !! The density-based computation of the convective flux REAL ( KIND = dp ), DIMENSION (:,:,:), allocatable :: MaFluxEW , MaFluxNS !! The mass flux for density-based computation REAL ( KIND = dp ), DIMENSION (:,:,:), allocatable :: VofFluxEW , VofFluxNS !! The volume fraction flux REAL ( KIND = dp ), DIMENSION (:,:,:), allocatable :: MoParExCo !! The source term coefficient for coupling particles and fluid field REAL ( KIND = dp ), DIMENSION (:,:,:), allocatable :: FluxDiv !! The total divergent flux REAL ( KIND = dp ), DIMENSION (:,:,:), allocatable :: GradP !! The pressure gradient REAL ( KIND = dp ), DIMENSION (:,:), allocatable :: UFric , VFric !! The friction coefficient for velocities REAL ( KIND = dp ), DIMENSION (:,:), allocatable :: UWE , USN , VWE , VSN !! Boundary condition for implicit diffusive solver REAL ( KIND = dp ), DIMENSION (:,:,:), allocatable :: matr !! Parameter for checking whether solver give an acceptable result REAL ( KIND = dp ), DIMENSION (:,:), allocatable :: rhm !! Parameter for checking whether solver give an acceptable result REAL ( KIND = dp ), DIMENSION (:,:), allocatable :: Uro , Vro !! The mass inside velocity cell INTEGER ( kind = it4b ) :: num_iterations , Order2rd , Surface0 REAL ( KIND = dp ) :: final_res_norm REAL ( KIND = dp ) :: Fe , Fw , Fn , Fs , ExDe , ExDw , ExDn , ExDs REAL ( KIND = dp ) :: RoCeN , RoCeO , resi REAL ( KIND = dp ) :: BetaP , BetaM , BetaW , Lamda , Fluxn0 REAL ( KIND = dp ) :: nupp , ropp , ug , vg , Reyp , Cd , mp , tp , Vrel allocate ( MaFluxEW ( ibeg : Isize + 1 , jbeg : Jsize , 2 )) allocate ( MaFluxNS ( ibeg : Isize , jbeg : Jsize + 1 , 2 )) allocate ( VofFluxEW ( ibeg : Isize + 1 , jbeg : Jsize , 2 )) allocate ( VofFluxNS ( ibeg : Isize , jbeg : Jsize + 1 , 2 )) allocate ( CFluxEW ( ibeg : Isize + 1 , jbeg : Jsize , 2 )) allocate ( CFluxNS ( ibeg : Isize , jbeg : Jsize + 1 , 2 )) allocate ( ConFluxEW ( ibeg : Isize + 1 , jbeg : Jsize , 2 )) allocate ( ConFluxNS ( ibeg : Isize , jbeg : Jsize + 1 , 2 )) allocate ( DifFluxEW ( ibeg : ibeg + Isize , jbeg : jbeg + Jsize - 1 , 2 )) allocate ( DifFluxNS ( ibeg : ibeg + Isize - 1 , jbeg : jbeg + Jsize , 2 )) allocate ( EDFluxEW ( ibeg : ibeg + Isize , jbeg : jbeg + Jsize - 1 , 2 )) allocate ( EDFluxNS ( ibeg : ibeg + Isize - 1 , jbeg : jbeg + Jsize , 2 )) allocate ( ExEDFluxEW ( ibeg : ibeg + Isize , jbeg : jbeg + Jsize - 1 , 2 )) allocate ( ExEDFluxNS ( ibeg : ibeg + Isize - 1 , jbeg : jbeg + Jsize , 2 )) allocate ( FluxDiv ( ibeg : ibeg + Isize - 1 , jbeg : jbeg + Jsize - 1 , 2 )) allocate ( MoParExCo ( Isize , Jsize , 2 )) allocate ( MoParExIJU ( TraPar % np , 2 )) allocate ( MoParExIJV ( TraPar % np , 2 )) allocate ( GradP ( Isize , Jsize , 2 )) allocate ( UWE ( jbeg + Jsize - 1 , 2 )) allocate ( USN ( ibeg + Isize - 1 , 2 )) allocate ( VWE ( jbeg + Jsize - 1 , 2 )) allocate ( VSN ( ibeg + Isize - 1 , 2 )) allocate ( matr ( Isize , Jsize , 5 )) allocate ( rhm ( Isize , Jsize )) allocate ( Uro ( Isize , Jsize )) allocate ( Vro ( Isize , Jsize )) u => TVar % u v => TVar % v p => TVar % p Uvolf => UCellO % vof Vvolf => VCellO % vof ! Compute the density for velocity cells do i = 1 , Isize do j = 1 , Jsize Uro ( i , j ) = ( 1.d0 - Uvolf ( i , j ) - UCell % vofS ( i , j )) * roa / Roref + Uvolf ( i , j ) * & row / Roref Vro ( i , j ) = ( 1.d0 - Vvolf ( i , j ) - VCell % vofS ( i , j )) * roa / Roref + Vvolf ( i , j ) * & row / Roref end do end do ! Determine the position of particles do i = 1 , TraPar % np call ParticlePosition ( TraPar % Posp ( i ), UGrid , MoParExIJU ( i , 1 ), & MoParExIJU ( i , 2 )) call ParticlePosition ( TraPar % Posp ( i ), VGrid , MoParExIJV ( i , 1 ), & MoParExIJV ( i , 2 )) ! Check for whether particles position is correct. if (( MoParExIJU ( i , 1 ) ==- 1. or . MoParExIJU ( i , 2 ) ==- 1 ). and . & TraPar % Posp ( i )% x < 1.d2 ) then print * , itt print * , TraPar % Posp ( i )% x , TraPar % Posp ( i )% y print * , TraPar % dp ( i ) print * , print * , UGrid % x ( 1 , 1 ) - UGrid % dx ( 1 , 1 ) / 2.d0 print * , UGrid % x ( 1 , 1 ) + UGrid % dx ( 1 , 1 ) / 2.d0 print * , print * , TraPar % uvp ( i )% u , TraPar % uvp ( i )% v print * , 'problem with algorithm locating particles in UCell_PredictorUv_105' TraPar % uvp ( i )% u = UParInlet MoParExIJU ( i , 1 ) = MoParExIJU ( i - 1 , 1 ) MoParExIJU ( i , 2 ) = MoParExIJU ( i - 1 , 2 ) end if if (( MoParExIJV ( i , 1 ) ==- 1. or . MoParExIJV ( i , 2 ) ==- 1 ). and . & TraPar % Posp ( i )% x < 1.d2 ) then print * , itt print * , TraPar % Posp ( i )% x , TraPar % Posp ( i )% y print * , TraPar % dp ( i ) print * , VGrid % x ( 1 , 1 ) - VGrid % dx ( 1 , 1 ) / 2.d0 print * , VGrid % x ( 1 , 1 ) + VGrid % dx ( 1 , 1 ) / 2.d0 print * , 'problem with algorithm locating particles in VCell_PredictorUv_105' TraPar % uvp ( i )% u = UParInlet MoParExIJV ( i , 1 ) = MoParExIJV ( i - 1 , 1 ) MoParExIJV ( i , 2 ) = MoParExIJV ( i - 1 , 2 ) end if end do BetaP = 1.d0 / ( row / Roref ) BetaM = 1.d0 / ( roa / Roref ) ! Step 1: Calculate the convective flux if ( itt == 1 ) then call ModifiedConvectiveFlux ( PGrid , UGrid , VGrid , PCellO , UCellO , VCellO , & CFluxEW , BoomCase % vs , 1 , 0 ) call ModifiedConvectiveFlux ( PGrid , UGrid , VGrid , PCellO , UCellO , VCellO , & CFluxNS , BoomCase % vs , 0 , 1 ) else call HighOrderConvectiveFluxForXDir ( PGrid , UGrid , VGrid , UCellO , VCellO , & BoomCase % vs , CFluxEW ) call HighOrderConvectiveFluxForYDir ( PGrid , UGrid , VGrid , UCellO , VCellO , & BoomCase % vs , CFluxNS ) end if call FaceDensityFlux ( PGrid , UGrid , VGrid , PCellO , UCellO , VCellO , MaFluxEW , & VofFluxEW , BoomCase % vs , dt , 1 , 0 ) call FaceDensityFlux ( PGrid , UGrid , VGrid , PCellO , UCellO , VCellO , MaFluxNS , & VofFluxNS , BoomCase % vs , dt , 0 , 1 ) call DensityBasedConvectiveFlux ( PGrid , UGrid , VGrid , PCellO , UCellO , VCellO , & ConFluxEW , VofFluxEW , BoomCase % vs , 1 , 0 ) call DensityBasedConvectiveFlux ( PGrid , UGrid , VGrid , PCellO , UCellO , VCellO , & ConFluxNS , VofFluxNS , BoomCase % vs , 0 , 1 ) ! Step 2: Calculate the diffusive flux call DiffusiveFlux ( PGrid , UGrid , VGrid , PCellO , UCellO , VCellO , DifFluxEW , & EDFluxEW , ExEDFluxEW , BoomCase % vs , 1 , 0 ) call DiffusiveFlux ( PGrid , UGrid , VGrid , PCellO , UCellO , VCellO , DifFluxNS , & EDFluxNS , ExEDFluxNS , BoomCase % vs , 0 , 1 ) ! U Cell do i = 1 , Isize - 1 do j = 1 , Jsize GradP ( i , j , 1 ) = 0.d0 FluxDiv ( i , j , 1 ) = 0.d0 if ( UCell % Posnu ( i , j ) /=- 1 ) then Fe = ConFluxEW ( i + 1 , j , 1 ) Fw = ConFluxEW ( i , j , 1 ) Fn = ConFluxNS ( i , j + 1 , 1 ) Fs = ConFluxNS ( i , j , 1 ) RoCeO = ( 1.d0 - Uvolf ( i , j ) - UCell % vofS ( i , j )) * roa / Roref + Uvolf ( i , j ) * & row / Roref RoCeN = RoCeO - dt * ( MaFluxEW ( i + 1 , j , 1 ) - MaFluxEW ( i , j , 1 ) + & MaFluxNS ( i , j + 1 , 1 ) - MaFluxNS ( i , j , 1 )) / & ( UGrid % dx ( i , j ) * UGrid % dy ( i , j )) ! Compute the density-based convective flux if ( RoCeN > ( 1.d0 + epsi - UCell % vofS ( i , j )) * roa / Roref . and . & RoCeN < ( 1.d0 - epsi - UCell % vofS ( i , j )) * row / Roref . and . & RoCeO > ( 1.d0 + epsi - UCell % vofS ( i , j )) * roa / Roref . and . & RoCeO < ( 1.d0 - epsi - UCell % vofS ( i , j )) * row / Roref . and . & UCell % vofS ( i , j ) < epsi ) then Fluxn0 = ( Fe - Fw + Fn - Fs ) / RoCeN + u ( i , j ) * ( 1.d0 - RoCeO / RoCeN ) / dt * & UGrid % dx ( i , j ) * UGrid % dy ( i , j ) else Fluxn0 = ( CFluxEW ( i + 1 , j , 1 ) - CFluxEW ( i , j , 1 ) + CFluxNS ( i , j + 1 , 1 ) - & CFluxNS ( i , j , 1 )) / ( 1.d0 - UCell % vofS ( i , j )) end if Order2rd = 1 ! Apply second order scheme if ( itt > 1. and . Order2rd == 1 ) then FluxDiv ( i , j , 1 ) = 1.5d0 * Fluxn0 - 0.5d0 * Flux_n1 ( i , j , 1 ) else FluxDiv ( i , j , 1 ) = Fluxn0 end if ! For cell with all fluid faces equal to 0, set up fluxdiv=0. Surface0 = 0 if ( UCell % WEdge_Area ( i , j ) < epsi ) Surface0 = Surface0 + 1 if ( UCell % EEdge_Area ( i , j ) < epsi ) Surface0 = Surface0 + 1 if ( UCell % SEdge_Area ( i , j ) < epsi ) Surface0 = Surface0 + 1 if ( UCell % NEdge_Area ( i , j ) < epsi ) Surface0 = Surface0 + 1 if ( Surface0 >= 3 ) then Surface0 = 0 FluxDiv ( i , j , 1 ) = 0.d0 end if FluxDiv ( i , j , 1 ) = FluxDiv ( i , j , 1 ) - u ( i , j ) * ( 1.d0 - UCellO % vofS ( i , j )) / & ( 1.d0 - UCell % vofS ( i , j )) * UGrid % dx ( i , j ) * UGrid % dy ( i , j ) / dt Flux_n1 ( i , j , 1 ) = Fluxn0 end if end do end do ! Apply the mixing procedure call Mixing_Procedure ( UGrid , UCell , 1 , 0 , FluxDiv (:,:, 1 )) ! Add diffusive flux to divergent flux do i = 1 , Isize - 1 do j = 1 , Jsize if ( UCell % Posnu ( i , j ) /=- 1 ) then ExDe = ExEDFluxEW ( i + 1 , j , 1 ) ExDw = ExEDFluxEW ( i , j , 1 ) ExDn = ExEDFluxNS ( i , j + 1 , 1 ) ExDs = ExEDFluxNS ( i , j , 1 ) FluxDiv ( i , j , 1 ) = FluxDiv ( i , j , 1 ) - & BetaVis * (( DifFluxEW ( i + 1 , j , 1 ) * ( u ( i + 1 , j ) - u ( i , j )) - & DifFluxEW ( i , j , 1 ) * ( u ( i , j ) - u ( i - 1 , j ))) - & ( DifFluxNS ( i , j + 1 , 1 ) * ( u ( i , j + 1 ) - u ( i , j )) - & DifFluxNS ( i , j , 1 ) * ( u ( i , j ) - u ( i , j - 1 )))) / & ( 1.d0 - UCell % vofS ( i , j )) + & ( - ExDe + ExDw - ExDn + ExDs ) / ( 1.d0 - UCell % vofS ( i , j )) if ( isnan ( FluxDiv ( i , j , 1 )). or . dabs ( Fluxdiv ( i , j , 1 )) > 1.d10 ) then print * , 'Problem with U-Velocity' print * , itt print * , i , j print * , Pred % u ( i , j ), UCell % vofS ( i , j ) print * , 'flux' pause 'PredictorUV_156' end if end if end do end do ! Add pressure gradient (can be disable for some cases ) do i = ibeg , Isize + ibeg - 2 do j = jbeg , Jsize + jbeg - 1 if ( UCell % Posnu ( i , j ) /=- 1 ) then if (( PCellO % vof ( i , j ) >= 0.5d0 . and . PCellO % vofS ( i , j ) < epsi ). or . & ( PCellO % phi ( i , j ) < 0.d0 . and . PCellO % vofS ( i , j ) >= epsi )) then if (( PCellO % vof ( i + 1 , j ) < 0.5d0 . and . PCellO % vofS ( i + 1 , j ) < epsi ). or . & ( PCellO % phi ( i + 1 , j ) >= 0.d0 . and . PCellO % vofS ( i + 1 , j ) >= epsi )) then Lamda = dabs ( PCellO % phi ( i , j )) / ( dabs ( PCellO % phi ( i , j )) + & dabs ( PCellO % phi ( i + 1 , j )) + tol ) BetaW = Lamda * BetaM + ( 1.d0 - Lamda ) * BetaP GradP ( i , j , 1 ) = UGrid % dy ( i , j ) * ( p ( i + 1 , j ) - p ( i , j )) * BetaM * BetaP / BetaW else BetaW = BetaP GradP ( i , j , 1 ) = UGrid % dy ( i , j ) * ( p ( i + 1 , j ) - p ( i , j )) * BetaW end if else if (( PCellO % vof ( i + 1 , j ) >= 0.5d0 . and . PCellO % vofS ( i + 1 , j ) < epsi ). or . & ( PCellO % phi ( i + 1 , j ) < 0.d0 . and . PCellO % vofS ( i + 1 , j ) >= epsi )) then Lamda = dabs ( PCellO % phi ( i , j )) / ( dabs ( PCellO % phi ( i , j )) + & dabs ( PCellO % phi ( i + 1 , j )) + tol ) BetaW = Lamda * BetaP + ( 1.d0 - Lamda ) * BetaM GradP ( i , j , 1 ) = UGrid % dy ( i , j ) * ( p ( i + 1 , j ) - p ( i , j )) * BetaM * BetaP / BetaW else BetaW = BetaM GradP ( i , j , 1 ) = UGrid % dy ( i , j ) * ( p ( i + 1 , j ) - p ( i , j )) * BetaW end if end if ! Pressure gradient is disable Gradp ( i , j , 1 ) = 0.d0 FluxDiv ( i , j , 1 ) = FluxDiv ( i , j , 1 ) !+GradP(i,j,1) end if end do end do ! Add the particle momentum exchange to divergent flux for UCell do i = 1 , TraPar % np ii = MoParExIJU ( i , 1 ) jj = MoParExIJU ( i , 2 ) if ( ii /=- 1. and . jj /=- 1 ) then if ( UCell % vofS ( ii , jj ) < 1.d0 - epsi ) then nupp = nuw * UCell % vof ( ii , jj ) / ( 1.d0 - UCell % vofS ( ii , jj )) + & nua * ( 1.d0 - UCell % vof ( ii , jj ) - UCell % vofS ( ii , jj )) / & ( 1.d0 - UCell % vofS ( ii , jj )) ropp = row * UCell % vof ( ii , jj ) / ( 1.d0 - UCell % vofS ( ii , jj )) + & roa * ( 1.d0 - UCell % vof ( ii , jj ) - UCell % vofS ( ii , jj )) / & ( 1.d0 - UCell % vofS ( ii , jj )) mp = Rop * 1.d0 / 6.d0 * pi * TraPar % dp ( i ) ** 3.d0 ug = TVar % u ( ii , jj ) vg = TVar % v ( ii , jj ) VRel = dsqrt (( TraPar % uvp ( i )% u - ug ) ** 2.d0 + ( TraPar % uvp ( i )% v - vg ) ** 2.d0 ) if ( VRel < 1.d-7 ) VRel = 1.d-7 Reyp = TraPar % dp ( i ) * VRel / nupp Cd = Drag ( Reyp ) tp = 4.d0 / 3.d0 * TraPar % dp ( i ) * rop / ropp / Cd fluxDiv ( ii , jj , 1 ) = fluxDiv ( ii , jj , 1 ) + mp / tp * TraPar % uvp ( i )% u * VRel / & ( TVar % Roref * TVar % Uref ** 2.d0 / UGrid % Lref ) / zp / Uro ( ii , jj ) MoParExCo ( ii , jj , 1 ) = MoParExCo ( ii , jj , 1 ) + mp / tp * VRel / & ( TVar % Roref * TVar % Uref / UGrid % Lref ) / zp / Uro ( ii , jj ) end if end if end do ! V-Cell do i = 1 , Isize do j = 1 , Jsize - 1 FluxDiv ( i , j , 2 ) = 0.d0 if ( VCell % Posnu ( i , j ) /=- 1 ) then Fe = ConFluxEW ( i + 1 , j , 2 ) Fw = ConFluxEW ( i , j , 2 ) Fn = ConFluxNS ( i , j + 1 , 2 ) Fs = ConFluxNS ( i , j , 2 ) RoCeO = ( 1.d0 - Vvolf ( i , j ) - VCell % vofS ( i , j )) * roa / Roref + Vvolf ( i , j ) * & row / Roref RoCeN = RoCeO - dt * ( MaFluxEW ( i + 1 , j , 2 ) - MaFluxEW ( i , j , 2 ) + & MaFluxNS ( i , j + 1 , 2 ) - MaFluxNS ( i , j , 2 )) / & ( VGrid % dx ( i , j ) * VGrid % dy ( i , j )) if ( RoCeN > ( 1.d0 + epsi - VCell % vofS ( i , j )) * roa / Roref . and . & RoCeN < ( 1.d0 - epsi - VCell % vofS ( i , j )) * row / Roref . and . & RoCeO > ( 1.d0 + epsi - VCell % vofS ( i , j )) * roa / Roref . and . & RoCeO < ( 1.d0 - epsi - VCell % vofS ( i , j )) * row / Roref . and . & VCell % vofS ( i , j ) < epsi ) then Fluxn0 = ( Fe - Fw + Fn - Fs ) / RoCeN + v ( i , j ) * ( 1.d0 - RoCeO / RoCeN ) / dt * & VGrid % dx ( i , j ) * VGrid % dy ( i , j ) else Fluxn0 = ( CFluxEW ( i + 1 , j , 2 ) - CFluxEW ( i , j , 2 ) + CFluxNS ( i , j + 1 , 2 ) - & CFluxNS ( i , j , 2 )) / ( 1.d0 - VCell % VofS ( i , j )) end if if ((( RoCeN > ( 1.d0 + epsi - VCell % vofS ( i , j )) * roa / Roref . and . & RoCeN < ( 1.d0 - epsi - VCell % vofS ( i , j )) * row / Roref . and . & RoCeO > ( 1.d0 + epsi - VCell % vofS ( i , j )) * roa / Roref . and . & RoCeO < ( 1.d0 - epsi - VCell % vofS ( i , j )) * row / Roref . and . & VCell % vofS ( i , j ) < epsi ). or . & RoCeN < ( 1.d0 + epsi - VCell % vofS ( i , j )) * roa / Roref . or . & RoCeN > ( 1.d0 - epsi - VCell % vofS ( i , j )) * row / Roref )) then Order2rd = 1 else Order2rd = 0 end if Order2rd = 1 ! V Cell if ( itt > 1. and . Order2rd == 1 ) then FluxDiv ( i , j , 2 ) = 1.5d0 * Fluxn0 - 0.5d0 * Flux_n1 ( i , j , 2 ) else FluxDiv ( i , j , 2 ) = Fluxn0 end if Surface0 = 0 if ( VCell % WEdge_Area ( i , j ) < epsi ) Surface0 = Surface0 + 1 if ( VCell % EEdge_Area ( i , j ) < epsi ) Surface0 = Surface0 + 1 if ( VCell % SEdge_Area ( i , j ) < epsi ) Surface0 = Surface0 + 1 if ( VCell % NEdge_Area ( i , j ) < epsi ) Surface0 = Surface0 + 1 if ( Surface0 >= 3 ) then Surface0 = 0 FluxDiv ( i , j , 2 ) = 0.d0 end if FluxDiv ( i , j , 2 ) = FluxDiv ( i , j , 2 ) - v ( i , j ) * ( 1.d0 - VCellO % VofS ( i , j )) / & ( 1.d0 - VCell % VofS ( i , j )) * VGrid % dx ( i , j ) * VGrid % dy ( i , j ) / dt Flux_n1 ( i , j , 2 ) = Fluxn0 end if end do end do call Mixing_Procedure ( VGrid , VCell , 0 , 1 , FluxDiv (:,:, 2 )) do i = 1 , Isize do j = 1 , Jsize - 1 if ( VCell % Posnu ( i , j ) /=- 1 ) then ExDe = ExEDFluxEW ( i + 1 , j , 2 ) ExDw = ExEDFluxEW ( i , j , 2 ) ExDn = ExEDFluxNS ( i , j + 1 , 2 ) ExDs = ExEDFluxNS ( i , j , 2 ) FluxDiv ( i , j , 2 ) = FluxDiv ( i , j , 2 ) - & BetaVis * (( DifFluxEW ( i + 1 , j , 2 ) * ( v ( i + 1 , j ) - v ( i , j )) - & DifFluxEW ( i , j , 2 ) * ( v ( i , j ) - v ( i - 1 , j ))) - & ( DifFluxNS ( i , j + 1 , 2 ) * ( v ( i , j + 1 ) - v ( i , j )) - & DifFluxNS ( i , j , 2 ) * ( v ( i , j ) - v ( i , j - 1 )))) / & ( 1.d0 - VCell % vofS ( i , j )) + & ( - ExDe + ExDw - ExDn + ExDs ) / ( 1.d0 - VCell % vofS ( i , j )) if ( VCell % VofS ( i , j ) > epsi . and . VCell % VofS ( i , j ) < 1.d0 - epsi ) then !*dabs(VCell%nx(i,j)) FluxDiv ( i , j , 2 ) = FluxDiv ( i , j , 2 ) - (( 1.d0 - VCell % vof ( i , j ) / & ( 1.d0 - VCell % vofS ( i , j ))) * nua / nuref + VCell % vof ( i , j ) / & ( 1.d0 - VCell % vofS ( i , j )) * nuw / nuref ) / Rey * & VCell % WlLh ( i , j ) / VCell % delh ( i , j ) * BoomCase % vs end if if ( isnan ( FluxDiv ( i , j , 2 )). or . dabs ( Fluxdiv ( i , j , 2 )) > 1.d20 ) then print * , 'Problem with V-Velocity' print * , itt print * , i , j print * , VCell % vofS ( i , j ) print * , VCell % Posnu ( i , j ) print * , print * , FluxDiv ( i , j , 2 ) pause 'PredictorUV_218' end if end if end do end do do i = 1 , Isize do j = 1 , Jsize - 1 if ( VCell % Posnu ( i , j ) /=- 1 ) then ! Add pressure gradient if (( PCellO % vof ( i , j ) >= 0.5d0 . and . PCellO % vofS ( i , j ) < epsi ). or . & ( PCellO % phi ( i , j ) < 0.d0 . and . PCellO % vofS ( i , j ) >= epsi )) then if (( PCellO % vof ( i , j + 1 ) < 0.5d0 . and . PCellO % vofS ( i , j + 1 ) < epsi ). or . & ( PCellO % phi ( i , j + 1 ) >= 0.d0 . and . PCellO % vofS ( i , j + 1 ) >= epsi )) then Lamda = dabs ( PCellO % phi ( i , j )) / ( dabs ( PCellO % phi ( i , j )) + & dabs ( PCellO % phi ( i , j + 1 )) + tol ) BetaW = Lamda * BetaM + ( 1.d0 - Lamda ) * BetaP GradP ( i , j , 2 ) = VGrid % dx ( i , j ) * ( p ( i , j + 1 ) - p ( i , j )) * BetaP * BetaM / BetaW else BetaW = BetaP GradP ( i , j , 2 ) = VGrid % dx ( i , j ) * ( p ( i , j + 1 ) - p ( i , j )) * BetaW end if else if (( PCellO % vof ( i , j + 1 ) >= 0.5d0 . and . PCellO % vofS ( i , j + 1 ) < epsi ). or . & ( PCellO % phi ( i , j + 1 ) < 0.d0 . and . PCellO % vofS ( i , j + 1 ) >= epsi )) then Lamda = dabs ( PCellO % phi ( i , j )) / ( dabs ( PCellO % phi ( i , j )) + & dabs ( PCellO % phi ( i , j + 1 )) + tol ) BetaW = Lamda * BetaP + ( 1.d0 - Lamda ) * BetaM GradP ( i , j , 2 ) = VGrid % dx ( i , j ) * ( p ( i , j + 1 ) - p ( i , j )) * BetaP * BetaM / BetaW else BetaW = BetaM GradP ( i , j , 2 ) = VGrid % dx ( i , j ) * ( p ( i , j + 1 ) - p ( i , j )) * BetaW end if end if GradP ( i , j , 2 ) = 0.d0 FluxDiv ( i , j , 2 ) = FluxDiv ( i , j , 2 ) !+GradP(i,j,2)            ! Contribution of pressure gradient end if end do end do ! Add the particle momentum exchange to flux difference for UCell do i = 1 , TraPar % np ii = MoParExIJU ( i , 1 ) jj = MoParExIJU ( i , 2 ) if ( ii /=- 1. and . jj /=- 1 ) then if ( VCell % vofS ( ii , jj ) < 1.d0 - epsi ) then nupp = nuw * VCell % vof ( ii , jj ) / ( 1.d0 - VCell % vofS ( ii , jj )) + & nua * ( 1.d0 - VCell % vof ( ii , jj ) - VCell % vofS ( ii , jj )) / & ( 1.d0 - VCell % vofS ( ii , jj )) ropp = row * VCell % vof ( ii , jj ) / ( 1.d0 - VCell % vofS ( ii , jj )) + & roa * ( 1.d0 - VCell % vof ( ii , jj ) - VCell % vofS ( ii , jj )) / ( 1.d0 - VCell % vofS ( ii , jj )) mp = Rop * 1.d0 / 6.d0 * pi * TraPar % dp ( i ) ** 3.d0 ug = TVar % u ( ii , jj ) vg = TVar % v ( ii , jj ) VRel = dsqrt (( TraPar % uvp ( i )% u - ug ) ** 2.d0 + ( TraPar % uvp ( i )% v - vg ) ** 2.d0 ) if ( VRel < 1.d-7 ) VRel = 1.d-7 Reyp = TraPar % dp ( i ) * VRel / nupp Cd = Drag ( Reyp ) tp = 4.d0 / 3.d0 * TraPar % dp ( i ) * rop / ropp / Cd FluxDiv ( ii , jj , 2 ) = FluxDiv ( ii , jj , 2 ) + mp / tp * TraPar % uvp ( i )% v * VRel / & ( TVar % Roref * TVar % Uref ** 2.d0 / VGrid % Lref ) / zp / Vro ( ii , jj ) MoParExCo ( ii , jj , 2 ) = MoParExCo ( ii , jj , 2 ) + mp / tp * VRel / ( TVar % Roref * & TVar % Uref / VGrid % Lref ) / zp / Vro ( ii , jj ) if ( dabs ( MoParExco ( ii , jj , 2 )) > 1.d10 . or . isnan ( fluxDiv ( ii , jj , 2 )). or . & isnan ( MoParExco ( ii , jj , 2 ))) then print * , fluxDiv ( ii , jj , 2 ) print * , 'Particle problem' print * , tp print * , TraPar % mp ( i ), TraPar % tp ( i ) print * , MoParExco ( ii , jj , 2 ) print * , TraPar % mp ( i ) / TraPar % tp ( i ) * TraPar % uvp ( i )% v * TraPar % VRelG ( i ) / & ( TVar % Roref * TVar % Uref ** 2.d0 / VGrid % Lref ) / zp / Vro ( ii , jj ) print * , TraPar % mp ( i ) / TraPar % tp ( i ) / TraPar % VRelG ( i ) / & ( TVar % Roref * TVar % Uref / VGrid % Lref ) / zp / Vro ( ii , jj ) print * , print * , TraPar % mp ( i ), TraPar % tp ( i ), TraPar % VRelG ( i ) print * , TVar % Roref * TVar % Uref / VGrid % Lref , zp , Vro ( ii , jj ) pause 'Momentum Particle 425' end if end if end if end do ! Solving for UCell (implicit diffusive flux) nullify ( Uvolf , Vvolf ) Uvolf => UCell % vof Vvolf => VCell % vof call DiffusiveFlux ( PGrid , UGrid , VGrid , PCell , UCell , VCell , DifFluxEW , & EDFluxEW , ExEDfluxEW , BoomCase % vs , 1 , 0 ) call DiffusiveFlux ( PGrid , UGrid , VGrid , PCell , UCell , VCell , DifFluxNS , & EDFluxNS , ExEDfluxEW , BoomCase % vs , 0 , 1 ) nullify ( Uvolf , Vvolf ) call SetBasicSolver ( solver , precond ) call SetMatrix ( A , parcsr_A , UGrid , UCell , DifFluxEW , DifFluxNS , EDFluxEW , & EDFluxNS , PU , UWE , USN , matr , itt , dt , 1 , 0 ) call SetVectors ( b , x , par_b , par_x , PGrid , UGrid , UCell , UWE , USN , FluxDiv (:,:, 1 ),& rhm , dt , 1 , 0 ) call HYPRE_ParCSRPCGSetup ( solver , parcsr_A , par_b , par_x , ierr ) call HYPRE_ParCSRPCGSolve ( solver , parcsr_A , par_b , par_x , ierr ) ! Run info - needed logging turned on call HYPRE_ParCSRPCGGetNumIterations ( solver , num_iterations , ierr ) call HYPRE_ParCSRPCGGetFinalRelative ( solver , final_res_norm , ierr ) call DeltaGetValues ( x , UCell , Pred % u , 1 , 0 ) ! Compute predicted u do i = 1 , Isize - 1 do j = 1 , Jsize Pred % u ( i , j ) = Pred % u ( i , j ) + dt * GradP ( i , j , 1 ) / UGrid % dx ( i , j ) / UGrid % dy ( i , j ) end do end do call HYPRE_IJMatrixDestroy ( A , ierr ) call HYPRE_IJVectorDestroy ( b , ierr ) call HYPRE_IJVectorDestroy ( x , ierr ) call HYPRE_BoomerAMGDestroy ( precond , ierr ) call HYPRE_ParCSRPCGDestroy ( solver , ierr ) ! VCell call SetBasicSolver ( solver , precond ) call SetMatrix ( A , parcsr_A , VGrid , VCell , DifFluxEW , DifFluxNS , EDFluxEW , & EDFluxNS , PV , VWE , VSN , matr , itt , dt , 0 , 1 ) call SetVectors ( b , x , par_b , par_x , PGrid , VGrid , VCell , VWE , VSN , FluxDiv (:,:, 2 ),& rhm , dt , 0 , 1 ) call HYPRE_ParCSRPCGSetup ( solver , parcsr_A , par_b , par_x , ierr ) call HYPRE_ParCSRPCGSolve ( solver , parcsr_A , par_b , par_x , ierr ) ! Run info - needed logging turned on call HYPRE_ParCSRPCGGetNumIterations ( solver , num_iterations , ierr ) call HYPRE_ParCSRPCGGetFinalRelative ( solver , final_res_norm , ierr ) call DeltaGetValues ( x , VCell , Pred % v , 0 , 1 ) ! Compute predicted v do i = 1 , Isize do j = 1 , Jsize - 1 Pred % v ( i , j ) = Pred % v ( i , j ) + dt * GradP ( i , j , 2 ) / VGrid % dx ( i , j ) / VGrid % dy ( i , j ) end do end do call HYPRE_IJMatrixDestroy ( A , ierr ) call HYPRE_IJVectorDestroy ( b , ierr ) call HYPRE_IJVectorDestroy ( x , ierr ) call HYPRE_BoomerAMGDestroy ( precond , ierr ) call HYPRE_ParCSRPCGDestroy ( solver , ierr ) PU % Dp ( ibeg - ight ,:) = PU % Dp ( ibeg ,:) PU % Dp ( ibeg + Isize - 1 ,:) = PU % Dp ( ibeg + Isize - 2 ,:) PU % Dp ( ibeg + Isize - 1 + ight ,:) = PU % Dp ( ibeg + Isize - 1 ,:) PU % Dp (:, jbeg - jght ) = PU % Dp (:, jbeg ) PU % Dp (:, jbeg + Jsize - 1 + jght ) = PU % Dp (:, jbeg + Jsize - 1 ) PV % Dp ( ibeg - ight ,:) = PV % Dp ( ibeg ,:) PV % Dp ( ibeg + Isize - 1 + ight ,:) = PV % Dp ( ibeg + Isize - 1 ,:) PV % Dp (:, jbeg - jght ) = PV % Dp (:, jbeg ) PV % Dp (:, jbeg + Jsize - 1 ) = PV % Dp (:, jbeg + Jsize - 2 ) PV % Dp (:, jbeg + Jsize - 1 + jght ) = PV % Dp (:, jbeg + Jsize - 1 ) call PredictorVelocityBoundaryCondition ( Pred , TVar ) deallocate ( Uro , Vro ) deallocate ( MaFluxEW ) deallocate ( MaFluxNS ) deallocate ( VofFluxEW ) deallocate ( VofFluxNS ) deallocate ( CFluxEW ) deallocate ( CFluxNS ) deallocate ( ConFluxEW ) deallocate ( ConFluxNS ) deallocate ( DifFluxEW , EDFluxEW , ExEDFluxEW ) deallocate ( DifFluxNS , EDFluxNS , ExEDFluxNS ) deallocate ( UWE ) deallocate ( USN ) deallocate ( VWE ) deallocate ( VSN ) deallocate ( FluxDiv ) deallocate ( GradP ) deallocate ( matr , rhm ) nullify ( u ) nullify ( v ) nullify ( p ) End subroutine Predictor_UV Subroutine SetBasicSolver ( solver , precond ) !! The subroutine set up methods for HYPRE solver IMPLICIT NONE INTEGER * 8 , INTENT ( INOUT ) :: solver INTEGER * 8 , INTENT ( INOUT ), optional :: precond ! Set up and use a solver Call HYPRE_ParCSRPCGCreate ( MPI_COMM_WORLD , solver , ierr ) ! Set some PARAMETERs Call HYPRE_ParCSRPCGSetMaxIter ( solver , 50 , ierr ) Call HYPRE_ParCSRPCGSetTol ( solver , 1.0d-20 , ierr ) Call HYPRE_ParCSRPCGSetTwoNorm ( solver , 0 , ierr ) ! Call HYPRE_ParCSRPCGSetPrintLevel(solver,2,ierr) Call HYPRE_ParCSRPCGSetLogging ( solver , 1 , ierr ) ! Now set up the AMG preconditioner and specify any PARAMETERs If ( present ( precond )) then Call HYPRE_BoomerAMGCreate ( precond , ierr ) ! Set some PARAMETERs ! Print less solver info since a preconditioner ! Call HYPRE_BoomerAMGSetPrintLevel(precond,1,ierr); ! Falgout coarsening Call HYPRE_BoomerAMGSetCoarsenTYPE ( precond , 6 , ierr ) ! SYMMETRIC G-S/Jacobi hybrid relaxation Call HYPRE_BoomerAMGSetRelaxTYPE ( precond , 6 , ierr ) ! Sweeeps on each level Call HYPRE_BoomerAMGSetNumSweeps ( precond , 1 , ierr ) ! conv. tolerance Call HYPRE_BoomerAMGSetTol ( precond , 0.0d0 , ierr ) ! do only one iteration! Call HYPRE_BoomerAMGSetMaxIter ( precond , 1 , ierr ) ! set amg as the pcg preconditioner ! precond_id = 2 Call HYPRE_ParCSRPCGSetPrecond ( solver , 2 , precond , ierr ) End if End subroutine SetBasicSolver subroutine SetMatrix ( A , parcsr_A , TGrid , TCell , DifFluxEW , DifFluxNS , EDFluxEW , & EDFluxNS , PUV , CWE , CSN , matr , itt , dt , iu , iv ) !! The subroutine set up the matrix for HYPRE IMPLICIT NONE INTEGER * 8 , INTENT ( INOUT ) :: A , parcsr_A !! An ID for matrix TYPE ( Grid ), INTENT ( IN ) :: TGrid !! The grid TYPE ( Cell ), INTENT ( IN ) :: TCell !! The cell INTEGER ( kind = it8b ), INTENT ( IN ) :: itt !! The iteration step REAL ( KIND = dp ), INTENT ( IN ) :: dt !! The time step REAL ( KIND = dp ), DIMENSION (:,:,:), allocatable , INTENT ( IN ) :: DifFluxEW , & DifFluxNS , EDFluxEW , EDFluxNS !! The diffusive flux coefficient TYPE ( PoissonCoefficient ), INTENT ( INOUT ) :: PUV !! The cofficient from predicted step REAL ( KIND = dp ), DIMENSION (:,:), allocatable , INTENT ( INOUT ) :: CWE , CSN !! The boundary condition REAL ( KIND = dp ), DIMENSION (:,:,:), allocatable , INTENT ( INOUT ) :: matr !! The matrix for testing solver INTEGER , INTENT ( IN ) :: iu , iv !! The input number to determine this subroutine is applied for x or y direction INTEGER ( kind = it4b ) :: nnz , ictr , ilower , iupper , cols ( 0 : 4 ) INTEGER ( kind = it4b ) :: i , j REAL ( KIND = dp ) :: aP , aE , aW , aN , aS , De , Dw , Dn , Ds , Sp , VofAF REAL ( KIND = dp ) :: Fe , Fw , Fn , Fs , Fep , Fem , Fwp , Fwm , Fnp , Fnm , Fsp , Fsm REAL ( KIND = dp ) :: values ( 0 : 4 ) ilower = 0 iupper = TCell % ExtCell ! Create and Set up matrix call HYPRE_IJMatrixCreate ( MPI_COMM_WORLD , ilower , iupper , ilower , iupper , & A , ierr ) call HYPRE_IJMatrixSetObjectTYPE ( A , HYPRE_PARCSR , ierr ) call HYPRE_IJMatrixInitialize ( A , ierr ) do i = ibeg , Isize - iu do j = jbeg , Jsize - iv if ( TCell % Posnu ( i , j ) /=- 1 ) then matr ( i , j ,:) = 0.d0 VofAF = 1.d0 - TCell % vofS ( i , j ) De = 0.d0 ; Dw = 0.d0 ; Dn = 0.d0 ; Ds = 0.d0 if ( iu == 1 ) then ! for UCell ! Coefficient for diffusive flux De = ( 1.d0 - BetaVis ) * DifFluxEW ( i + 1 , j , 1 ) / VofAF Dw = ( 1.d0 - BetaVis ) * DifFluxEW ( i , j , 1 ) / VofAF Dn = ( 1.d0 - BetaVis ) * DifFluxNS ( i , j + 1 , 1 ) / VofAF Ds = ( 1.d0 - BetaVis ) * DifFluxNS ( i , j , 1 ) / VofAF ! Coefficient for extra diffusive flux Fep = EDfluxEW ( i + 1 , j , 1 ) * ( 1.d0 - TCell % EtaE ( i , j )) / VofAF Fem = EDfluxEW ( i + 1 , j , 1 ) * TCell % EtaE ( i , j ) / VofAF Fwp = EDfluxEW ( i , j , 1 ) * TCell % EtaE ( i - 1 , j ) / VofAF Fwm = EDfluxEW ( i , j , 1 ) * ( 1.d0 - TCell % EtaE ( i - 1 , j )) / VofAF Fnp = EDfluxNS ( i , j + 1 , 1 ) * ( 1.d0 - TCell % EtaN ( i , j )) / VofAF Fnm = EDfluxNS ( i , j + 1 , 1 ) * TCell % EtaN ( i , j ) / VofAF Fsp = EDfluxNS ( i , j , 1 ) * TCell % EtaN ( i , j - 1 ) / VofAF Fsm = EDfluxNS ( i , j , 1 ) * ( 1.d0 - TCell % EtaN ( i , j - 1 )) / VofAF if ( j == Jsize ) Dn = 0.d0 if ( i == Isize - iu ) De = 0.d0 if ( i == ibeg ) Dw = 0.d0 elseif ( iv == 1 ) then ! for VCell De = ( 1.d0 - BetaVis ) * DifFluxEW ( i + 1 , j , 2 ) / VofAF Dw = ( 1.d0 - BetaVis ) * DifFluxEW ( i , j , 2 ) / VofAF Dn = ( 1.d0 - BetaVis ) * DifFluxNS ( i , j + 1 , 2 ) / VofAF Ds = ( 1.d0 - BetaVis ) * DifFluxNS ( i , j , 2 ) / VofAF Fep = EDfluxEW ( i + 1 , j , 2 ) * ( 1.d0 - TCell % EtaE ( i , j )) / VofAF Fem = EDfluxEW ( i + 1 , j , 2 ) * TCell % EtaE ( i , j ) / VofAF Fwp = EDfluxEW ( i , j , 2 ) * TCell % EtaE ( i - 1 , j ) / VofAF Fwm = EDfluxEW ( i , j , 2 ) * ( 1.d0 - TCell % EtaE ( i - 1 , j )) / VofAF Fnp = EDfluxNS ( i , j + 1 , 2 ) * ( 1.d0 - TCell % EtaN ( i , j )) / VofAF Fnm = EDfluxNS ( i , j + 1 , 2 ) * TCell % EtaN ( i , j ) / VofAF Fsp = EDfluxNS ( i , j , 2 ) * TCell % EtaN ( i , j - 1 ) / VofAF Fsm = EDfluxNS ( i , j , 2 ) * ( 1.d0 - TCell % EtaN ( i , j - 1 )) / VofAF if ( j == Jsize - iv ) Dn = 0.d0 end if aE = De ; aW = Dw ; aN = Dn ; aS = Ds ! Set up coefficient for boundary if ( i == ibeg ) CWE ( j , 1 ) = aW if ( i == Isize - iu ) CWE ( j , 2 ) = aE if ( j == jbeg ) CSN ( i , 1 ) = aS if ( j == Jsize - iv ) CSN ( i , 2 ) = aN aP = TGrid % dx ( i , j ) * TGrid % dy ( i , j ) / dt + aE + aW + aN + aS + & (( 1.d0 - TCell % vof ( i , j ) / ( 1.d0 - TCell % vofS ( i , j ))) * nua / nuref + & TCell % vof ( i , j ) / ( 1.d0 - TCell % vofS ( i , j )) * nuw / nuref ) / Rey * & TCell % WlLh ( i , j ) / TCell % delh ( i , j ) / VofAF aP = aP + Fep - Fwp + Fnp - Fsp aE = aE - Fem aW = aW + Fwm aN = aN - Fnm aS = aS + Fsm ! PUV%Dp(i,j)=dt !1.d0/(aP-aE-aW-aN-aS) PUV % Dp ( i , j ) = TGrid % dx ( i , j ) * TGrid % dy ( i , j ) / ( aP - aE - aW - aN - aS ) ictr = TCell % Posnu ( i , j ) nnz = 0 values = 0.d0 cols = 0 ! Bottom of current cell if ( j > jbeg ) then if ( TCell % Posnu ( i , j - 1 ) /=- 1 ) then cols ( nnz ) = TCell % Posnu ( i , j - 1 ) values ( nnz ) =- aS matr ( i , j , 1 ) = values ( nnz ) nnz = nnz + 1 end if end if ! West of current cell if ( i > ibeg ) then if ( TCell % Posnu ( i - 1 , j ) /=- 1 ) then cols ( nnz ) = TCell % Posnu ( i - 1 , j ) values ( nnz ) =- aW matr ( i , j , 2 ) = values ( nnz ) nnz = nnz + 1 end if end if ! Set the diagonal cell cols ( nnz ) = TCell % Posnu ( i , j ) values ( nnz ) = aP if ( isnan ( values ( nnz )). or . dabs ( values ( nnz )) > 1.d20 ) then print * , i , j , values ( nnz ) print * , iu print * , print * , aE , aW print * , aN , aS print * , print * , Dn , Fnm print * , DifFluxNS ( i , j + 1 , 1 ) print * , 'test UVCell' print * , TCell % SyN ( i , j ), TCell % SyN ( i , j + 1 ), TCell % SyN ( i , j - 1 ) print * , TCell % Cell_Cent ( i , j , 2 ), TCell % Cell_Cent ( i , j + 1 , 2 ), TCell % Cell_Cent ( i , j - 1 , 2 ) print * , print * , Sp pause 'predictoruv_760' end if matr ( i , j , 3 ) = values ( nnz ) nnz = nnz + 1 ! East of current cell if ( i < Isize ) then if ( TCell % Posnu ( i + 1 , j ) /=- 1 ) then cols ( nnz ) = TCell % Posnu ( i + 1 , j ) values ( nnz ) = - aE matr ( i , j , 4 ) = values ( nnz ) nnz = nnz + 1 end if end if ! North of current cell if ( j < Jsize ) then if ( TCell % Posnu ( i , j + 1 ) /=- 1 ) then cols ( nnz ) = TCell % Posnu ( i , j + 1 ) values ( nnz ) = - aN matr ( i , j , 5 ) = values ( nnz ) nnz = nnz + 1 end if end if call HYPRE_IJMatrixSetValues ( A , 1 , nnz , ictr , cols , values , ierr ) end if end do end do call HYPRE_IJMatrixAssemble ( A , ierr ) call HYPRE_IJMatrixGetObject ( A , parcsr_A , ierr ) end subroutine SetMatrix subroutine SetVectors ( b , x , par_b , par_x , PGrid , TGrid , TCell , CWE , CSN , IJFlux , & rhm , dt , iu , iv ) !! The subroutine set up a right hand side vector for HYPRE solver INTEGER * 8 , INTENT ( IN ) :: b , x , par_b , par_x !! The ID for vector INTEGER , INTENT ( IN ) :: iu , iv !! The input number to determine this subroutine is applied for x or y direction TYPE ( Grid ), INTENT ( IN ) :: PGrid , TGrid !! The grid TYPE ( Cell ), INTENT ( IN ) :: TCell !! The cell REAL ( KIND = dp ), DIMENSION (:,:), allocatable , INTENT ( IN ) :: CWE , CSN !! The boundary condition REAL ( KIND = dp ), DIMENSION (:,:), INTENT ( IN ) :: IJFlux !! The total flux which is set to be right hand side vector REAL ( KIND = dp ), DIMENSION (:,:), INTENT ( INOUT ) :: rhm !! The output right hand side vector which is used for checking solver real ( dp ), INTENT ( IN ) :: dt !! The time step INTEGER ( kind = it4b ) :: i , j INTEGER :: ilower , iupper , ictr , local_size INTEGER ( kind = it4b ), DIMENSION (:), allocatable :: rows REAL ( KIND = dp ), DIMENSION (:), allocatable :: rhs , xval REAL ( KIND = dp ) :: BetaP , BetaM , BetaW , Lamda BetaP = 1.d0 / ( row / Roref ) BetaM = 1.d0 / ( roa / Roref ) ilower = 0 iupper = TCell % ExtCell local_size = iupper - ilower + 1 ! the number of rows ! In here, we apply boundary condition for deltaP with its values is 0 at ! all boundary. therefore, we do not need to set boundary in vector b allocate ( rhs ( 0 : TCell % ExtCell )) allocate ( xval ( 0 : TCell % ExtCell )) allocate ( rows ( 0 : TCell % ExtCell )) call HYPRE_IJVectorCreate ( MPI_COMM_WORLD , ilower , iupper , b , ierr ) call HYPRE_IJVectorSetObjectTYPE ( b , HYPRE_PARCSR , ierr ) call HYPRE_IJVectorInitialize ( b , ierr ) call HYPRE_IJVectorCreate ( MPI_COMM_WORLD , ilower , iupper , x , ierr ) call HYPRE_IJVectorSetObjectTYPE ( x , HYPRE_PARCSR , ierr ) call HYPRE_IJVectorInitialize ( x , ierr ) rhs (:) = 0.d0 do i = ibeg , Isize - iu do j = jbeg , Jsize - iv ictr = TCell % PosNu ( i , j ) rhm ( i , j ) = 0.d0 if ( ictr /=- 1 ) then if ( iu == 1 ) then ! rhs(ictr)=u(i,j)*TGrid%dx(i,j)*TGrid%dy(i,j)/dt     ! Contribution of velocity at old time-step rhs ( ictr ) = rhs ( ictr ) - IJFlux ( i , j ) ! Convective flux else ! rhs(ictr)=v(i,j)*TGrid%dx(i,j)*TGrid%dy(i,j)/dt     ! Contribution of velocity at old time-step rhs ( ictr ) = rhs ( ictr ) - IJFlux ( i , j ) ! Contribution of convective term ! Contribution of gravity (should test again 05/10/2017 Contribution of volume flux) rhs ( ictr ) = rhs ( ictr ) - 1.d0 / Fr ** 2.d0 * TGrid % dx ( i , j ) * TGrid % dy ( i , j ) end if if ( i == ibeg ) rhs ( ictr ) = rhs ( ictr ) + CWE ( j , 1 ) * ( dble ( iu ) * u ( i - 1 , j ) + & dble ( iv ) * v ( i - 1 , j )) if ( i == Isize - iu ) rhs ( ictr ) = rhs ( ictr ) + CWE ( j , 2 ) * ( dble ( iu ) * u ( i + 1 , j ) + & dble ( iv ) * v ( i + 1 , j )) if ( j == jbeg ) rhs ( ictr ) = rhs ( ictr ) + CSN ( i , 1 ) * ( dble ( iu ) * u ( i , j - 1 ) + & dble ( iv ) * v ( i , j - 1 )) if ( j == Jsize - iv ) rhs ( ictr ) = rhs ( ictr ) + CSN ( j , 2 ) * ( dble ( iu ) * u ( i , j + 1 ) + & dble ( iv ) * v ( i , j + 1 )) if ( isnan ( rhs ( ictr )). or . dabs ( rhs ( ictr )) > 1.d20 ) then print * , i , j print * , rhs ( ictr ) pause 'Predictor 426' end if rhm ( i , j ) = rhs ( ictr ) xval ( ictr ) = 0.d0 rows ( ictr ) = ilower + ictr end if end do end do call HYPRE_IJVectorSetValues ( b , local_size , rows , rhs , ierr ) call HYPRE_IJVectorSetValues ( x , local_size , rows , xval , ierr ) call HYPRE_IJVectorAssemble ( b , ierr ) call HYPRE_IJVectorAssemble ( x , ierr ) ! get the x and b objects call HYPRE_IJVectorGetObject ( b , par_b , ierr ) call HYPRE_IJVectorGetObject ( x , par_x , ierr ) deallocate ( rhs ) deallocate ( xval ) deallocate ( rows ) end subroutine SetVectors SUBROUTINE DeltaGetValues ( x , TCell , Var , iu , iv ) !! The subroutine get the result for HYPRE INTEGER * 8 , INTENT ( IN ) :: x !! The ID for result vector INTEGER , INTENT ( IN ) :: iu , iv !! The input number to determine this subroutine is applied for x or y direction TYPE ( Cell ), INTENT ( IN ) :: TCell !! The cell REAL ( KIND = dp ), DIMENSION (:,:), allocatable , INTENT ( INOUT ) :: Var !! The output variable INTEGER ( kind = it4b ) :: i , j INTEGER ( kind = it4b ) :: ilower , iupper , local_size , ctr INTEGER ( kind = it4b ), DIMENSION (:), allocatable :: rows REAL ( KIND = dp ), DIMENSION (:), allocatable :: values ilower = 0 iupper = TCell % ExtCell local_size = TCell % ExtCell + 1 ! Number of elements allocate ( values ( ilower : iupper )) allocate ( rows ( ilower : iupper )) do i = 1 , Isize - iu do j = 1 , Jsize - iv if ( TCell % Posnu ( i , j ) /=- 1 ) then rows ( TCell % PosNu ( i , j )) = TCell % PosNu ( i , j ) + ilower end if end do end do call HYPRE_IJVectorGetValues ( x , local_size , rows , values , ierr ) ctr = 0 do i = 1 , Isize - iu do j = 1 , Jsize - iv if ( TCell % PosNu ( i , j ) == ctr ) then Var ( i , j ) = values ( ctr ) ctr = ctr + 1 else Var ( i , j ) = 0.d0 end if if ( isnan ( Var ( i , j ))) then print * , i , j pause 'PredictorUV_564' end if end do end do deallocate ( values , rows ) END SUBROUTINE DeltaGetValues SUBROUTINE ModifiedConvectiveFlux ( PGrid , UGrid , VGrid , PCell , UCell , VCell , & flux , vb , idir , jdir ) !! The subroutine computes the convective flux through velocity cell faces. !! The method is first order upwind for whole computational domain except !! the boundary cells, where, central scheme is applied. IMPLICIT NONE TYPE ( Grid ), INTENT ( IN ) :: PGrid , UGrid , VGrid !! The grid TYPE ( Cell ), INTENT ( IN ) :: PCell , UCell , VCell !! The cell REAL ( KIND = dp ), INTENT ( IN ) :: vb !! The boundary velocity INTEGER ( kind = it4b ), INTENT ( IN ) :: idir , jdir !! The parameter indicating the subroutine applied for x or y direction REAL ( KIND = dp ), DIMENSION (:,:,:), allocatable , INTENT ( INOUT ) :: flux !! The output convective flux INTEGER ( kind = it4b ) :: i , j REAL ( KIND = dp ) :: uw , vw , us , vs , epsi , uwn , uwp , vsn , vsp REAL ( KIND = dp ) :: eta , Sx , Sy epsi = 1.d-20 do i = 1 , Isize + idir do j = 1 , Jsize + jdir if ( idir == 1 ) then uw = 0.5d0 * ( u ( i , j ) + u ( i - 1 , j )) ! For u being convective velocity and scalar velocity if ( i == ibeg ) then Flux ( i , j , 1 ) = uw ** 2.d0 * UGrid % dy ( i , j ) * UCell % WEdge_Area ( i , j ) elseif ( i >= ibeg + Isize - 1 ) then Flux ( i , j , 1 ) = uw ** 2.d0 * UGrid % dy ( i - 1 , j ) * UCell % EEdge_Area ( i - 1 , j ) else eta = UCell % EtaE ( i - 1 , j ) uw = ( 1.d0 - eta ) * u ( i - 1 , j ) + eta * u ( i , j ) ! First order upwind uwp = 0.5d0 * ( uw + dabs ( uw )) uwn = 0.5d0 * ( uw - dabs ( uw )) Flux ( i , j , 1 ) = ( uwp * u ( i - 1 , j ) + uwn * u ( i , j )) * UCell % AlE ( i - 1 , j ) * & UGrid % dy ( i , j ) * UCell % WEdge_Area ( i , j ) end if ! Convective velocity: u, scalar advective : v uw = 0.5d0 * ( u ( i - 1 , j + 1 ) + u ( i - 1 , j )) if ( i > ibeg + Isize - 1 ) then Flux ( i , j , 2 ) = uw * 0.5d0 * ( v ( i - 1 , j ) + v ( i , j )) * VGrid % dy ( i - 1 , j ) * & VCell % EEdge_Area ( i - 1 , j ) elseif ( i == ibeg ) then Flux ( i , j , 2 ) = uw * 0.5d0 * ( v ( i - 1 , j ) + v ( i , j )) * VGrid % dy ( i , j ) * & VCell % WEdge_Area ( i , j ) else Sy = UCell % SyN ( i - 1 , j ) eta = dabs ( VCell % FCE ( i - 1 , j , 2 ) + PGrid % dy ( i - 1 , j ) / 2.d0 - & UCell % Cell_Cent ( i - 1 , j , 2 )) / Sy if ( dabs ( eta ) >= 1.d0 ) eta = 0.5d0 uw = ( 1.d0 - eta ) * u ( i - 1 , j ) + eta * u ( i - 1 , j + 1 ) ! firt order upwind uwp = 0.5d0 * ( uw + dabs ( uw )) uwn = 0.5d0 * ( uw - dabs ( uw )) Flux ( i , j , 2 ) = ( uwp * v ( i - 1 , j ) + uwn * v ( i , j )) * VCell % WEdge_Area ( i , j ) * & VGrid % dy ( i , j ) end if end if if ( jdir == 1 ) then ! Jflux ! Convective velocity: v, scalar advective: u vs = 0.5d0 * ( v ( i , j - 1 ) + v ( i + 1 , j - 1 )) if ( j > jbeg + Jsize - 1 ) then Flux ( i , j , 1 ) = vs * 0.5d0 * ( u ( i , j ) + u ( i , j - 1 )) * UGrid % dx ( i , j - 1 ) * & UCell % NEdge_Area ( i , j - 1 ) elseif ( j == jbeg ) then Flux ( i , j , 1 ) = vs * 0.5d0 * ( u ( i , j ) + u ( i , j - 1 )) * UGrid % dx ( i , j ) * & UCell % SEdge_Area ( i , j ) else Sx = VCell % SxE ( i , j - 1 ) eta = dabs ( UCell % FCN ( i , j - 1 , 1 ) + PGrid % dx ( i , j - 1 ) / 2.d0 - & VCell % Cell_Cent ( i , j - 1 , 1 )) / Sx if ( dabs ( eta ) >= 1.d0 ) eta = 0.5d0 vs = ( 1.d0 - eta ) * v ( i , j - 1 ) + eta * v ( i + 1 , j - 1 ) ! first order upwind vsp = 0.5d0 * ( vs + dabs ( vs )) vsn = 0.5d0 * ( vs - dabs ( vs )) Flux ( i , j , 1 ) = ( vsp * u ( i , j - 1 ) + vsn * u ( i , j )) * UCell % SEdge_Area ( i , j ) * & UGrid % dx ( i , j ) end if vs = 0.5d0 * ( v ( i , j ) + v ( i , j - 1 )) if ( j >= jbeg + Jsize - 1 ) then Flux ( i , j , 2 ) = vs ** 2.d0 * VGrid % dx ( i , Jsize ) * VCell % NEdge_Area ( i , j - 1 ) elseif ( j == jbeg ) then Flux ( i , j , 2 ) = vs ** 2.d0 * VGrid % dx ( i , j ) * VCell % SEdge_Area ( i , j ) else eta = VCell % EtaN ( i , j - 1 ) vs = ( 1.d0 - eta ) * v ( i , j - 1 ) + eta * v ( i , j ) vs = (( vs - vb ) * VCell % AlN ( i , j - 1 ) + vb ) ! First order upwind vsp = 0.5d0 * ( vs + dabs ( vs )) vsn = 0.5d0 * ( vs - dabs ( vs )) Flux ( i , j , 2 ) = ( vsp * v ( i , j - 1 ) + vsn * v ( i , j )) * VCell % SEdge_Area ( i , j ) * & VGrid % dx ( i , j ) if ( dabs ( Flux ( i , j , 2 )) > 1.d10 ) then print * , vs , eta , vb print * , VCell % AlN ( i , j - 1 ), VCell % EtaN ( i , j - 1 ) print * , end if end if end if end do end do END SUBROUTINE ModifiedConvectiveFlux SUBROUTINE HighOrderConvectiveFluxForXDir ( PGrid , UGrid , VGrid , UCell , & VCell , vb , flux ) !! The subroutine used the MUSCL scheme for computing the covective flux !! in x direction. It is applied for both u and v. !! The work is based on 'A MUSCL scheme on staggered grids with kinetic-like fluxes !! for the barotropic Euler system', Thierry Goundon, Julie Llobell IMPLICIT NONE TYPE ( Grid ), INTENT ( IN ) :: PGrid , UGrid , VGrid !! The grid TYPE ( Cell ), INTENT ( IN ) :: UCell , VCell !! The cell REAL ( KIND = dp ), INTENT ( IN ) :: vb !! The boundary velocity REAL ( KIND = dp ), DIMENSION (:,:,:), allocatable , INTENT ( INOUT ) :: flux !! The output convective flux INTEGER ( kind = it4b ) :: i , j , Lim REAL ( KIND = dp ) :: ul , ur , vl , vr , alr , uwp , uwn , sx , sy , uw , delhec , delh , eta REAL ( KIND = dp ) :: omei , omei1 , ri , ri1 , tolim , tol tol = 1.d-24 Lim = 2 do j = 1 , Jsize ul = u ( 0 , j ); ur = u ( 1 , j ) alr = ( ur + ul ) alr = dmax1 ( dabs ( ur ), dabs ( ul )) flux ( 1 , j , 1 ) = 0.5d0 * ( ur ** 2.d0 + ul ** 2.d0 - dabs ( alr ) * ( ur - ul )) * & UCell % WEdge_Area ( 1 , j ) * UGrid % dy ( 1 , j ) vl = v ( 0 , j ); vr = v ( 1 , j ) alr = 0.5d0 * ( u ( 0 , j ) + u ( 0 , j + 1 )) flux ( 1 , j , 2 ) = 0.5d0 * ( alr * vr + alr * vl - dabs ( alr ) * ( vr - vl )) * & VCell % WEdge_Area ( 1 , j ) * VGrid % dy ( 1 , j ) do i = 2 , Isize ! Calculate threshold for MUSCL tolim = dmin1 ( 2.d0 * UGrid % dx ( i - 1 , j ) / PGrid % dx ( i , j ), & 2.d0 * UGrid % dx ( i , j ) / PGrid % dx ( i , j )) ri = (( u ( i - 1 , j ) - u ( i - 2 , j )) / PGrid % dx ( i - 1 , j )) / & (( u ( i , j ) - u ( i - 1 , j )) / PGrid % dx ( i , j )) omei = MUSCLLimiter ( ri , Lim , tolim ) * ( u ( i , j ) - u ( i - 1 , j )) / PGrid % dx ( i , j ) ri1 = (( u ( i , j ) - u ( i - 1 , j )) / PGrid % dx ( i , j )) / & (( u ( i + 1 , j ) - u ( i , j )) / PGrid % dx ( min ( Isize , i + 1 ), j )) omei1 = MUSCLLimiter ( ri1 , Lim , tolim ) * ( u ( i + 1 , j ) - u ( i , j )) / & PGrid % dx ( min ( Isize , i + 1 ), j ) ul = u ( i - 1 , j ) + 0.5d0 * ( PGrid % dx ( i , j )) * omei ur = u ( i , j ) - 0.5d0 * ( PGrid % dx ( i , j )) * omei1 alr = ( ur + ul ) alr = dmax1 ( dabs ( ur ), dabs ( ul )) flux ( i , j , 1 ) = 0.5d0 * ( ur ** 2.d0 + ul ** 2.d0 - dabs ( alr ) * ( ur - ul )) * & UCell % WEdge_Area ( i , j ) * UGrid % dy ( i , j ) if ( i > 2. and . i < Isize ) then if ( UCell % vofS ( i - 2 , j ) > epsi . or . UCell % vofs ( i - 1 , j ) > epsi . or . & UCell % VofS ( i , j ) > epsi . or . UCell % vofS ( i + 1 , j ) > epsi ) then Sx = UCell % SxE ( i - 1 , j ) Sy = UCell % Cell_Cent ( i , j , 2 ) - UCell % Cell_Cent ( i - 1 , j , 2 ) eta = UCell % EtaE ( i - 1 , j ) uw = ( 1 - eta ) * u ( i - 1 , j ) + eta * u ( i , j ) ! first order for x-direction uwp = 0.5d0 * ( uw + dabs ( uw )) uwn = 0.5d0 * ( uw - dabs ( uw )) Flux ( i , j , 1 ) = ( uwp * u ( i - 1 , j ) + uwn * u ( i , j )) * UCell % AlE ( i - 1 , j ) * & UGrid % dy ( i , j ) * UCell % WEdge_Area ( i , j ) end if end if tolim = dmin1 ( 2.d0 * VGrid % dx ( i - 1 , j ) / UGrid % dx ( i - 1 , j ), & 2.d0 * VGrid % dx ( i , j ) / UGrid % dx ( i - 1 , j )) ri = (( v ( i - 1 , j ) - v ( i - 2 , j )) / UGrid % dx ( max ( 1 , i - 2 ), j )) / & (( v ( i , j ) - v ( i - 1 , j )) / UGrid % dx ( i - 1 , j )) omei = MUSCLlimiter ( ri , Lim , tolim ) * ( v ( i , j ) - v ( i - 1 , j )) / UGrid % dx ( i - 1 , j ) ri1 = (( v ( i , j ) - v ( i - 1 , j )) / UGrid % dx ( i - 1 , j )) / & (( v ( i + 1 , j ) - v ( i , j )) / UGrid % dx ( i , j )) omei1 = MUSCLLimiter ( ri1 , Lim , tolim ) * ( v ( i + 1 , j ) - v ( i , j )) / UGrid % dx ( i , j ) vl = v ( i - 1 , j ) + 0.5d0 * ( PGrid % dx ( i - 1 , j )) * omei vr = v ( i , j ) - 0.50d0 * ( PGrid % dx ( i , j )) * omei1 alr = 0.5d0 * ( u ( i - 1 , j ) + u ( i - 1 , j + 1 )) ! alr=dmax1(dabs(u(i-1,j)),dabs(u(i-1,j+1))) flux ( i , j , 2 ) = 0.5d0 * ( alr * vr + alr * vl - dabs ( alr ) * ( vr - vl )) * & VCell % WEdge_Area ( i , j ) * VGrid % dy ( i , j ) if ( i > 2. and . i < Isize ) then if ( VCell % vofS ( i - 2 , j ) > epsi . or . VCell % vofs ( i - 1 , j ) > epsi . or . & VCell % VofS ( i , j ) > epsi . or . VCell % vofS ( i + 1 , j ) > epsi ) then if ( VCell % WEdge_Area ( i , j ) < 0.5d0 ) then delhec = dabs ( VCell % FCE ( i - 1 , j , 1 ) * VCell % nxS ( i - 1 , j ) + & VCell % FCE ( i - 1 , j , 2 ) * VCell % nyS ( i - 1 , j ) + VCell % phiS ( i - 1 , j )) if ( UCell % MoExCell ( i - 1 , j + 1 ) /= 1. and . UCell % VofS ( i - 1 , j + 1 ) < 1.d0 - epsi ) then delh = dabs ( UCell % Cell_Cent ( i - 1 , j + 1 , 1 ) * UCell % nxS ( i - 1 , j + 1 ) + & UCell % Cell_Cent ( i - 1 , j + 1 , 2 ) * UCell % nyS ( i - 1 , j + 1 ) + & UCell % phiS ( i - 1 , j + 1 )) + tol uw = u ( i - 1 , j + 1 ) elseif ( UCell % MoExCell ( i - 1 , j ) /= 1. and . UCell % VofS ( i - 1 , j ) < 1.d0 - epsi ) then delh = dabs ( UCell % Cell_Cent ( i - 1 , j , 1 ) * UCell % nxS ( i - 1 , j ) + & UCell % Cell_Cent ( i - 1 , j , 2 ) * UCell % nyS ( i - 1 , j ) + & UCell % phiS ( i - 1 , j )) + tol uw = u ( i - 1 , j ) else delh = delhec + tol uw = 0.d0 end if uwp = 0.5d0 * ( uw + dabs ( uw )) uwn = 0.5d0 * ( uw - dabs ( uw )) Flux ( i , j , 2 ) = ( uwp * v ( i - 1 , j ) + uwn * v ( i , j )) * delhec / delh * & VCell % WEdge_Area ( i , j ) * VGrid % dy ( i , j ) else Sy = UCell % SyN ( i - 1 , j ) eta = dabs ( VCell % FCE ( i - 1 , j , 2 ) + VGrid % dy ( i - 1 , j ) / 2.d0 - & UCell % Cell_Cent ( i - 1 , j , 2 )) / Sy if ( dabs ( eta ) >= 1.d0 ) eta = 0.5d0 uw = ( 1.d0 - eta ) * u ( i - 1 , j ) + eta * u ( i - 1 , j + 1 ) uwp = 0.5d0 * ( uw + dabs ( uw )) uwn = 0.5d0 * ( uw - dabs ( uw )) Flux ( i , j , 2 ) = ( uwp * v ( i - 1 , j ) + uwn * v ( i , j )) * VCell % WEdge_Area ( i , j ) * & VGrid % dy ( i , j ) end if end if end if end do ul = u ( Isize , j ); ur = u ( Isize + 1 , j ) alr = ( ur + ul ) alr = dmax1 ( dabs ( ur ), dabs ( ul )) flux ( Isize + 1 , j , 1 ) = 0.5d0 * ( ur ** 2.d0 + ul ** 2.d0 - dabs ( alr ) * ( ur - ul )) * & UCell % EEdge_Area ( Isize , j ) * UGrid % dy ( Isize , j ) vl = v ( Isize , j ); vr = v ( Isize + 1 , j ) alr = 0.5d0 * ( u ( Isize , j ) + u ( Isize , j + 1 )) flux ( Isize + 1 , j , 2 ) = 0.5d0 * ( alr * vr + alr * vl - dabs ( alr ) * ( vr - vl )) * & VCell % EEdge_Area ( Isize , j ) * VGrid % dy ( Isize , j ) end do end subroutine HighOrderConvectiveFluxForXDir subroutine HighOrderConvectiveFluxForYDir ( PGrid , UGrid , VGrid , UCell , & VCell , vb , flux ) !! The subroutine used the MUSCL scheme for computing the covective flux !! in y direction. It is applied for both u and v. IMPLICIT NONE TYPE ( Grid ), INTENT ( IN ) :: PGrid , UGrid , VGrid !! The grid TYPE ( Cell ), INTENT ( IN ) :: UCell , VCell !! The cell REAL ( KIND = dp ), INTENT ( IN ) :: vb !! The boundary velocity REAL ( KIND = dp ), DIMENSION (:,:,:), allocatable , INTENT ( INOUT ) :: flux !! The output convective flux INTEGER ( kind = it4b ) :: i , j , Lim REAL ( KIND = dp ) :: ul , ur , vl , vr , alr , delhec , delh , tol REAL ( KIND = dp ) :: omei , omei1 , ri , ri1 , tolim , Sx , Sy , vs , vsp , vsn , eta Lim = 2 tol = 1.d-24 do i = 1 , Isize ul = u ( i , 0 ); ur = u ( i , 1 ) alr = 0.5d0 * ( v ( i , 0 ) + v ( i + 1 , 0 )) flux ( i , 1 , 1 ) = 0.5d0 * ( alr * ur *+ alr * ul - dabs ( alr ) * ( ur - ul )) * & UCell % SEdge_Area ( i , 1 ) * UGrid % dx ( i , 1 ) vl = v ( i , 0 ); vr = v ( i , 1 ) alr = ( vr + vl ) alr = dmax1 ( dabs ( vl ), dabs ( vr )) flux ( i , 1 , 2 ) = 0.5d0 * ( vr ** 2.d0 + vl ** 2.d0 - dabs ( alr ) * ( vr - vl )) * & VCell % SEdge_Area ( i , 1 ) * VGrid % dx ( i , 1 ) do j = 2 , Jsize tolim = dmin1 ( 2.d0 * UGrid % dy ( i , j - 1 ) / VGrid % dy ( i , j - 1 ), & 2.d0 * UGrid % dy ( i , j ) / VGrid % dy ( i , j - 1 )) ri = (( u ( i , j - 1 ) - u ( i , j - 2 )) / VGrid % dy ( i , max ( 1 , j - 2 ))) / & (( u ( i , j ) - u ( i , j - 1 )) / VGrid % dy ( i , j - 1 )) omei = MUSCLLimiter ( ri , Lim , tolim ) * ( u ( i , j ) - u ( i , j - 1 )) / VGrid % dy ( i , j - 1 ) ri1 = (( u ( i , j ) - u ( i , j - 1 )) / VGrid % dy ( i , j - 1 )) / & (( u ( i , j + 1 ) - u ( i , j )) / VGrid % dy ( i , j )) omei1 = MUSCLLimiter ( ri1 , Lim , tolim ) * ( u ( i , j + 1 ) - u ( i , j )) / VGrid % dy ( i , j ) ul = u ( i , j - 1 ) + 0.5d0 * ( PGrid % dy ( i , j - 1 )) * omei ur = u ( i , j ) - 0.5d0 * ( PGrid % dy ( i , j )) * omei1 alr = 0.5d0 * ( v ( i , j - 1 ) + v ( i + 1 , j - 1 )) ! alr=dmax1(dabs(v(i,j-1)),dabs(v(i+1,j-1))) flux ( i , j , 1 ) = 0.5d0 * ( alr * ur + alr * ul - dabs ( alr ) * ( ur - ul )) * & UCell % SEdge_Area ( i , j ) * UGrid % dx ( i , j ) if ( j > 2. and . j < Jsize ) then if ( UCell % vofS ( i , j - 2 ) > epsi . or . UCell % vofs ( i , j - 1 ) > epsi . or . & UCell % VofS ( i , j ) > epsi . or . UCell % vofS ( i , j + 1 ) > epsi ) then if ( UCell % SEdge_Area ( i , j ) < 0.5d0 ) then delhec = dabs ( UCell % FCN ( i , j - 1 , 1 ) * UCell % nxS ( i , j - 1 ) + & UCell % FCN ( i , j - 1 , 2 ) * UCell % nyS ( i , j - 1 ) + UCell % phiS ( i , j - 1 )) if ( VCell % MoExCell ( i , j - 1 ) /= 1. and . VCell % VofS ( i , j - 1 ) < 1.d0 - epsi ) then delh = dabs ( VCell % Cell_Cent ( i , j - 1 , 1 ) * VCell % nxS ( i , j - 1 ) + & VCell % Cell_Cent ( i , j - 1 , 2 ) * VCell % nyS ( i , j - 1 ) + & VCell % phiS ( i , j - 1 )) + tol vs = v ( i , j - 1 ) elseif ( VCell % MoExCell ( i + 1 , j - 1 ) /= 1. and . & VCell % VofS ( i + 1 , j - 1 ) < 1.d0 - epsi ) then delh = dabs ( VCell % Cell_Cent ( i + 1 , j - 1 , 1 ) * VCell % nxS ( i + 1 , j - 1 ) + & VCell % Cell_Cent ( i + 1 , j - 1 , 2 ) * VCell % nyS ( i + 1 , j - 1 ) + & VCell % phiS ( i + 1 , j - 1 )) + tol vs = v ( i + 1 , j - 1 ) else delh = delhec + tol vs = 0.d0 end if vs = vb + ( vs - vb ) * delhec / delh vsp = 0.5d0 * ( vs + dabs ( vs )) vsn = 0.5d0 * ( vs - dabs ( vs )) Flux ( i , j , 1 ) = ( vsp * u ( i , j - 1 ) + vsn * u ( i , j )) * delhec / delh * & UCell % SEdge_Area ( i , j ) * UGrid % dx ( i , j ) if ( isnan ( flux ( i , j , 1 ))) then print * , vsp , vsn print * , delhec , delh , UCell % SEdge_Area ( i , j ) print * , 'fuck you bugs' end if else Sx = VCell % SxE ( i , j - 1 ) eta = dabs ( UCell % FCN ( i , j - 1 , 1 ) + 0.5d0 * UGrid % dy ( i , j - 1 ) - & VCell % Cell_Cent ( i , j - 1 , 1 )) / Sx if ( dabs ( eta ) >= 1.d0 ) eta = 0.5d0 vs = ( 1.d0 - eta ) * v ( i , j - 1 ) + eta * v ( i + 1 , j - 1 ) vsp = 0.5d0 * ( vs + dabs ( vs )) vsn = 0.5d0 * ( vs - dabs ( vs )) Flux ( i , j , 1 ) = ( vsp * u ( i , j - 1 ) + vsn * u ( i , j )) * UCell % SEdge_Area ( i , j ) * & UGrid % dx ( i , j ) end if end if end if tolim = dmin1 ( 2.d0 * VGrid % dy ( i , j - 1 ) / PGrid % dy ( i , j ), & 2.d0 * VGrid % dy ( i , j ) / PGrid % dy ( i , j )) ri = (( v ( i , j - 1 ) - v ( i , j - 2 )) / PGrid % dy ( i , j - 1 )) / & (( v ( i , j ) - v ( i , j - 1 )) / PGrid % dy ( i , j )) omei = MUSCLlimiter ( ri , Lim , tolim ) * ( v ( i , j ) - v ( i , j - 1 )) / PGrid % dy ( i , j - 1 ) ri1 = (( v ( i , j ) - v ( i , j - 1 )) / PGrid % dy ( i , j )) / & (( v ( i , j + 1 ) - v ( i , j )) / PGrid % dy ( i , min ( Jsize , j + 1 ))) omei1 = MUSCLLimiter ( ri1 , Lim , tolim ) * ( v ( i , j + 1 ) - v ( i , j )) / & PGrid % dy ( i , min ( Jsize , j + 1 )) vl = v ( i , j - 1 ) + 0.5d0 * ( PGrid % dy ( i , j )) * omei vr = v ( i , j ) - 0.5d0 * ( PGrid % dy ( i , j )) * omei1 alr = ( vr + vl ) alr = dmax1 ( dabs ( vl ), dabs ( vr )) flux ( i , j , 2 ) = 0.5d0 * ( vr * vr + vl * vl - dabs ( alr ) * ( vr - vl )) * & VCell % SEdge_Area ( i , j ) * VGrid % dx ( i , j ) if ( j > 2. and . j < Jsize ) then if ( VCell % vofS ( i , j - 2 ) > epsi . or . VCell % vofs ( i , j - 1 ) > epsi . or . & VCell % VofS ( i , j ) > epsi . or . VCell % vofS ( i , j + 1 ) > epsi ) then Sx = VCell % Cell_Cent ( i , j , 1 ) - VCell % Cell_Cent ( i , j - 1 , 1 ) Sy = VCell % SyN ( i , j - 1 ) eta = VCell % EtaN ( i , j - 1 ) vs = ( 1.d0 - eta ) * v ( i , j - 1 ) + eta * v ( i , j ) vs = ( vb + ( vs - vb ) * VCell % AlN ( i , j - 1 )) vsp = 0.5d0 * ( vs + dabs ( vs )) vsn = 0.5d0 * ( vs - dabs ( vs )) Flux ( i , j , 2 ) = ( vsp * v ( i , j - 1 ) + vsn * v ( i , j )) * & VCell % SEdge_Area ( i , j ) * VGrid % dx ( i , j ) end if end if end do ul = u ( i , Jsize ); ur = u ( i , Jsize + 1 ) alr = 0.5d0 * ( v ( i , Jsize ) + v ( i + 1 , Jsize )) flux ( i , Jsize + 1 , 1 ) = 0.5d0 * ( alr * ur + alr * ul - dabs ( alr ) * ( ur - ul )) * & UCell % NEdge_Area ( i , Jsize ) * UGrid % dx ( i , Jsize ) vl = v ( i , Jsize ); vr = v ( i , Jsize + 1 ) alr = ( vr + vl ) alr = dmax1 ( dabs ( vl ), dabs ( vr )) flux ( i , Jsize + 1 , 2 ) = 0.5d0 * ( vr ** 2.d0 + vl ** 2.d0 - dabs ( alr ) * ( vr - vl )) * & VCell % NEdge_Area ( i , Jsize ) * VGrid % dx ( i , Jsize ) end do end subroutine HighOrderConvectiveFluxForYDir subroutine FaceDensityFlux ( PGrid , UGrid , VGrid , PCell , UCell , VCell , & flux , Vflux , vb , dt , idir , jdir ) !! The subroutine compute the mass flux through cell face. !! It also determine the mixture density at cell faces, which is used for computing !! the convective fluxes. IMPLICIT NONE TYPE ( Grid ), INTENT ( IN ) :: PGrid , UGrid , VGrid !! The grid TYPE ( Cell ), INTENT ( IN ) :: PCell , UCell , VCell !! The cell INTEGER ( kind = it4b ), INTENT ( IN ) :: idir , jdir !! The parameter indicating the subroutine applied for x or y direction REAL ( KIND = dp ), INTENT ( IN ) :: dt !! The time step REAL ( KIND = dp ), INTENT ( IN ) :: vb !! The boundary velocity REAL ( KIND = dp ), DIMENSION (:,:,:), allocatable , INTENT ( INOUT ) :: flux !! The mass flux REAL ( KIND = dp ), DIMENSION (:,:,:), allocatable , INTENT ( INOUT ) :: VFlux !! The mixture density at cell faces INTEGER ( kind = it4b ) :: i , j REAL ( KIND = dp ) :: uw , vs , uwn , uwp , vsn , vsp , VofFace , diss , nxx , nyy REAL ( KIND = dp ) :: eta , Sx , Sy , volf , vols do i = 1 , Isize + idir do j = 1 , Jsize + jdir if ( idir == 1 ) then uw = 0.5d0 * ( u ( i , j ) + u ( i - 1 , j )) Vflux ( i , j , 1 ) = 0.d0 Flux ( i , j , 1 ) = 0.d0 ! For UCell both for convective velocity and scalar velocity if ( i == ibeg ) then if ( UCell % WEdge_Area ( 1 , j ) >= epsi ) then VFlux ( i , j , 1 ) = (( 1.d0 - PCell % Vof ( i , j ) - PCell % VofS ( i , j )) * roa / Roref + & PCell % Vof ( i , j ) * row / Roref ) end if Flux ( i , j , 1 ) = uw * VFlux ( i , j , 1 ) * UGrid % dy ( i , j ) elseif ( i >= ibeg + Isize - 1 ) then if ( UCell % EEdge_Area ( Isize , j ) >= epsi ) then VFlux ( i , j , 1 ) = (( 1.d0 - PCell % Vof ( Isize , j ) - PCell % VofS ( Isize , j )) * & roa / Roref + PCell % Vof ( Isize , j ) * row / Roref ) end if Flux ( i , j , 1 ) = uw * VFlux ( i , j , 1 ) * UGrid % dy ( i - 1 , j ) else if ( UCell % WEdge_Area ( i , j ) >= epsi ) then eta = UCell % EtaE ( i - 1 , j ) uw = ( 1.d0 - eta ) * u ( i - 1 , j ) + eta * u ( i , j ) if ( PCell % vof ( i , j ) > 1.d0 - epsi . or . PCell % vof ( i , j ) < epsi ) then VFlux ( i , j , 1 ) = (( 1.d0 - PCell % Vof ( i , j ) - PCell % VofS ( i , j )) * roa / Roref + & PCell % Vof ( i , j ) * row / Roref ) else if ( PCell % VofS ( i , j ) < epsi ) then call frac ( PCell % nx ( i , j ), PCell % ny ( i , j ), PCell % phi ( i , j ) + & uw * dt / 2.d0 * PCell % nx ( i , j ), dabs ( uw * dt ), PGrid % dy ( i , j ), volf ) VFlux ( i , j , 1 ) = ( volf * row / Roref + ( 1.d0 - volf - vols ) * roa / Roref ) else call CellGeoCal ( PCell % nxs ( i , j ), PCell % nys ( i , j ), & PCell % phis ( i , j ) + uw * dt / 2.d0 * PCell % nxs ( i , j ), PCell % nx ( i , j ), & PCell % ny ( i , j ), PCell % phi ( i , j ) + uw * dt / 2.d0 * PCell % nx ( i , j ), & dabs ( uw * dt ), PGrid % dy ( i , j ), vols , volf ) VFlux ( i , j , 1 ) = ( volf * row / Roref + ( 1.d0 - volf - vols ) * roa / Roref ) end if end if end if Flux ( i , j , 1 ) = uw * UCell % AlE ( i - 1 , j ) * VFlux ( i , j , 1 ) * UGrid % dy ( i , j ) end if ! Convective velocity: u, scalar advective : v uw = 0.5d0 * ( u ( i - 1 , j + 1 ) + u ( i - 1 , j )) VFlux ( i , j , 2 ) = 0.d0 Flux ( i , j , 2 ) = 0.d0 if ( i > ibeg + Isize - 1 ) then if ( VCell % EEdge_Area ( Isize , j ) >= epsi ) then Flux ( i , j , 2 ) = uw * ( Vvolf ( Isize , j ) * row / Roref + & ( 1.d0 - Vvolf ( Isize , j ) - VCell % Vofs ( Isize , j )) * roa / Roref ) * & VGrid % dy ( i - 1 , j ) end if elseif ( i == ibeg ) then if ( VCell % WEdge_ARea ( 1 , j ) >= epsi ) then Flux ( i , j , 2 ) = uw * ( Vvolf ( i , j ) * row / Roref + & ( 1.d0 - Vvolf ( i , j ) - VCell % vofS ( i , j )) * roa / Roref ) * VGrid % dy ( i , j ) end if else if ( VCell % WEdge_Area ( i , j ) >= epsi ) then Sy = UCell % SyN ( i - 1 , j ) eta = dabs ( VCell % FCE ( i - 1 , j , 2 ) + PGrid % dy ( i - 1 , j ) / 2.d0 - & UCell % Cell_Cent ( i - 1 , j , 2 )) / Sy if ( dabs ( eta ) >= 1.d0 ) eta = 0.5d0 uw = ( 1.d0 - eta ) * u ( i - 1 , j ) + eta * u ( i - 1 , j + 1 ) uwp = 0.5d0 * ( uw + dabs ( uw )) uwn = 0.5d0 * ( uw - dabs ( uw )) Flux ( i , j , 2 ) = ( uwp * ( Vvolf ( i - 1 , j ) * row / Roref + ( 1.d0 - Vvolf ( i - 1 , j ) - & VCell % vofS ( i - 1 , j )) * roa / Roref ) + uwn * ( Vvolf ( i , j ) * & row / Roref + ( 1.d0 - Vvolf ( i , j ) - VCell % vofS ( i , j )) * & roa / Roref )) * VGrid % dy ( i , j ) end if end if end if if ( jdir == 1 ) then ! Jflux VFlux ( i , j , 1 ) = 0.d0 Flux ( i , j , 1 ) = 0.d0 ! Convective velocity: v, scalar advective: u vs = 0.5d0 * ( v ( i , j - 1 ) + v ( i + 1 , j - 1 )) if ( j > jbeg + Jsize - 1 ) then if ( UCell % NEdge_Area ( i , Jsize ) >= epsi ) then Flux ( i , j , 1 ) = vs * ( Uvolf ( i , Jsize ) * row / Roref + & ( 1.d0 - Uvolf ( i , Jsize ) - UCell % vofS ( i , Jsize )) * roa / Roref ) * & UGrid % dx ( i , j - 1 ) end if elseif ( j == jbeg ) then if ( UCell % SEdge_Area ( i , j ) >= epsi ) then Flux ( i , j , 1 ) = vs * ( Uvolf ( i , j ) * row / Roref + & ( 1.d0 - Uvolf ( i , j ) - UCell % vofS ( i , j )) * roa / Roref ) * UGrid % dx ( i , j ) end if else if ( UCell % SEdge_Area ( i , j ) >= epsi ) then Sx = VCell % SxE ( i , j - 1 ) eta = dabs ( UCell % FCN ( i , j - 1 , 1 ) + PGrid % dx ( i , j - 1 ) / 2.d0 - & VCell % Cell_Cent ( i , j - 1 , 1 )) / Sx if ( dabs ( eta ) >= 1.d0 ) eta = 0.5d0 vs = ( 1.d0 - eta ) * v ( i , j - 1 ) + eta * v ( i + 1 , j - 1 ) vsp = 0.5d0 * ( vs + dabs ( vs )) vsn = 0.5d0 * ( vs - dabs ( vs )) Flux ( i , j , 1 ) = ( vsp * ( Uvolf ( i , j - 1 ) * row / Roref + ( 1.d0 - Uvolf ( i , j - 1 ) - & UCell % vofS ( i , j - 1 )) * roa / Roref ) + vsn * ( Uvolf ( i , j ) * & row / Roref + ( 1.d0 - Uvolf ( i , j ) - UCell % vofS ( i , j )) * & roa / Roref )) * UGrid % dx ( i , j ) end if end if vs = 0.5d0 * ( v ( i , j ) + v ( i , j - 1 )) Vflux ( i , j , 2 ) = 0.d0 Flux ( i , j , 2 ) = 0.d0 if ( j >= jbeg + Jsize - 1 ) then if ( VCell % NEdge_Area ( i , Jsize ) >= epsi ) then VFlux ( i , j , 2 ) = (( 1.d0 - PCell % Vof ( i , Jsize ) - PCell % vofS ( i , Jsize )) * & roa / Roref + PCell % Vof ( i , Jsize ) * row / Roref ) end if Flux ( i , j , 2 ) = vs * VFlux ( i , j , 2 ) * VGrid % dx ( i , j - 1 ) elseif ( j == jbeg ) then if ( VCell % SEdge_Area ( i , j ) >= epsi ) then VFlux ( i , j , 2 ) = (( 1.d0 - PCell % Vof ( i , j ) - PCell % vofS ( i , j )) * roa / Roref + & PCell % Vof ( i , j ) * row / Roref ) end if Flux ( i , j , 2 ) = vs * VFlux ( i , j , 2 ) * VGrid % dx ( i , j ) else if ( VCell % SEdge_Area ( i , j ) >= epsi ) then eta = VCell % EtaN ( i , j - 1 ) vs = ( 1.d0 - eta ) * v ( i , j - 1 ) + eta * v ( i , j ) vs = (( vs - vb ) * VCell % AlN ( i , j - 1 ) + vb ) if ( PCell % vof ( i , j ) > 1.d0 - epsi . or . PCell % vof ( i , j ) < epsi ) then VFlux ( i , j , 2 ) = ( PCell % vof ( i , j ) * row / Roref + & ( 1.d0 - PCell % vof ( i , j ) - PCell % vofS ( i , j )) * roa / Roref ) else if ( PCell % vofS ( i , j ) < epsi ) then call frac ( PCell % nx ( i , j ), PCell % ny ( i , j ), PCell % phi ( i , j ) + & vs * dt / 2.d0 * PCell % ny ( i , j ), PGrid % dx ( i , j ), dabs ( vs * dt ), volf ) VFlux ( i , j , 2 ) = ( volf * row / Roref + ( 1.d0 - volf - vols ) * roa / Roref ) else call CellGeoCal ( PCell % nxs ( i , j ), PCell % nys ( i , j ), & PCell % phis ( i , j ) + vs * dt / 2.d0 * PCell % nys ( i , j ), PCell % nx ( i , j ),& PCell % ny ( i , j ), PCell % phi ( i , j ) + vs * dt / 2.d0 * PCell % ny ( i , j ), & PGrid % dx ( i , j ), dabs ( vs * dt ), vols , volf ) VFlux ( i , j , 2 ) = ( volf * row / Roref + ( 1.d0 - volf - vols ) * roa / Roref ) end if end if Flux ( i , j , 2 ) = vs * Vflux ( i , j , 2 ) * VGrid % dx ( i , j ) end if end if end if end do end do end subroutine FaceDensityFlux subroutine DensityBasedConvectiveFlux ( PGrid , UGrid , VGrid , PCell , UCell , VCell , & flux , Vflux , vb , idir , jdir ) !! The subroutine computes convective fluxes through cell faces. IMPLICIT NONE TYPE ( Grid ), INTENT ( IN ) :: PGrid , UGrid , VGrid !! The grid TYPE ( Cell ), INTENT ( IN ) :: PCell , UCell , VCell !! The cell INTEGER ( kind = it4b ), INTENT ( IN ) :: idir , jdir !! The parameter indicating the subroutine applied for x or y direction REAL ( KIND = dp ), DIMENSION (:,:,:), allocatable , INTENT ( IN ) :: Vflux !! The mixture density at cell faces REAL ( KIND = dp ), DIMENSION (:,:,:), allocatable , INTENT ( INOUT ) :: flux !! The convective flux REAL ( KIND = dp ), INTENT ( IN ) :: vb !! The boundary velocity INTEGER ( kind = it4b ) :: i , j REAL ( KIND = dp ) :: uw , vs , uwn , uwp , vsn , vsp REAL ( KIND = dp ) :: eta , Sx , Sy if ( idir == 1 ) then do i = 1 , Isize + 1 do j = 1 , Jsize uw = 0.5d0 * ( u ( i , j ) + u ( i - 1 , j )) ! for UCell both for convective velocity and scalar velocity if ( i == ibeg ) then Flux ( i , j , 1 ) = uw ** 2.d0 * VFlux ( i , j , 1 ) * UGrid % dy ( i , j ) elseif ( i >= ibeg + Isize - 1 ) then Flux ( i , j , 1 ) = uw ** 2.d0 * VFlux ( i , j , 1 ) * UGrid % dy ( i - 1 , j ) else eta = UCell % EtaE ( i - 1 , j ) uw = ( 1.d0 - eta ) * u ( i - 1 , j ) + eta * u ( i , j ) ! first order upwind uwp = 0.5d0 * ( uw + dabs ( uw )) uwn = 0.5d0 * ( uw - dabs ( uw )) Flux ( i , j , 1 ) = ( uwp * u ( i - 1 , j ) + uwn * u ( i , j )) * UCell % AlE ( i - 1 , j ) * & VFlux ( i , j , 1 ) * UGrid % dy ( i , j ) end if ! convective velocity: u, scalar advective : v uw = 0.5d0 * ( u ( i - 1 , j + 1 ) + u ( i - 1 , j )) Flux ( i , j , 2 ) = 0.d0 if ( i > ibeg + Isize - 1 ) then if ( VCell % EEdge_Area ( Isize , j ) >= epsi ) then Flux ( i , j , 2 ) = uw * 0.5d0 * ( v ( i - 1 , j ) + v ( i , j )) * ( Vvolf ( Isize , j ) * & row / Roref + ( 1.d0 - Vvolf ( Isize , j ) - VCell % VofS ( Isize , j )) * & roa / Roref ) * VGrid % dy ( i - 1 , j ) end if elseif ( i == ibeg ) then if ( VCell % WEdge_Area ( 1 , j ) >= epsi ) then Flux ( i , j , 2 ) = uw * 0.5d0 * ( v ( i - 1 , j ) + v ( i , j )) * ( Vvolf ( i , j ) * row / Roref + & ( 1.d0 - Vvolf ( i , j ) - VCell % VofS ( i , j )) * roa / Roref ) * VGrid % dy ( i , j ) end if else Sy = UCell % SyN ( i - 1 , j ) eta = dabs ( VCell % FCE ( i - 1 , j , 2 ) + PGrid % dy ( i - 1 , j ) / 2.d0 - & UCell % Cell_Cent ( i - 1 , j , 2 )) / Sy if ( dabs ( eta ) >= 1.d0 ) eta = 0.5d0 uw = ( 1.d0 - eta ) * u ( i - 1 , j ) + eta * u ( i - 1 , j + 1 ) ! firt order upwind uwp = 0.5d0 * ( uw + dabs ( uw )) uwn = 0.5d0 * ( uw - dabs ( uw )) if ( VCell % WEdge_Area ( i , j ) >= epsi ) then Flux ( i , j , 2 ) = ( uwp * v ( i - 1 , j ) * ( Vvolf ( i - 1 , j ) * row / Roref + & ( 1.d0 - Vvolf ( i - 1 , j ) - VCell % vofS ( i - 1 , j )) * roa / Roref ) + & uwn * v ( i , j ) * ( Vvolf ( i , j ) * row / Roref + ( 1.d0 - Vvolf ( i , j ) - & VCell % vofS ( i , j )) * roa / Roref )) * VGrid % dy ( i , j ) end if end if end do end do end if if ( jdir == 1 ) then ! Jflux do i = 1 , Isize do j = 1 , Jsize + 1 Flux ( i , j , 1 ) = 0.d0 ! Convective velocity: v, scalar advective: u if ( j > jbeg + Jsize - 1 ) then vs = 0.5d0 * ( v ( i , j - 1 ) + v ( i + 1 , j - 1 )) if ( UCell % NEdge_Area ( i , Jsize ) >= epsi ) then Flux ( i , j , 1 ) = vs * 0.5d0 * ( u ( i , j ) + u ( i , j - 1 )) * ( Uvolf ( i , Jsize ) * & row / Roref + ( 1.d0 - Uvolf ( i , Jsize ) - & UCell % vofS ( i , Jsize )) * roa / Roref ) * UGrid % dx ( i , j - 1 ) end if elseif ( j == jbeg ) then vs = 0.5d0 * ( v ( i , j - 1 ) + v ( i + 1 , j - 1 )) if ( UCell % SEdge_Area ( i , 1 ) >= epsi ) then Flux ( i , j , 1 ) = vs * 0.5d0 * ( u ( i , j ) + u ( i , j - 1 )) * ( Uvolf ( i , j ) * row / Roref + & ( 1.d0 - Uvolf ( i , j ) - UCell % vofS ( i , j )) * roa / Roref ) * UGrid % dx ( i , j ) end if else Sx = VCell % SxE ( i , j - 1 ) eta = dabs ( UCell % FCN ( i , j - 1 , 1 ) + PGrid % dx ( i , j - 1 ) / 2.d0 - & VCell % Cell_Cent ( i , j - 1 , 1 )) / Sx if ( dabs ( eta ) >= 1.d0 ) eta = 0.5d0 vs = ( 1.d0 - eta ) * v ( i , j - 1 ) + eta * v ( i + 1 , j - 1 ) vsp = 0.5d0 * ( vs + dabs ( vs )) vsn = 0.5d0 * ( vs - dabs ( vs )) if ( UCell % SEdge_Area ( i , j ) >= epsi ) then Flux ( i , j , 1 ) = ( vsp * u ( i , j - 1 ) * ( Uvolf ( i , j - 1 ) * row / Roref + & ( 1.d0 - Uvolf ( i , j - 1 ) - UCell % vofS ( i , j - 1 )) * roa / Roref ) + & vsn * u ( i , j ) * ( Uvolf ( i , j ) * row / Roref + ( 1.d0 - Uvolf ( i , j ) - & UCell % vofS ( i , j )) * roa / Roref )) * UGrid % dx ( i , j ) end if end if ! Convective velocity: v, scalar advective: v if ( j >= jbeg + Jsize - 1 ) then vs = 0.5d0 * ( v ( i , j ) + v ( i , j - 1 )) Flux ( i , j , 2 ) = vs ** 2.d0 * VFlux ( i , j , 2 ) * VGrid % dx ( i , j - 1 ) elseif ( j == jbeg ) then vs = 0.5d0 * ( v ( i , j ) + v ( i , j - 1 )) Flux ( i , j , 2 ) = vs ** 2.d0 * VFlux ( i , j , 2 ) * VGrid % dx ( i , j ) else eta = VCell % EtaN ( i , j - 1 ) vs = ( 1.d0 - eta ) * v ( i , j - 1 ) + eta * v ( i , j ) vs = (( vs - vb ) * VCell % AlN ( i , j - 1 ) + vb ) vsp = 0.5d0 * ( vs + dabs ( vs )) vsn = 0.5d0 * ( vs - dabs ( vs )) Flux ( i , j , 2 ) = ( vsp * v ( i , j - 1 ) + vsn * v ( i , j )) * VFlux ( i , j , 2 ) * VGrid % dx ( i , j ) end if end do end do end if end subroutine DensityBasedConvectiveFlux SUBROUTINE DiffusiveFlux ( PGrid , UGrid , VGrid , PCell , UCell , VCell , flux , Eflux , & ExEFlux , vb , idir , jdir ) !! The subroutine computes the diffusive fluxes and extra correction for diffusive fluxes IMPLICIT NONE INTEGER ( kind = it4b ), INTENT ( IN ) :: idir , jdir !! The parameter indicating the subroutine applied for x or y direction REAL ( KIND = dp ), INTENT ( IN ) :: vb !! The boundary velocity TYPE ( Cell ), INTENT ( IN ) :: PCell , UCell , VCell !! The cell TYPE ( Grid ), INTENT ( IN ) :: PGrid , UGrid , VGrid !! The grid REAL ( KIND = dp ), DIMENSION (:,:,:), allocatable , INTENT ( INOUT ) :: flux !! The diffusive flux REAL ( KIND = dp ), DIMENSION (:,:,:), allocatable , INTENT ( INOUT ) :: Eflux !! The extra diffusive flux coefficient REAL ( KIND = dp ), DIMENSION (:,:,:), allocatable , INTENT ( INOUT ) :: ExEFlux !! The extra diffusive flux which involve boundary velocity INTEGER ( kind = it4b ) :: i , j REAL ( KIND = dp ) :: tol , VofFace , VofSFace , Sx , Sy tol = 1.d-24 Eflux (:,:,:) = 0.d0 EXEFlux (:,:,:) = 0.d0 if ( idir == 1 ) then do j = 1 , Jsize flux ( 1 , j , 1 ) = (( 1.d0 - Uvolf ( 1 , j ) / ( 1.d0 - UCell % VofS ( 1 , j ) + tol )) * nua / nuref + & Uvolf ( 1 , j ) / ( 1.d0 - UCell % VofS ( 1 , j ) + tol ) * nuw / nuref ) * & UCell % WEdge_Area ( 1 , j ) * UGrid % dy ( 1 , j ) / PGrid % dx ( 1 , j ) / Rey flux ( 1 , j , 2 ) = (( 1.d0 - Vvolf ( 1 , j ) / ( 1.d0 - VCell % VofS ( 1 , j ) + tol )) * nua / nuref + & Vvolf ( 1 , j ) / ( 1.d0 - VCell % vofS ( 1 , j ) + tol ) * nuw / nuref ) * & VCell % WEdge_Area ( 1 , j ) * VGrid % dy ( 1 , j ) / PGrid % dx ( 1 , j ) / Rey do i = 2 , Isize Sx = UCell % SxE ( i - 1 , j ) Sy = UCell % Cell_Cent ( i , j , 2 ) - UCell % Cell_Cent ( i - 1 , j , 2 ) VofFace = 0.5d0 * ( Uvolf ( i , j ) / ( 1.d0 - UCell % VofS ( i , j ) + tol ) + & Uvolf ( i - 1 , j ) / ( 1.d0 - UCell % VofS ( i - 1 , j ) + tol )) flux ( i , j , 1 ) = (( 1.d0 - VofFace ) * nua / nuref + VofFace * nuw / nuref ) / Rey * & UCell % WEdge_Area ( i , j ) * UGrid % dy ( i , j ) / Sx if ( dabs ( Sy ) >= 1.d-3 * UGrid % dy ( i , j )) then EFlux ( i , j , 1 ) = (( 1.d0 - VofFace ) * nua / nuref + VofFace * nuw / nuref ) / Rey * & UCell % WEdge_Area ( i , j ) * UCell % DAlE ( i - 1 , j ) * UGrid % dy ( i , j ) end if Sx = VCell % SxE ( i - 1 , j ) Sy = VCell % Cell_Cent ( i , j , 2 ) - VCell % Cell_Cent ( i - 1 , j , 2 ) VofFace = 0.5d0 * ( Vvolf ( i , j ) / ( 1.d0 - VCell % VofS ( i , j ) + tol ) + & Vvolf ( i - 1 , j ) / ( 1.d0 - VCell % VofS ( i - 1 , j ) + tol )) flux ( i , j , 2 ) = (( 1.d0 - VofFace ) * nua / nuref + VofFace * nuw / nuref ) / Rey * & VCell % WEdge_Area ( i , j ) * VGrid % dy ( i , j ) / Sx if ( dabs ( Sy ) >= 1.d-3 * VGrid % dy ( i , j )) then EFlux ( i , j , 2 ) = (( 1.d0 - VofFace ) * nua / nuref + VofFace * nuw / nuref ) / Rey * & VCell % WEdge_Area ( i , j ) * VCell % DAlE ( i - 1 , j ) * VGrid % dy ( i , j ) ExEFlux ( i , j , 2 ) = vb * EFlux ( i , j , 2 ) end if end do flux ( Isize + 1 , j , 1 ) = (( 1.d0 - Uvolf ( Isize , j ) / & ( 1.d0 - UCell % VofS ( Isize , j ) + tol )) * nua / nuref + Uvolf ( Isize , j ) / & ( 1.d0 - UCell % VofS ( Isize , j ) + tol ) * nuw / nuref ) / Rey * & UCell % EEdge_Area ( Isize , j ) * UGrid % dy ( Isize , j ) / PGrid % dx ( Isize , j ) flux ( Isize + 1 , j , 2 ) = (( 1.d0 - Vvolf ( Isize , j ) / & ( 1.d0 - VCell % VofS ( Isize , j ) + tol )) * nua / nuref + Vvolf ( Isize , j ) / & ( 1.d0 - VCell % vofS ( Isize , j ) + tol ) * nuw / nuref ) / Rey * & VCell % EEdge_Area ( Isize , j ) * VGrid % dy ( Isize , j ) / PGrid % dx ( Isize , j ) end do elseif ( jdir == 1 ) then do i = 1 , Isize flux ( i , 1 , 1 ) = (( 1.d0 - Uvolf ( i , 1 ) / ( 1.d0 - UCell % VofS ( i , 1 ) + tol )) * nua / nuref + & Uvolf ( i , 1 ) / ( 1.d0 - UCell % VofS ( i , 1 ) + tol ) * nuw / nuref ) / Rey * & UCell % SEdge_Area ( i , 1 ) * UGrid % dx ( i , 1 ) / PGrid % dy ( i , 1 ) flux ( i , 1 , 2 ) = (( 1.d0 - Vvolf ( i , 1 ) / ( 1.d0 - VCell % VofS ( i , 1 ) + tol )) * nua / nuref + & Vvolf ( i , 1 ) / ( 1.d0 - VCell % vofS ( i , 1 ) + tol ) * nuw / nuref ) / Rey * & VCell % SEdge_Area ( i , 1 ) * VGrid % dx ( i , 1 ) / PGrid % dy ( i , 1 ) do j = 2 , Jsize Sx = UCell % Cell_Cent ( i , j , 1 ) - UCell % Cell_Cent ( i , j - 1 , 1 ) Sy = UCell % SyN ( i , j - 1 ) VofFace = 0.5d0 * ( Uvolf ( i , j - 1 ) / ( 1.d0 - UCell % VofS ( i , j - 1 ) + tol ) + & Uvolf ( i , j ) / ( 1.d0 - UCell % VofS ( i , j ) + tol )) flux ( i , j , 1 ) = (( 1.d0 - VofFace ) * nua / nuref + VofFace * nuw / nuref ) / Rey * & UCell % SEdge_Area ( i , j ) * UGrid % dx ( i , j ) / Sy if ( dabs ( Sx ) >= 1.d-3 * UGrid % dx ( i , j )) then EFlux ( i , j , 1 ) = (( 1.d0 - VofFace ) * nua / nuref + VofFace * nuw / nuref ) / Rey * & UCell % SEdge_Area ( i , j ) * UCell % DAlN ( i , j - 1 ) * UGrid % dx ( i , j ) end if Sx = VCell % Cell_Cent ( i , j , 1 ) - VCell % Cell_Cent ( i , j - 1 , 1 ) Sy = VCell % SyN ( i , j - 1 ) VofFace = 0.5d0 * ( Vvolf ( i , j - 1 ) / ( 1.d0 - VCell % VofS ( i , j - 1 ) + tol ) + & Vvolf ( i , j ) / ( 1.d0 - VCell % VofS ( i , j ) + tol )) flux ( i , j , 2 ) = (( 1.d0 - VofFace ) * nua / nuref + VofFace * nuw / nuref ) / Rey * & VCell % SEdge_Area ( i , j ) * VGrid % dx ( i , j ) / Sy if ( dabs ( Sx ) >= 1.d-3 * VGrid % dx ( i , j )) then EFlux ( i , j , 2 ) = (( 1.d0 - VofFace ) * nua / nuref + VofFace * nuw / nuref ) / Rey * & VCell % SEdge_Area ( i , j ) * VCell % DAlN ( i , j - 1 ) * VGrid % dx ( i , j ) ExEFlux ( i , j , 2 ) = vb * EFlux ( i , j , 2 ) end if end do flux ( i , Jsize + 1 , 1 ) = (( 1.d0 - Uvolf ( i , Jsize ) / & ( 1.d0 - UCell % VofS ( i , Jsize ) + tol )) * nua / nuref + Uvolf ( i , Jsize ) / & ( 1.d0 - UCell % VofS ( i , Jsize ) + tol ) * nuw / nuref ) / Rey * & UCell % NEdge_Area ( i , Jsize ) * UGrid % dx ( i , Jsize ) / PGrid % dy ( i , Jsize ) flux ( i , Jsize + 1 , 2 ) = (( 1.d0 - Vvolf ( i , Jsize ) / & ( 1.d0 - VCell % VofS ( i , Jsize ) + tol )) * nua / nuref + Vvolf ( i , Jsize ) / & ( 1.d0 - VCell % vofS ( i , Jsize ) + tol ) * nuw / nuref ) / Rey * & VCell % NEdge_Area ( i , Jsize ) * VGrid % dx ( i , Jsize ) / PGrid % dy ( i , Jsize ) end do end if end subroutine DiffusiveFlux subroutine Mixing_Procedure ( TGrid , TCell , idir , jdir , flux_mix ) !! The subroutine compute the total flux and redistribute it such that the !! resulted flux doesn't cause any problems to small cell. TYPE ( Grid ), INTENT ( IN ) :: TGrid !! The grid TYPE ( Cell ), INTENT ( IN ) :: TCell !! The cell INTEGER ( kind = it4b ), INTENT ( IN ) :: idir , jdir !! The parameter indicating the subroutine applied for x or y direction REAL ( KIND = dp ), DIMENSION (:,:), INTENT ( INOUT ) :: flux_mix !! The total flux INTEGER ( kind = it4b ) :: i , j , ii , jj REAL ( KIND = dp ), DIMENSION (:,:), allocatable :: flux REAL ( KIND = dp ) :: Fmix ( 3 ), Beta ( 3 ), Vtgt ( 3 ), temp allocate ( flux ( ibeg : Isize , jbeg : Jsize )) flux (:,:) = flux_mix (:,:) do i = ibeg , Isize - idir do j = jbeg , Jsize - jdir ! The condition specifies which cell is small cell and needed ! to redistribute the flux to neighour cells if ( TCell % VofS ( i , j ) >= 0.5d0 + epsi . and . TCell % Posnu ( i , j ) /=- 1 ) then ! Determine the first target cell ii = i + INT ( sign ( 1.d0 , TCell % nxS ( i , j ))); jj = j if ( ii <= Isize - idir . and . ii >= 1 ) then ! Compute coefficients Vtgt ( 1 ) = 1.d0 - TCell % VofS ( ii , jj ) Fmix ( 1 ) = ( 1.d0 - TCell % vofS ( i , j )) * Vtgt ( 1 ) * ( flux ( ii , jj ) - flux ( i , j )) Beta ( 1 ) = TCell % nxS ( i , j ) ** 2.d0 * Vtgt ( 1 ) ** 5.d0 else Fmix ( 1 ) = 0.d0 ; Beta ( 1 ) = 0.d0 ; Vtgt ( 1 ) = 1.d0 end if ! Determine the second target cell ii = i ; jj = j + INT ( sign ( 1.d0 , TCell % nyS ( i , j ))) if ( jj <= Jsize - jdir . and . jj >= 1 ) then Vtgt ( 2 ) = 1.d0 - TCell % VofS ( ii , jj ) Fmix ( 2 ) = ( 1.d0 - TCell % VofS ( i , j )) * Vtgt ( 2 ) * ( flux ( ii , jj ) - flux ( i , j )) Beta ( 2 ) = TCell % nyS ( i , j ) ** 2.d0 * Vtgt ( 2 ) ** 5.d0 else Fmix ( 2 ) = 0.d0 ; Beta ( 2 ) = 0.d0 ; Vtgt ( 2 ) = 1.d0 end if ! Determine the third target cell ii = i + INT ( sign ( 1.d0 , TCell % nxS ( i , j ))) jj = j + INT ( sign ( 1.d0 , TCell % nyS ( i , j ))) if ( ii <= Isize - idir . and . ii >= 1. and . jj <= Jsize - jdir . and . jj >= 1 ) then Vtgt ( 3 ) = 1.d0 - TCell % VofS ( ii , jj ) Fmix ( 3 ) = ( 1.d0 - TCell % vofS ( i , j )) * Vtgt ( 3 ) * ( flux ( ii , jj ) - flux ( i , j )) Beta ( 3 ) = dabs ( TCell % nxS ( i , j ) * TCell % nyS ( i , j )) * Vtgt ( 3 ) ** 5.d0 else Fmix ( 3 ) = 0.d0 ; Beta ( 3 ) = 0.d0 ; Vtgt ( 3 ) = 1.d0 end if temp = sum ( Beta ) do ii = 1 , 3 ! Recompute the coefficients Beta ( ii ) = Beta ( ii ) / temp ! Compute the flux difference between target cells and the small cell Fmix ( ii ) = Fmix ( ii ) * Beta ( ii ) / ( Beta ( ii ) * ( 1.d0 - TCell % VofS ( i , j )) + & Vtgt ( ii )) end do ! Update the flux in the small cell flux_mix ( i , j ) = flux ( i , j ) + 1.d0 / ( 1.d0 - TCell % VofS ( i , j )) * ( sum ( Fmix )) ii = i + INT ( sign ( 1.d0 , TCell % nxS ( i , j ))); jj = j ! Compute the new flux for target cells if ( ii <= Isize - idir . and . ii >= 1 ) then flux_mix ( ii , jj ) = flux_mix ( ii , jj ) - 1.d0 / Vtgt ( 1 ) * Fmix ( 1 ) end if ii = i ; jj = j + INT ( sign ( 1.d0 , TCell % nyS ( i , j ))) if ( jj <= Jsize - jdir . and . jj >= 1 ) then flux_mix ( ii , jj ) = flux_mix ( ii , jj ) - 1.d0 / Vtgt ( 2 ) * Fmix ( 2 ) end if ii = i + INT ( sign ( 1.d0 , TCell % nxS ( i , j ))) jj = j + INT ( sign ( 1.d0 , TCell % nyS ( i , j ))) if ( ii <= Isize - idir . and . ii >= 1. and . jj <= Jsize - jdir . and . jj >= 1 ) then flux_mix ( ii , jj ) = flux_mix ( ii , jj ) - 1.d0 / Vtgt ( 3 ) * Fmix ( 3 ) end if if ( isnan ( Flux_Mix ( i , j )). or . dabs ( Flux_Mix ( i , j )) > 1.d4 . or . & isnan ( Flux_Mix ( ii , jj )). or . dabs ( Flux_Mix ( ii , jj )) > 1.d4 ) then print * , i , j print * , ii , jj print * , Fmix ( 1 ), Fmix ( 2 ), Fmix ( 3 ) print * , Flux_Mix ( i , j ), Flux_Mix ( ii , jj ) print * , 'MixingProcedure_PredictorUV_2169' end if end if end do end do deallocate ( flux ) end subroutine Mixing_Procedure subroutine PredictorVelocityBoundaryCondition ( Pred , TVar ) IMPLICIT NONE TYPE ( Predictor ), INTENT ( INOUT ) :: Pred TYPE ( Variables ), INTENT ( IN ) :: TVar REAL ( KIND = dp ), PARAMETER :: Twall = 30 0.d0 INTEGER ( kind = it4b ) :: i , j do j = jbeg , Jsize + jbeg - 1 ! Outlet ! Pred%u(Isize+ibeg-1,j)=Pred%u(Isize+ibeg-2,j) end do do i = ibeg , Isize + ibeg - 1 ! Open air Pred % v ( i , Jsize + jbeg - 1 ) = Pred % v ( i , Jsize + jbeg - 2 ) end do end subroutine PredictorVelocityBoundaryCondition SUBROUTINE frac ( nx , ny , diss , dx , dy , vrt ) IMPLICIT NONE REAL ( KIND = dp ) :: slop_eps , nx , ny , diss , vrt , tnx , tny , dx , dy REAL ( KIND = dp ) :: xx , yy , topvf , rightvf , totalarea slop_eps = 1.d-20 tnx = dabs ( nx ) tny = dabs ( ny ) vrt = 0.d0 if ( diss + 0.5d0 * ( tnx * dx + tny * dy ) <= 0.d0 ) then vrt = 1.d0 return end if if ( diss - 0.5d0 * ( tnx * dx + tny * dy ) >= 0.d0 ) then vrt = 0.d0 return end if if ( tnx <= slop_eps ) then vrt = 0.5d0 - diss / dy return end if if ( tny <= slop_eps ) then vrt = 0.5d0 - diss / dx return end if xx = ( 0.5d0 * tny * dy - diss ) / dx / tnx + 0.5d0 yy = ( 0.5d0 * tnx * dx - diss ) / dy / tny + 0.5d0 totalarea = 0.5d0 * xx * yy topvf = 0.d0 if ( yy > 1.d0 ) topvf = (( yy - 1.d0 ) / yy ) ** 2.d0 rightvf = 0.d0 if ( xx > 1.d0 ) rightvf = (( xx - 1.d0 ) / xx ) ** 2.d0 vrt = totalarea * ( 1.d0 - topvf - rightvf ) if ( vrt < 0.d0 ) then print * , vrt , diss , nx , ny print * , tnx , tny , xx , yy print * , dy , dx write ( * , * ) 'vrt less than 0' print * , topvf , rightvf pause 'PredictorUV_1068' end if return END SUBROUTINE SUBROUTINE CellGeoCal ( nxs , nys , phis , nxl , nyl , phil , dx , dy , vols , volf ) IMPLICIT NONE REAL ( KIND = dp ), INTENT ( IN ) :: nxs , nys , phis , nxl , nyl , phil , dx , dy REAL ( KIND = dp ), INTENT ( OUT ) :: vols , volf REAL ( KIND = dp ), DIMENSION (:,:) :: node ( 6 , 2 ), nodel ( 7 , 2 ) INTEGER ( kind = it4b ) :: temp , templ , k REAL ( KIND = dp ) :: dx2 , dy2 , pdt ( 6 ), dpt ( 4 ), vol , epsil epsil = 1.d-24 dx2 = dx / 2.d0 dy2 = dy / 2.d0 temp = 1 node = 0.d0 ! calculate the distance of all cell's nodes to interface dpt ( 1 ) = dx2 * nxs - dy2 * nys + phis dpt ( 2 ) = - dx2 * nxs - dy2 * nys + phis dpt ( 3 ) = - dx2 * nxs + dy2 * nys + phis dpt ( 4 ) = dx2 * nxs + dy2 * nys + phis ! find nodes those belong to fluid field(including the cutting nodes between ! interface and cell edges) If ( dpt ( 1 ) >= 0.d0 ) then node ( temp , 1 ) = dx2 node ( temp , 2 ) = - dy2 temp = temp + 1 End if If ( dpt ( 1 ) * dpt ( 2 ) < 0.d0 ) then node ( temp , 1 ) = ( dy2 * nys - phis ) / nxs node ( temp , 2 ) = - dy2 temp = temp + 1 End if If ( dpt ( 2 ) >= 0.d0 ) then node ( temp , 1 ) = - dx2 node ( temp , 2 ) = - dy2 temp = temp + 1 End if If ( dpt ( 2 ) * dpt ( 3 ) < 0.d0 ) then node ( temp , 1 ) = - dx2 node ( temp , 2 ) = ( dx2 * nxs - phis ) / nys temp = temp + 1 End if If ( dpt ( 3 ) >= 0.d0 ) then node ( temp , 1 ) = - dx2 node ( temp , 2 ) = dy2 temp = temp + 1 End if If ( dpt ( 3 ) * dpt ( 4 ) < 0.d0 ) then node ( temp , 1 ) = ( - dy2 * nys - phis ) / nxs node ( temp , 2 ) = dy2 temp = temp + 1 End if If ( dpt ( 4 ) >= 0.d0 ) then node ( temp , 1 ) = dx2 node ( temp , 2 ) = dy2 temp = temp + 1 End if If ( dpt ( 4 ) * dpt ( 1 ) < 0.d0 ) then node ( temp , 1 ) = dx2 node ( temp , 2 ) = ( - dx2 * nxs - phis ) / nys temp = temp + 1 End if node ( temp , 1 ) = node ( 1 , 1 ) node ( temp , 2 ) = node ( 1 , 2 ) vol = 0.d0 ! applying Gauss theorem to find the volume of both fluid and gas do k = 1 , temp - 1 vol = vol + 0.5d0 * ( node ( k , 1 ) * node ( k + 1 , 2 ) - node ( k + 1 , 1 ) * node ( k , 2 )) pdt ( k ) = node ( k , 1 ) * nxl + node ( k , 2 ) * nyl + phil end do ! Volume fraction of solid in given cell vols = 1.d0 - dabs ( vol / ( dx * dy )) pdt ( temp ) = pdt ( 1 ) ! find the volume of liquid inside cell templ = 1 do k = 1 , temp - 1 if ( pdt ( k ) <= 0.d0 ) then nodel ( templ , 1 ) = node ( k , 1 ) nodel ( templ , 2 ) = node ( k , 2 ) templ = templ + 1 end if if ( pdt ( k ) * pdt ( k + 1 ) < 0.d0 ) then nodel ( templ , 1 ) = node ( k , 1 ) + ( node ( k + 1 , 1 ) - node ( k , 1 )) * dabs ( pdt ( k )) / & ( dabs ( pdt ( k )) + dabs ( pdt ( k + 1 ))) nodel ( templ , 2 ) = node ( k , 2 ) + ( node ( k + 1 , 2 ) - node ( k , 2 )) * dabs ( pdt ( k )) / & ( dabs ( pdt ( k )) + dabs ( pdt ( k + 1 ))) templ = templ + 1 end if end do nodel ( templ , 1 ) = nodel ( 1 , 1 ) nodel ( templ , 2 ) = nodel ( 1 , 2 ) vol = 0.d0 do k = 1 , templ - 1 vol = vol + 0.5d0 * ( nodel ( k , 1 ) * nodel ( k + 1 , 2 ) - nodel ( k + 1 , 1 ) * nodel ( k , 2 )) end do volf = dabs ( vol / ( dx * dy )) end subroutine CellGeoCal function MUSCLLimiter ( x , opt , tolim ) result ( y ) REAL ( KIND = dp ), INTENT ( IN ) :: x INTEGER ( kind = it4b ), INTENT ( IN ) :: opt REAL ( KIND = dp ), INTENT ( IN ) :: tolim REAL ( KIND = dp ) :: y select case ( opt ) ! MinMod limiter case ( 1 ) y = dmax1 ( 0.d0 , dmin1 ( tolim , x )) ! SuperBee limiter case ( 2 ) y = dmax1 ( 0.d0 , dmin1 ( tolim * x , 1.d0 ), dmin1 ( x , tolim )) end select end function MUSCLLimiter end module PredictorUV","tags":"","loc":"sourcefile/predictoruv_mod.f90.html","title":"PredictorUV_mod.f90 – Fortran Program"},{"text":"Contents Modules Matrix Source Code Matrix_Mod.f90 Source Code Module Matrix use precisionvar IMPLICIT NONE contains subroutine inverse ( a , c , n ) !*********************************************************** ! Inverse matrix ! Method: Based on Doolittle LU factorization for Ax=b ! Alex G. December 2009 !----------------------------------------------------------- ! input ... ! a(n,n) - array of coefficients for matrix A ! n      - DIMENSION ! output ... ! c(n,n) - inverse matrix of A ! comments ... ! the original matrix a(n,n) will be destroyed ! during the calculation !=========================================================== IMPLICIT NONE INTEGER n REAL ( KIND = dp ) :: a ( n , n ), c ( n , n ) REAL ( KIND = dp ) :: L ( n , n ), U ( n , n ), b ( n ), d ( n ), x ( n ) REAL ( KIND = dp ) :: coeff INTEGER i , j , k ! step 0: initialization for matrices L and U and b ! Fortran 90/95 aloows such operations on matrices L = 0.d0 U = 0.d0 b = 0.d0 ! step 1: forward elimination do k = 1 , n - 1 do i = k + 1 , n coeff = a ( i , k ) / a ( k , k ) L ( i , k ) = coeff do j = k + 1 , n a ( i , j ) = a ( i , j ) - coeff * a ( k , j ) end do end do end do ! Step 2: prepare L and U matrices ! L matrix is a matrix of the elimination coefficient ! + the diagonal elements are 1.0 do i = 1 , n L ( i , i ) = 1.d0 end do ! U matrix is the upper triangular part of A do j = 1 , n do i = 1 , j U ( i , j ) = a ( i , j ) end do end do ! Step 3: compute columns of the inverse matrix C do k = 1 , n b ( k ) = 1.d0 d ( 1 ) = b ( 1 ) ! Step 3a: Solve Ld=b using the forward substitution do i = 2 , n d ( i ) = b ( i ) do j = 1 , i - 1 d ( i ) = d ( i ) - L ( i , j ) * d ( j ) end do end do ! Step 3b: Solve Ux=d using the back substitution x ( n ) = d ( n ) / U ( n , n ) do i = n - 1 , 1 , - 1 x ( i ) = d ( i ) do j = n , i + 1 , - 1 x ( i ) = x ( i ) - U ( i , j ) * x ( j ) end do x ( i ) = x ( i ) / u ( i , i ) end do ! Step 3c: fill the solutions x(n) into column k of C do i = 1 , n c ( i , k ) = x ( i ) end do b ( k ) = 0.d0 end do end subroutine inverse subroutine Matrixinv ( a , b , n ) ! subroutine to calculate the inverse of a matrix using Gauss-Jordan elimination ! the inverse of matrix a(n,n) is calculated and stored in the matrix b(n,n) INTEGER :: i , j , k , l , m , n , irow double precision :: big , a ( n , n ), b ( n , n ), dum !build the identity matrix do i = 1 , n do j = 1 , n b ( i , j ) = 0.d0 end do b ( i , i ) = 1.d0 end do do i = 1 , n ! this is the big loop over all the columns of a(n,n) ! in case the entry a(i,i) is zero, we need to find a good pivot; this pivot ! is chosen as the largest value on the column i from a(j,i) with j = 1,n big = a ( i , i ) do j = i , n if ( dabs ( a ( j , i )). gt . big ) then big = dabs ( a ( j , i )) irow = j end if end do ! interchange lines i with irow for both a() and b() matrices if ( big . gt . a ( i , i )) then do k = 1 , n dum = a ( i , k ) ! matrix a() a ( i , k ) = a ( irow , k ) a ( irow , k ) = dum dum = b ( i , k ) ! matrix b() b ( i , k ) = b ( irow , k ) b ( irow , k ) = dum end do end if ! divide all entries in line i from a(i,j) by the value a(i,i); ! same operation for the identity matrix dum = a ( i , i ) if ( dum == 0.d0 ) then pause 'matrixinv 126' end if do j = 1 , n a ( i , j ) = a ( i , j ) / dum b ( i , j ) = b ( i , j ) / dum end do ! make zero all entries in the column a(j,i); same operation for indent() do j = i + 1 , n dum = a ( j , i ) do k = 1 , n a ( j , k ) = a ( j , k ) - dum * a ( i , k ) b ( j , k ) = b ( j , k ) - dum * b ( i , k ) end do end do end do ! substract appropiate multiple of row j from row j-1 do i = 1 , n - 1 do j = i + 1 , n dum = a ( i , j ) do l = 1 , n a ( i , l ) = a ( i , l ) - dum * a ( j , l ) b ( i , l ) = b ( i , l ) - dum * b ( j , l ) end do end do end do end function sech ( x ) result ( y ) IMPLICIT NONE REAL ( KIND = dp ), INTENT ( IN ) :: x REAL ( KIND = dp ) :: y y = 2.d0 / ( exp ( x ) + exp ( - x )) end function sech function dsech ( x ) result ( y ) IMPLICIT NONE REAL ( KIND = dp ), INTENT ( IN ) :: x REAL ( KIND = dp ) :: y y =- tanh ( x ) * sech ( x ) end function dsech End module Matrix","tags":"","loc":"sourcefile/matrix_mod.f90.html","title":"Matrix_Mod.f90 – Fortran Program"},{"text":"Contents Modules MPI Source Code MPI_Mod.f90 Source Code Module MPI IMPLICIT NONE Include 'mpif.h' Include 'HYPREf.h' INTEGER :: ierr , num_procs , myid Contains Subroutine MPI_Initial Call MPI_Init ( ierr ) Call MPI_Comm_rank ( MPI_COMM_WORLD , myid , ierr ) Call MPI_Comm_size ( MPI_COMM_WORLD , num_procs , ierr ) End subroutine MPI_Initial End module MPI","tags":"","loc":"sourcefile/mpi_mod.f90.html","title":"MPI_Mod.f90 – Fortran Program"},{"text":"Contents Modules PrecisionVar Source Code PrecisionVar_Mod.f90 Source Code Module PrecisionVar IMPLICIT NONE INTEGER , PARAMETER :: sp = selected_real_kind ( 6 , 35 ) ! 10 digit after \",\"  and form 10&#94;-35 to 10&#94;35 INTEGER , PARAMETER :: dp = selected_real_kind ( 15 , 307 ) ! 20 digit after \",\" and from 10&#94;-307 to 10&#94;307 INTEGER , PARAMETER :: it1b = selected_int_kind ( 2 ) ! from -10&#94;2 to 10&#94;2 INTEGER , PARAMETER :: it2b = selected_int_kind ( 3 ) ! from -10&#94;3 to 10&#94;3 INTEGER , PARAMETER :: it4b = selected_int_kind ( 6 ) ! from -10&#94;6 to 10&#94;6 INTEGER , PARAMETER :: it8b = selected_int_kind ( 12 ) ! from -10&#94;12 to 10&#94;12 End module","tags":"","loc":"sourcefile/precisionvar_mod.f90.html","title":"PrecisionVar_Mod.f90 – Fortran Program"},{"text":"Contents Modules vtr Source Code VTR_mod.f90 Source Code module vtr !! VTR_mod.f90 --- XML VTR ASCII data file !! !! Auteur          : Jalel Chergui (LIMSI-CNRS) <Jalel.Chergui@limsi.fr> !! Dern. mod. par  : Jalel Chergui (LIMSI-CNRS) <Jalel.Chergui@limsi.fr> !! Dern. mod. le   : Wed Sep 16 14:36:29 2009 use PrecisionVar use StateVariables IMPLICIT NONE PRIVATE INTEGER , PARAMETER :: s = selected_real_kind ( 6 ) INTEGER , PARAMETER :: d = selected_real_kind ( 12 ) character ( len = 1 ), PARAMETER :: newline = achar ( 10 ) INTEGER :: iproc = 0 , nb_procs = 1 TYPE , public :: VTR_file_handle PRIVATE character ( len = 80 ) :: prefix INTEGER :: unit INTEGER :: ni , nj , nk INTEGER :: counter = 0 INTEGER :: restart = 0 logical :: first = . true . end TYPE VTR_file_handle PRIVATE :: handle_error , handle_warning , handle_info PRIVATE :: VTR_write_mesh_2d , VTR_write_mesh_3d , & VTR_write_vector_2d , VTR_write_vector_3d , & VTR_write_scalar_2d , VTR_write_scalar_3d public :: VTR_open_file , & VTR_write_mesh , & VTR_write_var , & VTR_close_file , & VTR_collect_file interface VTR_write_mesh module procedure VTR_write_mesh_2d , VTR_write_mesh_3d end interface interface VTR_write_var module procedure VTR_write_scalar_2d , VTR_write_scalar_3d , & VTR_write_vector_2d , VTR_write_vector_3d end interface contains subroutine handle_error ( name , message ) IMPLICIT NONE character ( len =* ), INTENT ( IN ) :: name , message INTEGER :: code , errcode = 92 print '(/,\"   *** Error *** \", A,\": \", A,/)' , name , message stop end subroutine handle_error subroutine handle_warning ( name , message ) IMPLICIT NONE character ( len =* ), INTENT ( IN ) :: name , message print '(/,\"   *** Warning *** \",A,\": \", A,/)' , name , message end subroutine handle_warning subroutine handle_info ( name , message ) IMPLICIT NONE character ( len =* ), INTENT ( IN ) :: name , message print '(/,\"   *** Info *** \",A,\": \", A,/)' , name , message end subroutine handle_info subroutine VTR_open_file ( prefix , proc_rank , num_procs , restart , itera , fd ) IMPLICIT NONE character ( len =* ), INTENT ( IN ) :: prefix INTEGER , optional , INTENT ( IN ) :: proc_rank , num_procs , restart INTEGER ( kind = it8b ), optional , INTENT ( IN ) :: itera TYPE ( VTR_file_handle ), INTENT ( INOUT ) :: fd character ( len = 10 ) :: rank , snapshot character ( len = 80 ) :: f INTEGER :: err , iproc logical :: file_opened !... Looking for a none connected logical file unit. fd % prefix = trim ( prefix ) fd % unit = 99 inquire ( unit = fd % unit , opened = file_opened ) do while ( file_opened . and . fd % unit /= 0 ) fd % unit = fd % unit - 1 inquire ( unit = fd % unit , opened = file_opened ) end do if ( fd % unit == 0 . and . file_opened ) then call handle_error ( \"VTR_open_file\" , \"All file units from 0 to 99 are already connected.\" ) stop else if ( present ( proc_rank ) . and . present ( num_procs ) ) then iproc = proc_rank nb_procs = num_procs else if ( present ( proc_rank ) ) then call handle_error ( \"VTK_open_file\" , \"Both PROC_RANK and NUM_PROCS arguments must be present.\" ) else if ( present ( num_procs ) ) then call handle_error ( \"VTK_open_file\" , \"Both PROC_RANK and NUM_PROCS arguments must be present.\" ) end if if (( fd % first ) . and . ( present ( restart ))) then fd % restart = restart fd % counter = restart fd % first = . false . end if fd % counter = fd % counter + 1 if ( present ( itera )) fd % counter = itera write ( snapshot , '(i8.8)' ) fd % counter if ( present ( proc_rank ) ) then write ( rank , '(i8)' ) iproc if ( present ( itera )) then f = trim ( adjustl ( dir )) // 'Paraview/' // trim ( fd % prefix ) // & trim ( adjustl ( rank )) // \"_\" // trim ( adjustl ( snapshot )) // \".vtr\" end if else if ( present ( itera )) then f = trim ( adjustl ( dir )) // 'Paraview/' // trim ( fd % prefix ) // \"_\" // & trim ( adjustl ( snapshot )) // \".vtr\" end if end if open ( unit = fd % unit , file = trim ( adjustl ( f )), form = \"FORMATTED\" , status = \"replace\" , & action = \"write\" , iostat = err ) if ( err /= 0 ) print '(\"Problem creating file \",a,\".\")' , trim ( f ) end if write ( unit = fd % unit , fmt = '(100A)' ) '<VTKFile type=\"RectilinearGrid\" version=\"0.1\" format=\"ascii\">' end subroutine VTR_open_file subroutine VTR_write_mesh_2d ( fd , x , y ) IMPLICIT NONE TYPE ( VTR_file_handle ), INTENT ( INOUT ) :: fd REAL ( KIND = dp ), INTENT ( IN ), DIMENSION (:) :: x , y character ( len = 10 ) :: buf1 , buf2 fd % ni = size ( x ) ; fd % nj = size ( y ) write ( buf1 , '(I6)' ) fd % ni write ( buf2 , '(I6)' ) fd % nj write ( unit = fd % unit , fmt = '(100A)' ) ' <RectilinearGrid WholeExtent=\"1 ' // trim ( adjustl ( buf1 )) // & & ' 1 ' // trim ( adjustl ( buf2 )) // ' 1 1 ' // '\">' write ( unit = fd % unit , fmt = '(100A)' ) '  <Piece Extent=\"1 ' // trim ( adjustl ( buf1 )) // ' 1 ' // & & trim ( adjustl ( buf2 )) // ' 1 1 ' // '\">' write ( unit = fd % unit , fmt = '(100A)' ) '   <Coordinates>' write ( unit = fd % unit , fmt = '(100A)' ) '    <DataArray type=\"Float32\" Name=\"X_COORDINATES\" NumberOfComponents=\"1\" format=\"ascii\">' write ( unit = fd % unit , fmt =* ) real ( x ( 1 : fd % ni ), kind = s ) write ( unit = fd % unit , fmt = '(100A)' ) '    </DataArray>' write ( unit = fd % unit , fmt = '(100A)' ) '    <DataArray type=\"Float32\" Name=\"Y_COORDINATES\" NumberOfComponents=\"1\" format=\"ascii\">' write ( unit = fd % unit , fmt =* ) real ( y ( 1 : fd % nj ), kind = s ) write ( unit = fd % unit , fmt = '(100A)' ) '    </DataArray>' write ( unit = fd % unit , fmt = '(100A)' ) '    <DataArray type=\"Float32\" Name=\"Z_COORDINATES\" NumberOfComponents=\"1\" format=\"ascii\">' write ( unit = fd % unit , fmt =* ) real ( 0.0 _ d , kind = s ) write ( unit = fd % unit , fmt = '(100A)' ) '    </DataArray>' write ( unit = fd % unit , fmt = '(100A)' ) '   </Coordinates>' write ( unit = fd % unit , fmt = '(100A)' ) '   <PointData>' end subroutine VTR_write_mesh_2d subroutine VTR_write_mesh_3d ( fd , x , y , z ) IMPLICIT NONE TYPE ( VTR_file_handle ), INTENT ( INOUT ) :: fd REAL ( KIND = dp ), INTENT ( IN ), DIMENSION (:) :: x , y , z character ( len = 10 ) :: buf1 , buf2 , buf3 fd % ni = size ( x ) ; fd % nj = size ( y ) ; fd % nk = size ( z ) write ( buf1 , '(I6)' ) fd % ni write ( buf2 , '(I6)' ) fd % nj write ( buf3 , '(I6)' ) fd % nk write ( unit = fd % unit , fmt = '(100A)' ) ' <RectilinearGrid WholeExtent=\"1 ' // trim ( adjustl ( buf1 )) // & & ' 1 ' // trim ( adjustl ( buf2 )) // ' 1 ' // trim ( adjustl ( buf3 )) // '\">' write ( unit = fd % unit , fmt = '(100A)' ) '  <Piece Extent=\"1 ' // trim ( adjustl ( buf1 )) // ' 1 ' // & & trim ( adjustl ( buf2 )) // ' 1 ' // trim ( adjustl ( buf3 )) // '\">' write ( unit = fd % unit , fmt = '(100A)' ) '   <Coordinates>' write ( unit = fd % unit , fmt = '(100A)' ) '    <DataArray type=\"Float32\" Name=\"X_COORDINATES\" NumberOfComponents=\"1\" format=\"ascii\">' write ( unit = fd % unit , fmt =* ) real ( x ( 1 : fd % ni ), kind = s ) write ( unit = fd % unit , fmt = '(100A)' ) '    </DataArray>' write ( unit = fd % unit , fmt = '(100A)' ) '    <DataArray type=\"Float32\" Name=\"Y_COORDINATES\" NumberOfComponents=\"1\" format=\"ascii\">' write ( unit = fd % unit , fmt =* ) real ( y ( 1 : fd % nj ), kind = s ) write ( unit = fd % unit , fmt = '(100A)' ) '    </DataArray>' write ( unit = fd % unit , fmt = '(100A)' ) '    <DataArray type=\"Float32\" Name=\"Z_COORDINATES\" NumberOfComponents=\"1\" format=\"ascii\">' write ( unit = fd % unit , fmt =* ) real ( z ( 1 : fd % nk ), kind = s ) write ( unit = fd % unit , fmt = '(100A)' ) '    </DataArray>' write ( unit = fd % unit , fmt = '(100A)' ) '   </Coordinates>' write ( unit = fd % unit , fmt = '(100A)' ) '   <PointData>' end subroutine VTR_write_mesh_3d subroutine VTR_write_vector_2d ( fd , name , vx , vy ) IMPLICIT NONE TYPE ( VTR_file_handle ), INTENT ( IN ) :: fd character ( len =* ), INTENT ( IN ) :: name REAL ( KIND = dp ), INTENT ( IN ), DIMENSION (:,:) :: vx , vy REAL ( KIND = dp ), allocatable , DIMENSION (:,:,:) :: velocity INTEGER :: i , j , code character ( len = 256 ) :: uname , vname if (( size ( vx , dim = 1 ) /= fd % ni ) . or . & ( size ( vx , dim = 2 ) /= fd % nj ) ) call handle_warning ( \"VTR_write_var\" , \"Incompatible Vx component and mesh sizes.\" ) if (( size ( vy , dim = 1 ) /= fd % ni ) . or . & ( size ( vy , dim = 2 ) /= fd % nj ) ) call handle_warning ( \"VTR_write_var\" , \"Incompatible Vy component and mesh sizes.\" ) if (. not . Allocated ( velocity )) then Allocate ( velocity ( 3 , 1 : fd % ni , 1 : fd % nj ), STAT = code ) if ( code /= 0 ) & call handle_error ( \"VTR_write_var\" , \"Not enough memory to Allocate VELOCITY array\" ) end if do j = 1 , fd % nj do i = 1 , fd % ni velocity ( 1 , i , j ) = vx ( i , j ) velocity ( 2 , i , j ) = vy ( i , j ) velocity ( 3 , i , j ) = 0.0 _ d end do end do write ( unit = fd % unit , fmt = '(100A)' ) '        <DataArray type=\"Float32\" Name=\"' // & & trim ( adjustl ( name )) // '\" NumberOfComponents=\"3\" format=\"ascii\">' write ( unit = fd % unit , fmt =* ) real ( Velocity (:, 1 : fd % ni , 1 : fd % nj ), kind = s ) write ( unit = fd % unit , fmt = '(100A)' ) '        </DataArray>' uname = \"X_\" // name write ( unit = fd % unit , fmt = '(100A)' ) '        <DataArray type=\"Float32\" Name=\"' // & & trim ( adjustl ( uname )) // '\" NumberOfComponents=\"1\" format=\"ascii\">' write ( unit = fd % unit , fmt =* ) real ( velocity ( 1 , 1 : fd % ni , 1 : fd % nj ), kind = s ) write ( unit = fd % unit , fmt = '(100A)' ) '        </DataArray>' vname = \"Y_\" // name write ( unit = fd % unit , fmt = '(100A)' ) '        <DataArray type=\"Float32\" Name=\"' // & & trim ( adjustl ( vname )) // '\" NumberOfComponents=\"1\" format=\"ascii\">' write ( unit = fd % unit , fmt =* ) real ( velocity ( 2 , 1 : fd % ni , 1 : fd % nj ), kind = s ) write ( unit = fd % unit , fmt = '(100A)' ) '        </DataArray>' if ( Allocated ( velocity )) deAllocate ( velocity ) end subroutine VTR_write_vector_2d subroutine VTR_write_vector_3d ( fd , name , vx , vy , vz ) IMPLICIT NONE TYPE ( VTR_file_handle ), INTENT ( IN ) :: fd character ( len =* ), INTENT ( IN ) :: name REAL ( KIND = dp ), INTENT ( IN ), DIMENSION (:,:,:) :: vx , vy , vz REAL ( KIND = dp ), allocatable , DIMENSION (:,:,:,:) :: velocity INTEGER :: i , j , k , code character ( len = 256 ) :: uname , vname , wname if (( size ( vx , dim = 1 ) /= fd % ni ) . or . & ( size ( vx , dim = 2 ) /= fd % nj ) . or . & ( size ( vx , dim = 3 ) /= fd % nk )) call handle_warning ( \"VTR_write_var\" , \"Incompatible Vx component and mesh sizes.\" ) if (( size ( vy , dim = 1 ) /= fd % ni ) . or . & ( size ( vy , dim = 2 ) /= fd % nj ) . or . & ( size ( vy , dim = 3 ) /= fd % nk )) call handle_warning ( \"VTR_write_var\" , \"Incompatible Vy component and mesh sizes.\" ) if (( size ( vz , dim = 1 ) /= fd % ni ) . or . & ( size ( vz , dim = 2 ) /= fd % nj ) . or . & ( size ( vz , dim = 3 ) /= fd % nk )) call handle_warning ( \"VTR_write_var\" , \"Incompatible Vz component and mesh sizes.\" ) if (. not . Allocated ( velocity )) then Allocate ( velocity ( 3 , 1 : fd % ni , 1 : fd % nj , 1 : fd % nk ), STAT = code ) if ( code /= 0 ) & call handle_error ( \"VTR_write_var\" , \"Not enough memory to Allocate VELOCITY array\" ) end if do k = 1 , fd % nk do j = 1 , fd % nj do i = 1 , fd % ni velocity ( 1 , i , j , k ) = vx ( i , j , k ) velocity ( 2 , i , j , k ) = vy ( i , j , k ) velocity ( 3 , i , j , k ) = vz ( i , j , k ) end do end do end do write ( unit = fd % unit , fmt = '(100A)' ) '        <DataArray type=\"Float32\" Name=\"' // & & trim ( adjustl ( name )) // '\" NumberOfComponents=\"3\" format=\"ascii\">' write ( unit = fd % unit , fmt =* ) real ( Velocity (:, 1 : fd % ni , 1 : fd % nj , 1 : fd % nk ), kind = s ) write ( unit = fd % unit , fmt = '(100A)' ) '        </DataArray>' uname = \"X_\" // name write ( unit = fd % unit , fmt = '(100A)' ) '        <DataArray type=\"Float32\" Name=\"' // & & trim ( adjustl ( uname )) // '\" NumberOfComponents=\"1\" format=\"ascii\">' write ( unit = fd % unit , fmt =* ) real ( velocity ( 1 , 1 : fd % ni , 1 : fd % nj , 1 : fd % nk ), kind = s ) write ( unit = fd % unit , fmt = '(100A)' ) '        </DataArray>' vname = \"Y_\" // name write ( unit = fd % unit , fmt = '(100A)' ) '        <DataArray type=\"Float32\" Name=\"' // & & trim ( adjustl ( vname )) // '\" NumberOfComponents=\"1\" format=\"ascii\">' write ( unit = fd % unit , fmt =* ) real ( velocity ( 2 , 1 : fd % ni , 1 : fd % nj , 1 : fd % nk ), kind = s ) write ( unit = fd % unit , fmt = '(100A)' ) '        </DataArray>' wname = \"Z_\" // name write ( unit = fd % unit , fmt = '(100A)' ) '        <DataArray type=\"Float32\" Name=\"' // & & trim ( adjustl ( wname )) // '\" NumberOfComponents=\"1\" format=\"ascii\">' write ( unit = fd % unit , fmt =* ) real ( velocity ( 3 , 1 : fd % ni , 1 : fd % nj , 1 : fd % nk ), kind = s ) write ( unit = fd % unit , fmt = '(100A)' ) '        </DataArray>' if ( Allocated ( velocity )) deAllocate ( velocity ) end subroutine VTR_write_vector_3d subroutine VTR_write_scalar_2d ( fd , name , field ) IMPLICIT NONE TYPE ( VTR_file_handle ), INTENT ( IN ) :: fd character ( len =* ), INTENT ( IN ) :: name REAL ( KIND = dp ), INTENT ( IN ), DIMENSION (:,:) :: field if (( size ( field , dim = 1 ) /= fd % ni ) . or . & ( size ( field , dim = 2 ) /= fd % nj )) call handle_warning ( \"VTR_write_var\" , \"Incompatible FIELD and MESH sizes.\" ) write ( unit = fd % unit , fmt = '(100A)' ) '         <DataArray type=\"Float32\" Name=\"' // & & trim ( adjustl ( name )) // '\" NumberOfComponents=\"1\" format=\"ascii\">' write ( unit = fd % unit , fmt =* ) real ( field ( 1 : fd % ni , 1 : fd % nj ), kind = s ) write ( unit = fd % unit , fmt = '(100A)' ) '         </DataArray>' end subroutine VTR_write_scalar_2d subroutine VTR_write_scalar_3d ( fd , name , field ) IMPLICIT NONE TYPE ( VTR_file_handle ), INTENT ( IN ) :: fd character ( len =* ), INTENT ( IN ) :: name REAL ( KIND = dp ), INTENT ( IN ), DIMENSION (:,:,:) :: field if (( size ( field , dim = 1 ) /= fd % ni ) . or . & ( size ( field , dim = 2 ) /= fd % nj ) . or . & ( size ( field , dim = 3 ) /= fd % nk )) call handle_warning ( \"VTR_write_var\" , \"Incompatible FIELD and MESH sizes.\" ) write ( unit = fd % unit , fmt = '(100A)' ) '         <DataArray type=\"Float32\" Name=\"' // & & trim ( adjustl ( name )) // '\" NumberOfComponents=\"1\" format=\"ascii\">' write ( unit = fd % unit , fmt =* ) real ( field ( 1 : fd % ni , 1 : fd % nj , 1 : fd % nk ), kind = s ) write ( unit = fd % unit , fmt = '(100A)' ) '         </DataArray>' end subroutine VTR_write_scalar_3d subroutine VTR_close_file ( fd ) IMPLICIT NONE TYPE ( VTR_file_handle ), INTENT ( INOUT ) :: fd logical :: file_opened inquire ( unit = fd % unit , opened = file_opened ) if ( file_opened ) then write ( unit = fd % unit , fmt = '(100A)' ) '     </PointData>' write ( unit = fd % unit , fmt = '(100A)' ) '   </Piece>' write ( unit = fd % unit , fmt = '(100A)' ) '  </RectilinearGrid>' write ( unit = fd % unit , fmt = '(100A)' ) '</VTKFile>' close ( unit = fd % unit ) else call handle_warning ( \"VTR_close_file\" , \"No such file to close. Please, check file descriptor.\" ) end if end subroutine VTR_close_file subroutine VTR_collect_file ( fd ) IMPLICIT NONE TYPE ( VTR_file_handle ), INTENT ( INOUT ) :: fd character ( len = 10 ) :: rank , snapshot character ( len = 80 ) :: f , vtrfile INTEGER :: shot , code , err , nt , np , k logical :: file_opened !... Looking for a none connected logical file unit. if ( iproc == 0 ) then fd % unit = 99 inquire ( unit = fd % unit , opened = file_opened ) do while ( file_opened . and . fd % unit /= 0 ) fd % unit = fd % unit - 1 inquire ( unit = fd % unit , opened = file_opened ) end do if ( fd % unit == 0 . and . file_opened ) then call handle_warning ( \"VTR_open_file\" , \"warning, all file units from 0 to 99 are already connected.\" ) else f = trim ( adjustl ( fd % prefix )) // \".pvd\" open ( unit = fd % unit , file = trim ( adjustl ( f )), form = \"FORMATTED\" , status = \"replace\" , & action = \"write\" , iostat = err ) if ( err /= 0 ) print '(\"VTR_collect_file: Error, problem creating file \",a,\".\")' , trim ( f ) write ( unit = fd % unit , fmt = '(100A)' ) '<?xml version=\"1.0\"?>' write ( unit = fd % unit , fmt = '(100A)' ) '<VTKFile type=\"Collection\" version=\"0.1\" format=\"ascii\">' write ( unit = fd % unit , fmt = '(100A)' ) '  <Collection>' nt = len_trim ( fd % prefix ) np = scan ( STRING = fd % prefix , SET = \"/\" , BACK = . true .) vtrfile = fd % prefix ( np + 1 : nt ) if ( nb_procs == 1 ) then do shot = 1 , fd % counter write ( snapshot , '(i6)' ) shot write ( unit = fd % unit , fmt = '(100A)' ) '    <DataSet timestep=\"' // trim ( adjustl ( snapshot )) // & & '\" part=\"0' // '\" file=\"' // trim ( adjustl ( vtrfile )) // & & \"_\" // trim ( adjustl ( snapshot )) // '.vtr\"/>' end do else do k = 0 , nb_procs - 1 write ( rank , '(i6)' ) k do shot = 1 , fd % counter write ( snapshot , '(i6)' ) shot write ( unit = fd % unit , fmt = '(100A)' ) '    <DataSet timestep=\"' // trim ( adjustl ( snapshot )) // & & '\" part=\"' // trim ( adjustl ( rank )) // '\" file=\"' // & & trim ( adjustl ( vtrfile )) // \"_\" // trim ( adjustl ( rank )) // & & \"_\" // trim ( adjustl ( snapshot )) // '.vtr\"/>' end do end do end if write ( unit = fd % unit , fmt = '(100A)' ) '  </Collection>' write ( unit = fd % unit , fmt = '(100A)' ) '</VTKFile>' close ( unit = fd % unit ) end if end if fd % counter = 0 ; fd % restart = 0 ; fd % first = . true . ; iproc = 0 ; nb_procs = 1 end subroutine VTR_collect_file end module vtr","tags":"","loc":"sourcefile/vtr_mod.f90.html","title":"VTR_mod.f90 – Fortran Program"},{"text":"Contents Modules PrintResult Source Code PrintResult.f90 Source Code Module PrintResult USE PrecisionVar USE Mesh USE StateVariables , ONLY : ight , jght , variables , pi , Ktw , rey , xc , yc , End_Point , & roa , row , Fr , roref , Lref , dir USE Clsvof USE Cutcell USE VTK USE VTR USE Particles IMPLICIT NONE PRIVATE character ( len = 1 ), PARAMETER :: newline = achar ( 10 ) PUBLIC :: Print_Result_Tecplot_PCent , Print_Result_Tecplot_UCent , & Print_Result_Tecplot_VCent , Print_Result_VTK_2D , ReadOldDataPCell , & ReadOldDataVelocityCell , ReadOldDataParticle Interface Print_Result_Tecplot_PCent Module procedure Print_Result_Tecplot_PCent End Interface Print_Result_Tecplot_PCent Interface Print_Result_Tecplot_UCent Module procedure Print_Result_Tecplot_UCent End Interface Print_Result_Tecplot_UCent Interface Print_Result_Tecplot_VCent Module procedure Print_Result_Tecplot_VCent End Interface Print_Result_Tecplot_VCent Interface Print_Result_VTK_2D Module procedure Print_Result_VTK_2D End interface Interface ReadOldDataPCell Module procedure ReadOldDataPCell End interface Interface ReadOldDataVelocityCell Module procedure ReadOldDataVelocityCell End interface Interface ReadOldDataParticle Module procedure ReadOldDataParticle End interface Contains Subroutine Print_Result_Tecplot_PCent ( TGrid , TVar , TCell , TraPar , FluxP , iter , PriPar ) IMPLICIT NONE TYPE ( Grid ), INTENT ( IN ) :: TGrid TYPE ( Variables ), INTENT ( INOUT ) :: TVar TYPE ( Cell ), INTENT ( IN ) :: TCell TYPE ( Particle ), INTENT ( IN ) :: TraPar REAL ( KIND = dp ), INTENT ( IN ), DIMENSION (:,:,:), ALLOCATABLE :: FluxP INTEGER ( kind = it8b ), INTENT ( IN ) :: iter INTEGER ( kind = it4b ), INTENT ( IN ) :: PriPar INTEGER ( kind = it4b ) :: i , j REAL ( KIND = dp ), DIMENSION (:,:), allocatable :: p Character ( 15 ) :: curd Allocate ( p ( ibeg : ibeg + Isize - 1 , jbeg : jbeg + Jsize - 1 )) Do i = ibeg , ibeg + Isize - 1 Do j = jbeg , jbeg + Jsize - 1 If ( TCell % vof ( i , j ) >= 0.5d0 ) then p ( i , j ) = TVar % p ( i , j ) !+row/Roref*1.d0/Fr**2.d0*(End_Point%y-TGrid%y(i,j)) Else p ( i , j ) = TVar % p ( i , j ) !+roa/Roref*1.d0/Fr**2.d0*(End_Point%y-TGrid%y(i,j)) End if End do End do Write ( curd , '(i8.8)' ) iter Open ( unit = 5 , file = trim ( adjustl ( dir )) // 'Tecplot/Pressure_' // & trim ( curd ) // '.dat' , action = 'write' ) Write ( 5 , * ) 'title = \"flow\"' Write ( 5 , * ) 'variables =\"x\",\"y\",\"p\",\"u\",\"v\",\"phi\",\"vof\",\"phiS\",\"vofS\"' , & ',\"vofA\",\"Mres\",\"FluxU\",\"FluxV\",\"nxS\",\"nyS\"' Write ( 5 , 1112 ) Isize , Jsize Write ( 5 , \"(f24.14)\" )(( TGrid % x ( i , j ), i = ibeg , Isize + ibeg - 1 ), j = jbeg , Jsize + jbeg - 1 ) Write ( 5 , \"(f24.14)\" )(( TGrid % y ( i , j ), i = ibeg , Isize + ibeg - 1 ), j = jbeg , Jsize + jbeg - 1 ) Write ( 5 , \"(f24.14)\" )(( p ( i , j ), i = ibeg , Isize + ibeg - 1 ), j = jbeg , Jsize + jbeg - 1 ) write ( 5 , \"(f24.14)\" )(( 0.5d0 * ( TVar % u ( i - 1 , j ) + TVar % u ( i , j )), i = ibeg , Isize + ibeg - 1 ), j = jbeg , Jsize + jbeg - 1 ) write ( 5 , \"(f24.14)\" )(( 0.5d0 * ( TVar % v ( i , j - 1 ) + TVar % v ( i , j )), i = ibeg , Isize + ibeg - 1 ), j = jbeg , Jsize + jbeg - 1 ) Write ( 5 , \"(f24.14)\" )(( TCell % phi ( i , j ), i = ibeg , Isize + ibeg - 1 ), j = jbeg , Jsize + jbeg - 1 ) Write ( 5 , \"(f24.14)\" )(( TCell % vof ( i , j ), i = ibeg , Isize + ibeg - 1 ), j = jbeg , Jsize + jbeg - 1 ) Write ( 5 , \"(f24.14)\" )(( TCell % phiS ( i , j ), i = ibeg , Isize + ibeg - 1 ), j = jbeg , Jsize + jbeg - 1 ) Write ( 5 , \"(f24.14)\" )(( TCell % vofS ( i , j ), i = ibeg , Isize + ibeg - 1 ), j = jbeg , Jsize + jbeg - 1 ) Write ( 5 , \"(f24.14)\" )(( 1.d0 - TCell % vof ( i , j ) - TCell % vofS ( i , j ), i = ibeg , Isize + ibeg - 1 ), j = jbeg , Jsize + jbeg - 1 ) Write ( 5 , \"(f24.14)\" )(( TVar % mres ( i , j ), i = ibeg , Isize + ibeg - 1 ), j = jbeg , Jsize + jbeg - 1 ) write ( 5 , \"(f24.14)\" )(( FluxP ( i , j , 1 ), i = ibeg , Isize ), j = jbeg , Jsize ) write ( 5 , \"(f24.14)\" )(( FluxP ( i , j , 2 ), i = ibeg , Isize ), j = jbeg , Jsize ) write ( 5 , \"(f24.14)\" )(( TCell % nxS ( i , j ), i = ibeg , Isize + ibeg - 1 ), j = jbeg , Jsize + jbeg - 1 ) write ( 5 , \"(f24.14)\" )(( TCell % nyS ( i , j ), i = ibeg , Isize + ibeg - 1 ), j = jbeg , Jsize + jbeg - 1 ) Close ( 5 ) 1112 format ( 1 x , 'zone i=' , i5 , ',k=' , i5 , ',f=block' ) !  For Paraview if ( PriPar == 1 ) then Open ( unit = 5 , file = trim ( adjustl ( dir )) // 'Paraview/ParticlesVTR_' // & trim ( curd ) // '.txt' , action = 'write' ) Write ( 5 , * ) 'x,y,dp,up,vp' do i = 1 , Trapar % np write ( 5 , 70 ) TraPar % Posp ( i )% x / Lref , ',' , TraPar % Posp ( i )% y / Lref , ',' , & TraPar % dp ( i ) / Lref , ',' , TraPar % uvp ( i )% u / TVar % Uref , ',' , TraPar % uvp ( i )% v / TVar % Uref enddo close ( 5 ) end if !  For Tecplot if ( PriPar == 1 ) then Open ( unit = 5 , file = trim ( adjustl ( dir )) // 'Tecplot/' // & 'Particles_' // trim ( curd ) // '.dat' , action = 'write' ) Write ( 5 , * ) 'variables = \"x\",\"y\",\"dp\",\"up\",\"vp\"' Write ( 5 , * ) 'zone f=block, i=' , TraPar % np , 'j=' , 1 Write ( 5 , \"(f24.14)\" )( TraPar % Posp ( i )% x / Lref , i = 1 , TraPar % np ) Write ( 5 , \"(f24.14)\" )( TraPar % Posp ( i )% y / Lref , i = 1 , TraPar % np ) Write ( 5 , \"(f24.14)\" )( TraPar % dp ( i ) / Lref , i = 1 , TraPar % np ) Write ( 5 , \"(f24.14)\" )( TraPar % uvp ( i )% u / TVar % Uref , i = 1 , TraPar % np ) Write ( 5 , \"(f24.14)\" )( TraPar % uvp ( i )% v / TVar % Uref , i = 1 , TraPar % np ) Close ( 5 ) end if Deallocate ( p ) 70 format (( f24 . 14 ),( a3 ),( f24 . 14 ),( a3 ),( f24 . 14 ),( a3 ),( f24 . 14 ),( a3 ),( f24 . 14 )) End Subroutine Print_Result_Tecplot_PCent Subroutine Print_Result_Tecplot_UCent ( TGrid , TVar , TCell , itt ) IMPLICIT NONE TYPE ( Grid ), INTENT ( IN ) :: TGrid TYPE ( Variables ), INTENT ( IN ) :: TVar TYPE ( Cell ), INTENT ( IN ) :: TCell INTEGER ( kind = it8b ), INTENT ( IN ) :: itt INTEGER ( kind = it4b ) i , j Character ( 15 ) curd Write ( curd , '(i8.8)' ) itt Open ( unit = 5 , file = trim ( adjustl ( dir )) // 'Tecplot/' // & 'Uvelocity_' // trim ( curd ) // '.dat' , action = 'write' ) Write ( 5 , * ) 'title = \"flow\"' Write ( 5 , * ) 'variables =\"x\",\"y\",\"u\",\"phi\",\"vof\",\"phiS\",\"vofS\",\"vofA\"' Write ( 5 , 1113 ) Isize , Jsize Write ( 5 , \"(f24.14)\" )(( TGrid % x ( i , j ), i = ibeg , Isize + ibeg - 1 ), j = jbeg , Jsize + jbeg - 1 ) Write ( 5 , \"(f24.14)\" )(( TGrid % y ( i , j ), i = ibeg , Isize + ibeg - 1 ), j = jbeg , Jsize + jbeg - 1 ) Write ( 5 , \"(f24.14)\" )(( TVar % u ( i , j ), i = ibeg , Isize + ibeg - 1 ), j = jbeg , Jsize + jbeg - 1 ) Write ( 5 , \"(f24.14)\" )(( TCell % phi ( i , j ), i = ibeg , Isize + ibeg - 1 ), j = jbeg , Jsize + jbeg - 1 ) Write ( 5 , \"(f24.14)\" )(( TCell % vof ( i , j ), i = ibeg , Isize + ibeg - 1 ), j = jbeg , Jsize + jbeg - 1 ) Write ( 5 , \"(f24.14)\" )(( TCell % phiS ( i , j ), i = ibeg , Isize + ibeg - 1 ), j = jbeg , Jsize + jbeg - 1 ) Write ( 5 , \"(f24.14)\" )(( TCell % vofS ( i , j ), i = ibeg , Isize + ibeg - 1 ), j = jbeg , Jsize + jbeg - 1 ) Write ( 5 , \"(f24.14)\" )(( 1.d0 - TCell % vof ( i , j ) - TCell % vofS ( i , j ), i = ibeg , Isize + ibeg - 1 ), j = jbeg , Jsize + jbeg - 1 ) Close ( 5 ) 1113 format ( 1 x , 'zone i=' , i5 , ',k=' , i5 , ',f=block' ) End Subroutine Print_Result_Tecplot_UCent Subroutine Print_Result_Tecplot_VCent ( TGrid , TVar , TCell , itt ) IMPLICIT NONE TYPE ( Grid ), INTENT ( IN ) :: TGrid TYPE ( Variables ), INTENT ( IN ) :: TVar TYPE ( Cell ), INTENT ( IN ) :: TCell INTEGER ( kind = it8b ), INTENT ( IN ) :: itt INTEGER ( kind = it4b ) i , j Character ( 15 ) curd Write ( curd , '(i8.8)' ) itt Open ( unit = 5 , file = trim ( adjustl ( dir )) // 'Tecplot/' // & 'Vvelocity_' // trim ( curd ) // '.dat' , action = 'write' ) Write ( 5 , * ) 'title = \"flow\"' Write ( 5 , * ) 'variables =\"x\",\"y\",\"v\",\"phi\",\"vof\",\"phiS\",\"vofS\",\"vofA\"' Write ( 5 , 1114 ) Isize , Jsize Write ( 5 , \"(f24.14)\" )(( TGrid % x ( i , j ), i = ibeg , Isize + ibeg - 1 ), j = jbeg , Jsize + jbeg - 1 ) Write ( 5 , \"(f24.14)\" )(( TGrid % y ( i , j ), i = ibeg , Isize + ibeg - 1 ), j = jbeg , Jsize + jbeg - 1 ) Write ( 5 , \"(f24.14)\" )(( TVar % v ( i , j ), i = ibeg , Isize + ibeg - 1 ), j = jbeg , Jsize + jbeg - 1 ) Write ( 5 , \"(f24.14)\" )(( TCell % phi ( i , j ), i = ibeg , Isize + ibeg - 1 ), j = jbeg , Jsize + jbeg - 1 ) Write ( 5 , \"(f24.14)\" )(( TCell % vof ( i , j ), i = ibeg , Isize + ibeg - 1 ), j = jbeg , Jsize + jbeg - 1 ) Write ( 5 , \"(f24.14)\" )(( TCell % phiS ( i , j ), i = ibeg , Isize + ibeg - 1 ), j = jbeg , Jsize + jbeg - 1 ) Write ( 5 , \"(f24.14)\" )(( TCell % vofS ( i , j ), i = ibeg , Isize + ibeg - 1 ), j = jbeg , Jsize + jbeg - 1 ) Write ( 5 , \"(f24.14)\" )(( 1.d0 - TCell % vof ( i , j ) - TCell % vofS ( i , j ), i = ibeg , Isize + ibeg - 1 ), j = jbeg , Jsize + jbeg - 1 ) Close ( 5 ) 1114 format ( 1 x , 'zone i=' , i5 , ',k=' , i5 , ',f=block' ) End Subroutine Print_Result_Tecplot_VCent subroutine Print_Result_VTK_2D ( TGrid , TVar , TCell , itt ) IMPLICIT NONE TYPE ( Grid ), INTENT ( IN ) :: TGrid TYPE ( Variables ), INTENT ( IN ) :: TVar TYPE ( Cell ), INTENT ( IN ) :: TCell INTEGER ( kind = it8b ), INTENT ( IN ) :: itt TYPE ( VTR_file_handle ) :: fd call VTR_open_file ( Prefix = \"FlowField\" , itera = itt , FD = fd ) ! use keyword argument due to huge number of optional dummy argument ! so we need keyword argument to specify the location of actual argument call VTR_write_mesh ( fd , TGrid % x (:, 1 ), TGrid % y ( 1 ,:)) call VTR_write_var ( fd , \"Velocity\" , TVar % u ( 1 : Isize , 1 : Jsize ), TVar % v ( 1 : Isize , 1 : Jsize )) call VTR_write_var ( fd , \"Pressure\" , TVar % p ( 1 : Isize , 1 : Jsize )) call VTR_write_var ( fd , \"Levelset\" , TCell % phi (:,:)) call VTR_write_var ( fd , \"SolidLvs\" , TCell % phiS (:,:)) call VTR_Write_var ( fd , \"Vof\" , TCell % vof (:,:)) call VTR_Write_var ( fd , \"SolidVof\" , TCell % vofS (:,:)) call VTR_close_file ( fd ) !    call VTK_open_file(PREFIX=\"projectvtk\",FD=fd1) !    call VTK_write_mesh(FD=fd1,X=x1,Y=y1) !    call VTK_write_var(FD=fd1,Name=\"Velocity\",Vx=u,Vy=v) !    call VTK_write_var(FD=fd1,Name=\"Levelset\",FIELD=phi) !    call VTK_close_file(FD=fd1) end subroutine Print_Result_VTK_2D SUBROUTINE ReadOldDataPCell ( filename , TCell , TVar , FluxP ) IMPLICIT NONE CHARACTER ( LEN = 80 ), INTENT ( IN ) :: filename TYPE ( Variables ), INTENT ( INOUT ) :: TVar TYPE ( Cell ), INTENT ( INOUT ) :: TCell REAL ( KIND = dp ), INTENT ( INOUT ), DIMENSION (:,:,:), ALLOCATABLE :: FluxP INTEGER ( KIND = it4b ) :: i , j REAL ( KIND = dp ), DIMENSION (:,:), ALLOCATABLE :: VarRead allocate ( VarRead ( Isize , Jsize )) open ( unit = 5 , file = filename , action = 'read' ) read ( 5 , * ) read ( 5 , * ) read ( 5 , * ) read ( 5 , \"(f24.14)\" )(( VarRead ( i , j ), i = ibeg , Isize ), j = jbeg , Jsize ) read ( 5 , \"(f24.14)\" )(( VarRead ( i , j ), i = ibeg , Isize ), j = jbeg , Jsize ) read ( 5 , \"(f24.14)\" )(( TVar % p ( i , j ), i = ibeg , Isize ), j = jbeg , Jsize ) read ( 5 , \"(f24.14)\" )(( VarRead ( i , j ), i = ibeg , Isize ), j = jbeg , Jsize ) read ( 5 , \"(f24.14)\" )(( VarRead ( i , j ), i = ibeg , Isize ), j = jbeg , Jsize ) read ( 5 , \"(f24.14)\" )(( TCell % phi ( i , j ), i = ibeg , Isize ), j = jbeg , Jsize ) read ( 5 , \"(f24.14)\" )(( TCell % vof ( i , j ), i = ibeg , Isize ), j = jbeg , Jsize ) read ( 5 , \"(f24.14)\" )(( TCell % phiS ( i , j ), i = ibeg , Isize ), j = jbeg , Jsize ) read ( 5 , \"(f24.14)\" )(( TCell % vofS ( i , j ), i = ibeg , Isize ), j = jbeg , Jsize ) read ( 5 , \"(f24.14)\" )(( VarRead ( i , j ), i = ibeg , Isize ), j = jbeg , Jsize ) read ( 5 , \"(f24.14)\" )(( VarRead ( i , j ), i = ibeg , Isize ), j = jbeg , Jsize ) read ( 5 , \"(f24.14)\" )(( FluxP ( i , j , 1 ), i = ibeg , Isize ), j = jbeg , Jsize ) read ( 5 , \"(f24.14)\" )(( FluxP ( i , j , 2 ), i = ibeg , Isize ), j = jbeg , Jsize ) read ( 5 , \"(f24.14)\" )(( TCell % nxS ( i , j ), i = ibeg , Isize ), j = jbeg , Jsize ) read ( 5 , \"(f24.14)\" )(( TCell % nyS ( i , j ), i = ibeg , Isize ), j = jbeg , Jsize ) close ( 5 ) deallocate ( VarRead ) END SUBROUTINE ReadOldDataPCell SUBROUTINE ReadOldDataVelocityCell ( filename , TCell , UVVel ) IMPLICIT NONE CHARACTER ( LEN = 80 ), INTENT ( IN ) :: filename REAL ( KIND = dp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: UVVel TYPE ( Cell ), INTENT ( INOUT ) :: TCell INTEGER ( KIND = it4b ) :: i , j REAL ( KIND = dp ), DIMENSION (:,:), ALLOCATABLE :: VarRead allocate ( VarRead ( Isize , Jsize )) open ( unit = 5 , file = filename , action = 'read' ) read ( 5 , * ) read ( 5 , * ) read ( 5 , * ) read ( 5 , \"(f24.14)\" )(( VarRead ( i , j ), i = ibeg , Isize ), j = jbeg , Jsize ) read ( 5 , \"(f24.14)\" )(( VarRead ( i , j ), i = ibeg , Isize ), j = jbeg , Jsize ) read ( 5 , \"(f24.14)\" )(( UVVel ( i , j ), i = ibeg , Isize ), j = jbeg , Jsize ) read ( 5 , \"(f24.14)\" )(( TCell % phi ( i , j ), i = ibeg , Isize ), j = jbeg , Jsize ) read ( 5 , \"(f24.14)\" )(( TCell % vof ( i , j ), i = ibeg , Isize ), j = jbeg , Jsize ) read ( 5 , \"(f24.14)\" )(( TCell % phiS ( i , j ), i = ibeg , Isize ), j = jbeg , Jsize ) read ( 5 , \"(f24.14)\" )(( TCell % vofS ( i , j ), i = ibeg , Isize ), j = jbeg , Jsize ) read ( 5 , \"(f24.14)\" )(( VarRead ( i , j ), i = ibeg , Isize ), j = jbeg , Jsize ) close ( 5 ) END SUBROUTINE ReadOldDataVelocityCell SUBROUTINE ReadOldDataParticle ( filename , TraPar , TVar ) IMPLICIT NONE CHARACTER ( LEN = 80 ), INTENT ( IN ) :: filename TYPE ( Particle ), INTENT ( INOUT ) :: TraPar TYPE ( Variables ) :: TVar INTEGER ( KIND = it4b ) :: i , j CHARACTER ( LEN = 20 ) :: read1 , read2 , read3 , read4 , read5 open ( unit = 5 , file = filename , action = 'read' ) read ( 5 , * ) read ( 5 , * ) read1 , read2 , read3 , TraPar % np , read5 , j read ( 5 , \"(f24.14)\" )( TraPar % Posp ( i )% x , i = 1 , TraPar % np ) read ( 5 , \"(f24.14)\" )( TraPar % Posp ( i )% y , i = 1 , TraPar % np ) read ( 5 , \"(f24.14)\" )( TraPar % dp ( i ), i = 1 , TraPar % np ) read ( 5 , \"(f24.14)\" )( TraPar % uvp ( i )% u , i = 1 , TraPar % np ) read ( 5 , \"(f24.14)\" )( TraPar % uvp ( i )% v , i = 1 , TraPar % np ) close ( 5 ) do i = 1 , TraPar % np TraPar % Posp ( i )% x = TraPar % Posp ( i )% x * Lref TraPar % Posp ( i )% y = TraPar % Posp ( i )% y * Lref TraPar % dp ( i ) = TraPar % dp ( i ) * Lref TraPar % uvp ( i )% u = TraPar % uvp ( i )% u * TVar % Uref TraPar % uvp ( i )% v = TraPar % uvp ( i )% v * TVar % Uref end do END SUBROUTINE ReadOldDataParticle End module PrintResult","tags":"","loc":"sourcefile/printresult.f90.html","title":"PrintResult.f90 – Fortran Program"},{"text":"Contents Modules ProjectionP Source Code ProjectionP_Mod.f90 Source Code !********************************************************************* !* For cut-cell method !* To avoid the singularity we also solve the internal cell and set up !* the value of internal cell afterwards. Module ProjectionP USE PrecisionVar USE Mesh USE Cutcell USE StateVariables USE PredictorUV USE MPI IMPLICIT NONE PRIVATE REAL ( KIND = dp ), DIMENSION (:,:), POINTER :: p , u , v REAL ( KIND = dp ), PARAMETER :: amp = 1.d0 REAL ( KIND = dp ), PARAMETER :: alp = 0.4d0 , bet = 0.5d0 REAL ( KIND = dp ), DIMENSION (:,:,:), ALLOCATABLE :: PoCoef , HJump ! the coefficient for Poisson solving TYPE , PUBLIC :: Projection REAL ( KIND = dp ), DIMENSION (:,:), ALLOCATABLE :: Pp END TYPE PUBLIC :: PoissonEquationSolver INTERFACE PoissonEquationSolver MODULE PROCEDURE PoissonEquationSolver END INTERFACE PoissonEquationSolver CONTAINS SUBROUTINE PoissonEquationSolver ( PGrid , UGrid , VGrid , PCellO , PCell , UCell , & VCell , TVar , TPred , PU , PV , Proj , vb , dt , itt ) IMPLICIT NONE TYPE ( Grid ), INTENT ( IN ) :: PGrid , UGrid , VGrid TYPE ( Cell ), INTENT ( IN ) :: PCellO , PCell , UCell , VCell TYPE ( Variables ), INTENT ( IN ), target :: TVar TYPE ( Predictor ), INTENT ( IN ), target :: TPred TYPE ( Projection ), INTENT ( INOUT ), target :: Proj TYPE ( PoissonCoefficient ), INTENT ( IN ) :: PU , PV REAL ( KIND = dp ), INTENT ( IN ) :: vb INTEGER ( kind = it8b ), INTENT ( IN ) :: itt REAL ( KIND = dp ), INTENT ( IN ) :: dt INTEGER * 8 :: A , parcsr_A , b , par_b , x , par_x , solver , precond INTEGER ( kind = it4b ) :: num_iterations , i , j REAL ( KIND = dp ) :: final_res_norm , tol , resi REAL ( KIND = dp ), DIMENSION (:,:,:), allocatable :: matr REAL ( KIND = dp ), DIMENSION (:,:), allocatable :: rhm allocate ( matr ( Isize , Jsize , 5 )) allocate ( rhm ( Isize , Jsize )) allocate ( PoCoef ( Isize , Jsize , 4 )) ! the order of the face: S-1;W-2,E-3,N-4 allocate ( HJump ( Isize , Jsize , 4 )) p => TVar % p u => TPred % u v => TPred % v call ComputePossionMatrixCoefficient ( PGrid , UGrid , VGrid , PCell , UCell , & VCell , PU , PV ) call SetBasicSolver ( solver , precond ) !     call SetBasicSolver(solver=solver,ierr=ierr) !     WB,EB,SB,NB call SetPoissonMatrix ( A , parcsr_A , PGrid , PCell , 1 , 1 , 1 , 0 , matr , itt ) call SetPoissonVectors ( b , x , par_b , par_x , PGrid , PCellO , PCell , vb , dt , rhm , itt ) call HYPRE_ParCSRPCGSetup ( solver , parcsr_A , par_b , par_x , ierr ) call HYPRE_ParCSRPCGSolve ( solver , parcsr_A , par_b , par_x , ierr ) !     Run info - needed logging turned on call HYPRE_ParCSRPCGGetNumIterations ( solver , num_iterations , ierr ) call HYPRE_ParCSRPCGGetFinalRelative ( solver , final_res_norm , ierr ) !     call HYPRE_ParCSRPCGGetResidual(solver,tol,ierr) call DeltaPressureGetValues ( x , PCell , Proj ) call DeltaPressureBoundaryCondition ( Proj , 1 , 1 , 1 , 0 ) call HYPRE_IJMatrixDestroy ( A , ierr ) call HYPRE_IJVectorDestroy ( b , ierr ) call HYPRE_IJVectorDestroy ( x , ierr ) call HYPRE_BoomerAMGDestroy ( precond , ierr ) call HYPRE_ParCSRPCGDestroy ( solver , ierr ) do i = ibeg , Isize do j = jbeg , Jsize resi = 0.d0 if ( j > 1 ) then resi = resi + matr ( i , j , 1 ) * Proj % Pp ( i , j - 1 ) end if if ( i > 1 ) then resi = resi + matr ( i , j , 2 ) * Proj % Pp ( i - 1 , j ) end if resi = resi + matr ( i , j , 3 ) * Proj % Pp ( i , j ) if ( i < Isize ) then resi = resi + matr ( i , j , 4 ) * Proj % Pp ( i + 1 , j ) end if if ( j < Jsize ) then resi = resi + matr ( i , j , 5 ) * Proj % Pp ( i , j + 1 ) end if if ( dabs ( resi - rhm ( i , j )) > 1.d-10 . and . PCell % Posnu ( i , j ) /=- 1 ) then print * , 'Problem start' print * , resi , rhm ( i , j ), dabs ( resi - rhm ( i , j )) print * , i , j pause 'ProjectionP_86' end if end do end do nullify ( p ) nullify ( u ) nullify ( v ) deallocate ( matr , rhm ) deallocate ( PoCoef , HJump ) END SUBROUTINE PoissonEquationSolver SUBROUTINE SetBasicSolver ( solver , precond ) IMPLICIT NONE INTEGER * 8 , INTENT ( INOUT ) :: solver INTEGER * 8 , INTENT ( INOUT ), optional :: precond !       Set up and use a solver call HYPRE_ParCSRPCGCreate ( MPI_COMM_WORLD , solver , ierr ) !       Set some PARAMETERs call HYPRE_ParCSRPCGSetMaxIter ( solver , 50 , ierr ) !      call HYPRE_ParCSRPCGSetAbsoluteTol(solver,1.d-14,ierr) !      call HYPRE_ParCSRPCGSetResidualTol(solver,1.0d-14,ierr) call HYPRE_ParCSRPCGSetTol ( solver , 1.0d-20 , ierr ) call HYPRE_ParCSRPCGSetTwoNorm ( solver , 0 , ierr ) !      call HYPRE_ParCSRPCGSetPrintLevel(solver,2,ierr) call HYPRE_ParCSRPCGSetLogging ( solver , 1 , ierr ) !      Now set up the AMG preconditioner and specify any PARAMETERs if ( present ( precond )) then call HYPRE_BoomerAMGCreate ( precond , ierr ) !        Set some PARAMETERs !        Print less solver info since a preconditioner !        call HYPRE_BoomerAMGSetPrintLevel(precond,1,ierr); !        falgout coarsening call HYPRE_BoomerAMGSetCoarsenTYPE ( precond , 6 , ierr ) !        SYMMETRIC G-S/Jacobi hybrid relaxation call HYPRE_BoomerAMGSetRelaxTYPE ( precond , 6 , ierr ) !        Sweeeps on each level call HYPRE_BoomerAMGSetNumSweeps ( precond , 1 , ierr ) !        conv. tolerance call HYPRE_BoomerAMGSetTol ( precond , 0.0d0 , ierr ) !        do only one iteration! call HYPRE_BoomerAMGSetMaxIter ( precond , 10 , ierr ) !        set amg as the pcg preconditioner !         precond_id = 2 call HYPRE_ParCSRPCGSetPrecond ( solver , 2 , precond , ierr ) end if END SUBROUTINE SetBasicSolver SUBROUTINE SetPoissonMatrix ( A , parcsr_A , PGrid , PCell , WB , EB , SB , NB , matr , itt ) IMPLICIT NONE INTEGER * 8 , INTENT ( INOUT ) :: A , parcsr_A TYPE ( Grid ), INTENT ( IN ) :: PGrid TYPE ( Cell ), INTENT ( IN ) :: PCell INTEGER ( kind = it4b ), INTENT ( IN ) :: WB , EB , SB , NB ! boundary condition for west face, east face, ! south face, north face, 0: Dirichlet, 1: Neumann INTEGER ( kind = it8b ), INTENT ( IN ) :: itt INTEGER ( kind = it4b ) :: nnz , ictr , ilower , iupper , cols ( 0 : 4 ) INTEGER ( kind = it4b ) :: i , j , ii , jj REAL ( KIND = dp ) :: values ( 0 : 4 ) REAL ( KIND = dp ) :: dx , dy , test , nesu , diag , tol , mindiag REAL ( KIND = dp ), DIMENSION (:,:,:), allocatable :: matr ilower = 0 iupper = PCell % ExtCell tol = 1.d-24 ! Create and Set up matrix call HYPRE_IJMatrixCreate ( MPI_COMM_WORLD , ilower , iupper , ilower , iupper , & A , ierr ) call HYPRE_IJMatrixSetObjectTYPE ( A , HYPRE_PARCSR , ierr ) call HYPRE_IJMatrixInitialize ( A , ierr ) !     Now go through my local rows and set the matrix entries. !     Each row has at most 5 entries. For example, if n=3: ! !      A = [M -I 0; -I M -I; 0 -I M] !      M = [4 -1 0; -1 4 -1; 0 -1 4] ! !     Note that here we are setting one row at a time, though !     one could set all the rows together (see the User's Manual). !      mindiag=1.d10 do i = ibeg , ibeg + Isize - 1 do j = jbeg , jbeg + Jsize - 1 if ( PCell % Posnu ( i , j ) /=- 1 ) then nesu = 0.d0 diag = 0.d0 matr ( i , j ,:) = 0.d0 dx = PGrid % dx ( i , j ) dy = PGrid % dy ( i , j ) ictr = Pcell % Posnu ( i , j ) nnz = 0 values = 0.d0 cols = 0 ! Bottom of current cell if ( j > jbeg ) then if ( PCell % Posnu ( i , j - 1 ) /=- 1 ) then cols ( nnz ) = PCell % Posnu ( i , j - 1 ) values ( nnz ) =- PoCoef ( i , j , 1 ) * PCell % SEdge_Area ( i , j ) matr ( i , j , 1 ) = values ( nnz ) nesu = nesu + dabs ( values ( nnz )) nnz = nnz + 1 end if end if ! West of current cell if ( i > ibeg ) then if ( PCell % Posnu ( i - 1 , j ) /=- 1 ) then cols ( nnz ) = PCell % Posnu ( i - 1 , j ) values ( nnz ) =- PoCoef ( i , j , 2 ) * PCell % WEdge_Area ( i , j ) nesu = nesu + dabs ( values ( nnz )) matr ( i , j , 2 ) = values ( nnz ) nnz = nnz + 1 end if end if ! Set the diagonal cell cols ( nnz ) = PCell % Posnu ( i , j ) values ( nnz ) = PoCoef ( i , j , 1 ) * PCell % SEdge_Area ( i , j ) + & PoCoef ( i , j , 2 ) * PCell % WEdge_Area ( i , j ) + & PoCoef ( i , j , 3 ) * PCell % EEdge_Area ( i , j ) + & PoCoef ( i , j , 4 ) * PCell % NEdge_Area ( i , j ) !  values(nnz)=PoCoef(i,j,1)+                 & !              PoCoef(i,j,2)*PCell%WEdge_Area(i,j)+                 & !              PoCoef(i,j,3)*PCell%EEdge_Area(i,j)+                 & !              PoCoef(i,j,4) if ( isnan ( Values ( nnz )). or . dabs ( Values ( nnz )) > 1.d10 ) then print * , i , j , Values ( nnz ) print * , PoCoef ( i , j , 1 ), PoCoef ( i , j , 2 ), PoCoef ( i , j , 3 ), PoCoef ( i , j , 4 ) pause 'ProjectP_195 Bugs, you are again!' end if ! Apply boundary condition for matrix if ( SB == 1. and . j == jbeg ) then values ( nnz ) = values ( nnz ) - PoCoef ( i , j , 1 ) * PCell % SEdge_Area ( i , j ) end if if ( WB == 1. and . i == ibeg ) then values ( nnz ) = values ( nnz ) - PoCoef ( i , j , 2 ) * PCell % WEdge_Area ( i , j ) end if if ( EB == 1. and . i == ibeg + Isize - 1 ) then values ( nnz ) = values ( nnz ) - PoCoef ( i , j , 3 ) * PCell % EEdge_Area ( i , j ) end if if ( NB == 1. and . j == jbeg + Jsize - 1 ) then values ( nnz ) = values ( nnz ) - PoCoef ( i , j , 4 ) * PCell % NEdge_Area ( i , j ) end if values ( nnz ) = values ( nnz ) + dsign ( 1.d0 , values ( nnz )) * tol diag = dabs ( values ( nnz )) matr ( i , j , 3 ) = values ( nnz ) !            if(mindiag>dabs(values(nnz))) then !              ii=i !              jj=j !              mindiag=dabs(values(nnz)) !            end if nnz = nnz + 1 ! East of current cell if ( i < ibeg + Isize - 1 ) then if ( PCell % Posnu ( i + 1 , j ) /=- 1 ) then cols ( nnz ) = PCell % Posnu ( i + 1 , j ) values ( nnz ) =- PoCoef ( i , j , 3 ) * PCell % EEdge_Area ( i , j ) nesu = nesu + dabs ( values ( nnz )) matr ( i , j , 4 ) = values ( nnz ) nnz = nnz + 1 end if end if ! North of current cell if ( j < jbeg + Jsize - 1 ) then if ( PCell % Posnu ( i , j + 1 ) /=- 1 ) then cols ( nnz ) = PCell % Posnu ( i , j + 1 ) values ( nnz ) =- PoCoef ( i , j , 4 ) * PCell % NEdge_Area ( i , j ) nesu = nesu + dabs ( values ( nnz )) matr ( i , j , 5 ) = values ( nnz ) nnz = nnz + 1 end if end if call HYPRE_IJMatrixSetValues ( A , 1 , nnz , ictr , cols , values , ierr ) !            if(i==299.and.(j==76.or.j==77)) then !              print*,i,j !              print*,PCell%vofS(i,j) !              print*,PCell%SEdge_ARea(i,j),PCell%NEdge_Area(i,j) !              print*,PCell%WEdge_Area(i,j),PCell%EEdge_Area(i,j) !              print*, !            end if end if end do end do !      print*,'*************************_End test Projection' !      print*,ii,jj !      print*,mindiag !      print*,'----------------------' call HYPRE_IJMatrixAssemble ( A , ierr ) call HYPRE_IJMatrixGetObject ( A , parcsr_A , ierr ) end subroutine SetPoissonMatrix subroutine SetPoissonVectors ( b , x , par_b , par_x , PGrid , PCellO , PCell , vb , dt , rhm , itt ) INTEGER * 8 :: b , x , par_b , par_x TYPE ( Grid ), INTENT ( IN ) :: PGrid TYPE ( Cell ), INTENT ( IN ) :: PCellO , PCell REAL ( KIND = dp ), INTENT ( IN ) :: vb REAL ( KIND = dp ), INTENT ( IN ) :: dt INTEGER ( kind = it8b ), INTENT ( IN ) :: itt INTEGER ( kind = it4b ) :: i , j , ii , jj INTEGER :: ilower , iupper , ictr , local_size REAL ( KIND = dp ) :: dx , dy , beta ( 2 ), maxvect INTEGER ( kind = it4b ), DIMENSION (:), allocatable :: rows REAL ( KIND = dp ), DIMENSION (:), allocatable :: rhs , xval REAL ( KIND = dp ), DIMENSION (:,:), allocatable :: ExtFlux , rhm ilower = 0 iupper = PCell % ExtCell local_size = iupper - ilower + 1 ! the number of rows ! In here, we apply boundary condition for deltaP with its values is 0 at ! all boundary. therefore, we do not need to set boundary in vector b allocate ( rhs ( 0 : PCell % ExtCell )) allocate ( xval ( 0 : PCell % ExtCell )) allocate ( rows ( 0 : PCell % ExtCell )) allocate ( ExtFlux ( ibeg : ibeg + Isize - 1 , jbeg + jbeg + Jsize - 1 )) call HYPRE_IJVectorCreate ( MPI_COMM_WORLD , ilower , iupper , b , ierr ) call HYPRE_IJVectorSetObjectTYPE ( b , HYPRE_PARCSR , ierr ) call HYPRE_IJVectorInitialize ( b , ierr ) call HYPRE_IJVectorCreate ( MPI_COMM_WORLD , ilower , iupper , x , ierr ) call HYPRE_IJVectorSetObjectTYPE ( x , HYPRE_PARCSR , ierr ) call HYPRE_IJVectorInitialize ( x , ierr ) ExtFlux (:,:) = 0.d0 !        maxvect=0.d0 do i = ibeg , ibeg + Isize - 1 do j = jbeg , jbeg + Jsize - 1 ictr = PCell % PosNu ( i , j ) if ( ictr /=- 1 ) then rhm ( i , j ) = 0.d0 dx = Pgrid % dx ( i , j ) dy = Pgrid % dy ( i , j ) rhs ( ictr ) =- ( u ( i , j ) * PCell % EEdge_Area ( i , j ) - & u ( i - 1 , j ) * PCell % WEdge_Area ( i , j )) * dy - & ( v ( i , j ) * PCell % NEdge_Area ( i , j ) - & v ( i , j - 1 ) * PCell % SEdge_Area ( i , j )) * dx & + vb * PCell % nyS ( i , j ) * PCell % WlLh ( i , j ) ! -((1.d0-PCell%vofS(i,j))-(1.d0-PCellO%vofS(i,j)))*dx*dy xval ( ictr ) = 0.d0 rows ( ictr ) = ilower + ictr rhm ( i , j ) = rhs ( ictr ) if ( isnan ( rhs ( ictr )). or . dabs ( rhs ( ictr )) > 1.d5 ) then print * , u ( i , j ), u ( i - 1 , j ), v ( i , j ), v ( i , j - 1 ), i , j pause 'bugs, projection 476' endif !              if(maxvect<dabs(rhs(ictr))) then !                maxvect=dabs(rhs(ictr)) !                ii=i !                jj=j !              end if !  if(i==294.and.j==190) then !    print*,i,j !    print*,vb,PCell%nyS(i,j),PCell%WlLh(i,j) !    print*, !  end if endif end do end do !        print*,'oooooooooooooooooo' !        print*,maxvect !        print*,ii,jj !        print*,'iiiiiiiii_Test vector' call HYPRE_IJVectorSetValues ( b , local_size , rows , rhs , ierr ) call HYPRE_IJVectorSetValues ( x , local_size , rows , xval , ierr ) call HYPRE_IJVectorAssemble ( b , ierr ) call HYPRE_IJVectorAssemble ( x , ierr ) ! get the x and b objects call HYPRE_IJVectorGetObject ( b , par_b , ierr ) call HYPRE_IJVectorGetObject ( x , par_x , ierr ) deallocate ( rhs ) deallocate ( xval ) deallocate ( rows ) deallocate ( ExtFlux ) end subroutine SetPoissonVectors subroutine DeltaPressureGetValues ( x , PCell , Projp ) INTEGER * 8 , INTENT ( IN ) :: x TYPE ( Cell ), INTENT ( IN ) :: PCell TYPE ( Projection ), INTENT ( INOUT ) :: Projp INTEGER ( kind = it4b ) :: i , j INTEGER ( kind = it4b ) :: ilower , iupper , local_size , ctr INTEGER ( kind = it4b ), DIMENSION (:), allocatable :: rows REAL ( KIND = dp ), DIMENSION (:), allocatable :: values ilower = 0 iupper = PCell % ExtCell local_size = PCell % ExtCell + 1 ! number of element allocate ( values ( ilower : iupper )) allocate ( rows ( ilower : iupper )) do i = ibeg , ibeg + Isize - 1 do j = jbeg , jbeg + Jsize - 1 if ( PCell % PosNu ( i , j ) /=- 1 ) then rows ( PCell % PosNu ( i , j )) = PCell % PosNu ( i , j ) + ilower end if end do end do call HYPRE_IJVectorGetValues ( x , local_size , rows , values , ierr ) ctr = 0 do i = ibeg , ibeg + Isize - 1 do j = jbeg , jbeg + Jsize - 1 if ( PCell % PosNu ( i , j ) == ctr ) then Projp % Pp ( i , j ) = values ( ctr ) ctr = ctr + 1 if ( isnan ( Projp % Pp ( i , j )). or . projp % Pp ( i , j ) > 1.d10 ) then print * , Projp % Pp ( i , j ) pause 'ProjectionP_Mod 356' end if else Projp % Pp ( i , j ) = 0.d0 end if end do end do deallocate ( values , rows ) end subroutine DeltaPressureGetValues subroutine ComputePossionMatrixCoefficient ( PGrid , UGrid , VGrid , PCell , UCell , & VCell , PU , PV ) IMPLICIT NONE TYPE ( Grid ), INTENT ( IN ) :: PGrid , UGrid , VGrid TYPE ( Cell ), INTENT ( IN ) :: PCell , UCell , VCell TYPE ( PoissonCoefficient ), INTENT ( IN ) :: PU , PV REAL ( KIND = dp ) :: BetaP , BetaM , BetaW , BetaD , Lamda , tol INTEGER ( kind = it4b ) :: i , j ! Set Coefficient for W,E,S,N tol = 1.d-24 BetaP = 1.d0 / ( row / Roref ) BetaM = 1.d0 / ( roa / Roref ) do i = 1 , Isize do j = 1 , Jsize if (( PCell % vof ( i , j ) >= 0.5d0 . and . PCell % vofS ( i , j ) < epsi ). or . & ( PCell % phi ( i , j ) < 0.d0 . and . PCell % vofS ( i , j ) >= epsi )) then ! this cell is in water and it is assigned wet cell ! For South Cell if ( j > 1 ) then if (( PCell % vof ( i , j - 1 ) < 0.5d0 . and . PCell % vofS ( i , j - 1 ) < epsi ). or . & ( PCell % phi ( i , j - 1 ) >= 0.d0 . and . PCell % vofS ( i , j - 1 ) >= epsi )) then ! the South Cell is in air and assigned dry cell Lamda = dabs ( PCell % phi ( i , j )) / ( dabs ( PCell % phi ( i , j )) + & dabs ( PCell % phi ( i , j - 1 )) + tol ) BetaW = Lamda * BetaM + ( 1.d0 - Lamda ) * BetaP PoCoef ( i , j , 1 ) = PV % Dp ( i , j - 1 ) * PGrid % dx ( i , j ) / VGrid % dy ( i , j - 1 ) * & BetaP * BetaM / BetaW elseif (( PCell % vof ( i , j - 1 ) >= 0.5d0 . and . PCell % vofS ( i , j - 1 ) < epsi ). or . & ( PCell % phi ( i , j - 1 ) < 0.d0 . and . PCell % vofS ( i , j - 1 ) >= epsi )) then ! the South Cell is in water and assigned wet cell BetaW = BetaM PoCoef ( i , j , 1 ) = PV % Dp ( i , j - 1 ) * PGrid % dx ( i , j ) / VGrid % dy ( i , j - 1 ) * & BetaP * BetaM / BetaW ! Using the new concept to calculate the pressure gradient end if else BetaW = BetaM PoCoef ( i , j , 1 ) = PV % Dp ( i , j ) * PGrid % dx ( i , j ) / VGrid % dy ( i , j ) * & BetaP * BetaM / BetaW end if ! For West Cell if ( i > 1 ) then if (( PCell % vof ( i - 1 , j ) < 0.5d0 . and . PCell % vofS ( i - 1 , j ) < epsi ). or . & ( PCell % phi ( i - 1 , j ) >= 0.d0 . and . PCell % vofS ( i - 1 , j ) >= epsi )) then ! the West Cell is in air and assigned dry cell Lamda = dabs ( PCell % phi ( i , j )) / ( dabs ( PCell % phi ( i , j )) + & dabs ( PCell % phi ( i - 1 , j )) + tol ) BetaW = Lamda * BetaM + ( 1.d0 - Lamda ) * BetaP PoCoef ( i , j , 2 ) = PU % Dp ( i - 1 , j ) * PGrid % dy ( i , j ) / UGrid % dx ( i - 1 , j ) * & BetaP * BetaM / BetaW elseif (( PCell % vof ( i - 1 , j ) >= 0.5d0 . and . PCell % vofS ( i - 1 , j ) < epsi ). or . & ( PCell % phi ( i - 1 , j ) < 0.d0 . and . PCell % vofS ( i - 1 , j ) >= epsi )) then BetaW = BetaM PoCoef ( i , j , 2 ) = PU % Dp ( i - 1 , j ) * PGrid % dy ( i , j ) / UGrid % dx ( i - 1 , j ) * & BetaP * BetaM / BetaW end if else BetaW = BetaM PoCoef ( i , j , 2 ) = PU % Dp ( i , j ) * PGrid % dy ( i , j ) / UGrid % dx ( i , j ) * & BetaP * BetaM / BetaW end if ! For East Cell if ( i < Isize ) then if (( PCell % vof ( i + 1 , j ) < 0.5d0 . and . PCell % vofS ( i + 1 , j ) < epsi ). or . & ( PCell % phi ( i + 1 , j ) >= 0.d0 . and . PCell % vofS ( i + 1 , j ) >= epsi )) then Lamda = dabs ( PCell % phi ( i , j )) / ( dabs ( PCell % phi ( i , j )) + & dabs ( PCell % phi ( i + 1 , j )) + tol ) BetaW = Lamda * BetaM + ( 1.d0 - Lamda ) * BetaP PoCoef ( i , j , 3 ) = PU % Dp ( i , j ) * PGrid % dy ( i , j ) / UGrid % dx ( i , j ) * & BetaP * BetaM / BetaW elseif (( PCell % vof ( i + 1 , j ) >= 0.5d0 . and . PCell % vofS ( i + 1 , j ) < epsi ). or . & ( PCell % phi ( i + 1 , j ) < 0.d0 . and . PCell % vofS ( i + 1 , j ) >= epsi )) then BetaW = BetaM PoCoef ( i , j , 3 ) = PU % Dp ( i , j ) * PGrid % dy ( i , j ) / UGrid % dx ( i , j ) * & BetaP * BetaM / BetaW end if else BetaW = BetaM PoCoef ( i , j , 3 ) = PU % Dp ( i , j ) * PGrid % dy ( i , j ) / UGrid % dx ( i , j ) * & BetaP * BetaM / BetaW end if ! For North Cell if ( j < Jsize ) then if (( PCell % vof ( i , j + 1 ) < 0.5d0 . and . PCell % vofS ( i , j + 1 ) < epsi ). or . & ( PCell % phi ( i , j + 1 ) >= 0.d0 . and . PCell % vofS ( i , j + 1 ) >= epsi )) then Lamda = dabs ( PCell % phi ( i , j )) / ( dabs ( PCell % phi ( i , j )) + & dabs ( PCell % phi ( i , j + 1 )) + tol ) BetaW = Lamda * BetaM + ( 1.d0 - Lamda ) * BetaP PoCoef ( i , j , 4 ) = PV % Dp ( i , j ) * PGrid % dx ( i , j ) / VGrid % dy ( i , j ) * & BetaP * BetaM / BetaW elseif (( PCell % vof ( i , j + 1 ) >= 0.5d0 . and . PCell % vofS ( i , j + 1 ) < epsi ). or . & ( PCell % phi ( i , j + 1 ) < 0.d0 . and . PCell % vofS ( i , j + 1 ) >= epsi )) then BetaW = BetaM PoCoef ( i , j , 4 ) = PV % Dp ( i , j ) * PGrid % dx ( i , j ) / VGrid % dy ( i , j ) * & BetaP * BetaM / BetaW end if else BetaW = BetaM PoCoef ( i , j , 4 ) = PV % Dp ( i , j ) * PGrid % dx ( i , j ) / VGrid % dy ( i , j ) * & BetaP * BetaM / BetaW end if elseif (( PCell % vof ( i , j ) < 0.5d0 . and . PCell % vofS ( i , j ) < epsi ). or . & ( PCell % phi ( i , j ) >= 0.d0 . and . PCell % vofS ( i , j ) >= epsi )) then ! this cell is in air and it is assigned dry cell if ( j > 1 ) then ! the South Cell is in water and assigned wet cell if (( PCell % vof ( i , j - 1 ) >= 0.5d0 . and . PCell % vofS ( i , j - 1 ) < epsi ). or . & ( PCell % phi ( i , j - 1 ) < 0.d0 . and . PCell % vofS ( i , j - 1 ) >= epsi )) then Lamda = dabs ( PCell % phi ( i , j )) / ( dabs ( PCell % phi ( i , j )) + & dabs ( PCell % phi ( i , j - 1 )) + tol ) BetaD = Lamda * BetaP + ( 1.d0 - Lamda ) * BetaM PoCoef ( i , j , 1 ) = PV % Dp ( i , j - 1 ) * PGrid % dx ( i , j ) / VGrid % dy ( i , j - 1 ) * & BetaP * BetaM / BetaD elseif (( PCell % vof ( i , j - 1 ) < 0.5d0 . and . PCell % vofS ( i , j - 1 ) < epsi ). or . & ( PCell % phi ( i , j - 1 ) >= 0.d0 . and . PCell % vofS ( i , j - 1 ) >= epsi )) then ! the South Cell is in water and assigned wet cell BetaW = BetaP PoCoef ( i , j , 1 ) = PV % Dp ( i , j - 1 ) * PGrid % dx ( i , j ) / VGrid % dy ( i , j - 1 ) * & BetaP * BetaM / BetaD end if else BetaD = BetaP PoCoef ( i , j , 1 ) = PV % Dp ( i , j ) * PGrid % dx ( i , j ) / VGrid % dy ( i , j ) * & BetaP * BetaM / BetaD end if if ( i > 1 ) then ! the West Cell is in water and assigned wet cell if (( PCell % vof ( i - 1 , j ) >= 0.5d0 . and . PCell % vofS ( i - 1 , j ) < epsi ). or . & ( PCell % phi ( i - 1 , j ) < 0.d0 . and . PCell % vofS ( i - 1 , j ) >= epsi )) then Lamda = dabs ( PCell % phi ( i , j )) / ( dabs ( PCell % phi ( i , j )) + & dabs ( PCell % phi ( i - 1 , j )) + tol ) BetaD = Lamda * BetaP + ( 1.d0 - Lamda ) * BetaM PoCoef ( i , j , 2 ) = PU % Dp ( i - 1 , j ) * PGrid % dy ( i , j ) / UGrid % dx ( i - 1 , j ) * & BetaP * BetaM / BetaD elseif (( PCell % vof ( i - 1 , j ) < 0.5d0 . and . PCell % vofS ( i - 1 , j ) < epsi ). or . & ( PCell % phi ( i - 1 , j ) >= 0.d0 . and . PCell % vofS ( i - 1 , j ) >= epsi )) then BetaD = BetaP PoCoef ( i , j , 2 ) = PU % Dp ( i - 1 , j ) * PGrid % dy ( i , j ) / UGrid % dx ( i - 1 , j ) * & BetaP * BetaM / BetaD end if else BetaD = BetaP PoCoef ( i , j , 2 ) = PU % Dp ( i , j ) * PGrid % dy ( i , j ) / UGrid % dx ( i , j ) * & BetaP * BetaM / BetaD end if ! The East Cell is in the water and assigned wet cell if ( i < Isize ) then if (( PCell % vof ( i + 1 , j ) >= 0.5d0 . and . PCell % vofS ( i + 1 , j ) < epsi ). or . & ( PCell % phi ( i + 1 , j ) < 0.d0 . and . PCell % vofS ( i + 1 , j ) >= epsi )) then Lamda = dabs ( PCell % phi ( i , j )) / ( dabs ( PCell % phi ( i , j )) + & dabs ( PCell % phi ( i + 1 , j )) + tol ) BetaD = Lamda * BetaP + ( 1.d0 - Lamda ) * BetaM PoCoef ( i , j , 3 ) = PU % Dp ( i , j ) * PGrid % dy ( i , j ) / UGrid % dx ( i , j ) * & BetaP * BetaM / BetaD elseif (( PCell % vof ( i + 1 , j ) < 0.5d0 . and . PCell % vofS ( i + 1 , j ) < epsi ). or . & ( PCell % phi ( i + 1 , j ) >= 0.d0 . and . PCell % vofS ( i + 1 , j ) >= epsi )) then BetaD = BetaP PoCoef ( i , j , 3 ) = PU % Dp ( i , j ) * PGrid % dy ( i , j ) / UGrid % dx ( i , j ) * & BetaP * BetaM / BetaD end if else BetaD = BetaP PoCoef ( i , j , 3 ) = PU % Dp ( i , j ) * PGrid % dy ( i , j ) / UGrid % dx ( i , j ) * & BetaP * BetaM / BetaD end if !  For North Cell if ( j < Jsize ) then if (( PCell % vof ( i , j + 1 ) >= 0.5d0 . and . PCell % vofS ( i , j + 1 ) < epsi ). or . & ( PCell % phi ( i , j + 1 ) < 0.d0 . and . PCell % vofS ( i , j + 1 ) >= epsi )) then ! the North Cell is in the Water and assigned wet cell Lamda = dabs ( PCell % phi ( i , j )) / ( dabs ( PCell % phi ( i , j )) + & dabs ( PCell % phi ( i , j + 1 )) + tol ) BetaD = Lamda * BetaP + ( 1.d0 - Lamda ) * BetaM PoCoef ( i , j , 4 ) = PV % Dp ( i , j ) * PGrid % dx ( i , j ) / VGrid % dy ( i , j ) * & BetaP * BetaM / BetaD elseif (( PCell % vof ( i , j + 1 ) < 0.5d0 . and . PCell % vofS ( i , j + 1 ) < epsi ). or . & ( PCell % phi ( i , j + 1 ) >= 0.d0 . and . PCell % vofS ( i , j + 1 ) >= epsi )) then BetaD = BetaP PoCoef ( i , j , 4 ) = PV % Dp ( i , j ) * PGrid % dx ( i , j ) / VGrid % dy ( i , j ) * & BetaP * BetaM / BetaD end if else BetaD = BetaP PoCoef ( i , j , 4 ) = PV % Dp ( i , j ) * PGrid % dx ( i , j ) / VGrid % dy ( i , j ) * & BetaP * BetaM / BetaD end if end if end do end do End Subroutine ComputePossionMatrixCoefficient Subroutine DeltaPressureBoundaryCondition ( Proj , WB , EB , SB , NB ) IMPLICIT NONE TYPE ( Projection ), INTENT ( INOUT ) :: Proj INTEGER ( kind = it4b ), INTENT ( IN ) :: WB , EB , SB , NB INTEGER ( kind = it4b ) :: i , j Do i = ibeg , ibeg + Isize - 1 Proj % Pp ( i , jbeg - 1 ) = dble ( SB ) * Proj % Pp ( i , jbeg ) Proj % Pp ( i , jbeg + Jsize ) = dble ( NB ) * Proj % Pp ( i , jbeg + Jsize - 1 ) End do Do j = jbeg , jbeg + Jsize - 1 Proj % Pp ( ibeg - 1 , j ) = dble ( WB ) * Proj % Pp ( ibeg , j ) Proj % Pp ( ibeg + Isize , j ) = dble ( EB ) * Proj % Pp ( ibeg + Isize - 1 , j ) End do End subroutine DeltaPressureBoundaryCondition End module ProjectionP","tags":"","loc":"sourcefile/projectionp_mod.f90.html","title":"ProjectionP_Mod.f90 – Fortran Program"},{"text":"Contents Modules Solver Source Code Solver_Mod.f90 Source Code Module Solver USE PrecisionVar USE Mesh USE StateVariables USE CutCell USE Clsvof USE PrintResult USE ComputePUV USE MPI USE Particles IMPLICIT NONE PRIVATE TYPE , PUBLIC :: SolverTime INTEGER ( kind = it8b ) :: iter REAL ( KIND = dp ) :: cfl REAL ( KIND = dp ) :: dt , PhysT , NondiT End TYPE SolverTime TYPE , PUBLIC :: SolverConvergence REAL ( KIND = dp ) :: N1 , N2 , NInf , N1c , N2c , NInfc End TYPE SolverConvergence REAL ( KIND = dp ), PARAMETER :: Twalls = 30 0.d0 REAL ( KIND = dp ), PARAMETER :: Twall = 40 0.d0 REAL ( KIND = dp ), PRIVATE :: tprint ( 7 ), xprintex ( 0 : 7 ) INTEGER ( kind = it4b ), PRIVATE :: WavePrint PUBLIC :: IterationSolution Interface IterationSolution Module Procedure IterationSolution End Interface IterationSolution Contains subroutine IterationSolution ( PGrid , UGrid , VGrid , PCell , UCell , VCell , TVar , & TraPar , BoomCase , iprint ) IMPLICIT NONE TYPE ( Grid ), INTENT ( IN ) :: PGrid , UGrid , VGrid TYPE ( Cell ), INTENT ( INOUT ) :: PCell , UCell , VCell TYPE ( Variables ), INTENT ( INOUT ) :: TVar INTEGER ( kind = it4b ), INTENT ( IN ) :: iprint TYPE ( Particle ), INTENT ( INOUT ) :: TraPar TYPE ( SolidObject ), INTENT ( INOUT ) :: BoomCase TYPE ( Cell ) :: PCellO , UCellO , VCellO REAL ( KIND = dp ), DIMENSION (:,:), allocatable :: GraP REAL ( KIND = dp ), DIMENSION (:,:,:), allocatable :: Flux_n1 TYPE ( SolverTime ) :: Time TYPE ( SolverConvergence ) :: UConv , VConv , PConv TYPE ( Variables ) :: TVar_n INTEGER ( kind = it4b ) :: iprint1 , i , j INTEGER ( kind = it8b ) :: itt , tempvel REAL ( KIND = dp ) :: velaver , timeb CHARACTER ( LEN = 80 ) :: filename , curd allocate ( Flux_n1 ( 0 : Isize + 1 , 0 : Jsize + 1 , 2 )) Flux_n1 (:,:,:) = 0.d0 allocate ( GraP ( 1 : Isize , 1 : Jsize )) Time % iter = 10 ** 6 Time % NondiT = 0.d0 Time % Cfl = 0.3d0 iprint1 = iprint tempvel = 0 velaver = 0.d0 timeb = 2 0.d0 ! Set up time for pring wave profile !   tprint(1)=0.50074d0 !   tprint(2)=0.75264d0 !   tprint(3)=0.8018d0 !   tprint(4)=0.85095d0 !   tprint(5)=0.89396d0 !   tprint(6)=1.02912d0 !   tprint(7)=1.20116d0 ! Set up time for Overtaking collisions tprint ( 1 ) = 2.59892d0 tprint ( 2 ) = 3.50209d0 tprint ( 3 ) = 4.14721d0 tprint ( 4 ) = 4.6971d0 tprint ( 5 ) = 5.5972d0 tprint ( 6 ) = 6.60174d0 tprint ( 7 ) = 8.39887d0 ! Set up printing position for overtaking collisions xprintex ( 0 ) = 0.d0 xprintex ( 1 ) = 1.301585d0 xprintex ( 2 ) = 1.294936d0 xprintex ( 3 ) = 1.3711241d0 !1.462082d0 ! for lowest point between two waves xprintex ( 4 ) = 1.456825d0 xprintex ( 5 ) = 1.46058d0 xprintex ( 6 ) = 1.469767d0 xprintex ( 7 ) = 1.495967d0 ! Flag to print wave profile (1 for printing) ! This variables is assigned value in ComputeTimeStep Subroutine WavePrint = 0 call PrintWaterWave ( Time % PhysT , PGrid , PCell ) allocate ( UCellO % vof ( ibeg : Isize + ibeg - 1 , jbeg : Jsize + jbeg - 1 )) allocate ( UCellO % phi ( ibeg : Isize + ibeg - 1 , jbeg : Jsize + jbeg - 1 )) allocate ( UCellO % nx ( ibeg : Isize + ibeg - 1 , jbeg : Jsize + jbeg - 1 )) allocate ( UCellO % ny ( ibeg : Isize + ibeg - 1 , jbeg : Jsize + jbeg - 1 )) allocate ( UCellO % vofS ( ibeg : Isize + ibeg - 1 , jbeg : Jsize + jbeg - 1 )) allocate ( UCellO % phiS ( ibeg : Isize + ibeg - 1 , jbeg : Jsize + jbeg - 1 )) allocate ( UCellO % nxS ( ibeg : Isize + ibeg - 1 , jbeg : Jsize + jbeg - 1 )) allocate ( UCellO % nyS ( ibeg : Isize + ibeg - 1 , jbeg : Jsize + jbeg - 1 )) allocate ( UCellO % EEdge_Area ( ibeg - 1 : Isize + ibeg - 1 + 1 , jbeg - 1 : Jsize + jbeg - 1 + 1 )) allocate ( UCellO % WEdge_Area ( ibeg - 1 : Isize + ibeg - 1 + 1 , jbeg - 1 : Jsize + jbeg - 1 + 1 )) allocate ( UCellO % NEdge_Area ( ibeg - 1 : Isize + ibeg - 1 + 1 , jbeg - 1 : Jsize + jbeg - 1 + 1 )) allocate ( UCellO % SEdge_Area ( ibeg - 1 : Isize + ibeg - 1 + 1 , jbeg - 1 : Jsize + jbeg - 1 + 1 )) allocate ( UCellO % MoExCell ( ibeg : Isize + ibeg - 1 , jbeg : Jsize + jbeg - 1 )) allocate ( UCellO % EtaE ( ibeg - ight : ibeg + Isize - 1 + ight , jbeg - jght : jbeg + Jsize - 1 + jght )) allocate ( UCellO % EtaN ( ibeg - ight : ibeg + Isize - 1 + ight , jbeg - jght : jbeg + Jsize - 1 + jght )) allocate ( UCellO % DAlE ( ibeg - ight : ibeg + Isize - 1 + ight , jbeg - jght : jbeg + Jsize - 1 + jght )) allocate ( UCellO % DAlN ( ibeg - ight : ibeg + Isize - 1 + ight , jbeg - jght : jbeg + Jsize - 1 + jght )) allocate ( UCellO % AlE ( ibeg - ight : ibeg + Isize - 1 + ight , jbeg - jght : jbeg + Jsize - 1 + jght )) allocate ( UCellO % AlN ( ibeg - ight : ibeg + Isize - 1 + ight , jbeg - jght : jbeg + Jsize - 1 + jght )) allocate ( UCellO % SxE ( ibeg - ight : ibeg + Isize - 1 + ight , jbeg - jght : jbeg + Jsize - 1 + jght )) allocate ( UCellO % SyN ( ibeg - ight : ibeg + Isize - 1 + ight , jbeg - jght : jbeg + Jsize - 1 + jght )) allocate ( UCellO % FCE ( ibeg - ight : ibeg + Isize - 1 + ight , jbeg - jght : jbeg + Jsize - 1 + jght , 2 )) allocate ( UCellO % FCN ( ibeg - ight : ibeg + Isize - 1 + ight , jbeg - jght : jbeg + Jsize - 1 + jght , 2 )) allocate ( UCellO % WlLh ( ibeg : ibeg + Isize - 1 , jbeg : jbeg + Jsize - 1 )) allocate ( UCellO % delh ( ibeg : ibeg + Isize - 1 , jbeg : jbeg + Jsize - 1 )) allocate ( UCellO % PosNu ( ibeg - ight : ibeg + Isize - 1 + ight , jbeg - jght : jbeg + Jsize - 1 + jght )) allocate ( UCellO % Cell_Cent ( Isize , Jsize , 2 )) allocate ( UCellO % MsCe ( Isize , Jsize , 2 )) allocate ( VCellO % vof ( ibeg : Isize + ibeg - 1 , jbeg : Jsize + jbeg - 1 )) allocate ( VCellO % phi ( ibeg : Isize + ibeg - 1 , jbeg : Jsize + jbeg - 1 )) allocate ( VCellO % nx ( ibeg : Isize + ibeg - 1 , jbeg : Jsize + jbeg - 1 )) allocate ( VCellO % ny ( ibeg : Isize + ibeg - 1 , jbeg : Jsize + jbeg - 1 )) allocate ( VCellO % vofS ( ibeg : Isize + ibeg - 1 , jbeg : Jsize + jbeg - 1 )) allocate ( VCellO % phiS ( ibeg : Isize + ibeg - 1 , jbeg : Jsize + jbeg - 1 )) allocate ( VCellO % nxS ( ibeg : Isize + ibeg - 1 , jbeg : Jsize + jbeg - 1 )) allocate ( VCellO % nyS ( ibeg : Isize + ibeg - 1 , jbeg : Jsize + jbeg - 1 )) allocate ( VCellO % EEdge_Area ( ibeg - 1 : Isize + ibeg - 1 + 1 , jbeg - 1 : Jsize + jbeg - 1 + 1 )) allocate ( VCellO % WEdge_Area ( ibeg - 1 : Isize + ibeg - 1 + 1 , jbeg - 1 : Jsize + jbeg - 1 + 1 )) allocate ( VCellO % NEdge_Area ( ibeg - 1 : Isize + ibeg - 1 + 1 , jbeg - 1 : Jsize + jbeg - 1 + 1 )) allocate ( VCellO % SEdge_Area ( ibeg - 1 : Isize + ibeg - 1 + 1 , jbeg - 1 : Jsize + jbeg - 1 + 1 )) allocate ( VCellO % MoExCell ( ibeg : Isize + ibeg - 1 , jbeg : Jsize + jbeg - 1 )) allocate ( VCellO % EtaE ( ibeg - ight : ibeg + Isize - 1 + ight , jbeg - jght : jbeg + Jsize - 1 + jght )) allocate ( VCellO % EtaN ( ibeg - ight : ibeg + Isize - 1 + ight , jbeg - jght : jbeg + Jsize - 1 + jght )) allocate ( VCellO % DAlE ( ibeg - ight : ibeg + Isize - 1 + ight , jbeg - jght : jbeg + Jsize - 1 + jght )) allocate ( VCellO % DAlN ( ibeg - ight : ibeg + Isize - 1 + ight , jbeg - jght : jbeg + Jsize - 1 + jght )) allocate ( VCellO % AlE ( ibeg - ight : ibeg + Isize - 1 + ight , jbeg - jght : jbeg + Jsize - 1 + jght )) allocate ( VCellO % AlN ( ibeg - ight : ibeg + Isize - 1 + ight , jbeg - jght : jbeg + Jsize - 1 + jght )) allocate ( VCellO % SxE ( ibeg - ight : ibeg + Isize - 1 + ight , jbeg - jght : jbeg + Jsize - 1 + jght )) allocate ( VCellO % SyN ( ibeg - ight : ibeg + Isize - 1 + ight , jbeg - jght : jbeg + Jsize - 1 + jght )) allocate ( VCellO % FCE ( ibeg - ight : ibeg + Isize - 1 + ight , jbeg - jght : jbeg + Jsize - 1 + jght , 2 )) allocate ( VCellO % FCN ( ibeg - ight : ibeg + Isize - 1 + ight , jbeg - jght : jbeg + Jsize - 1 + jght , 2 )) allocate ( VCellO % WlLh ( ibeg : ibeg + Isize - 1 , jbeg : jbeg + Jsize - 1 )) allocate ( VCellO % delh ( ibeg : ibeg + Isize - 1 , jbeg : jbeg + Jsize - 1 )) allocate ( VCellO % PosNu ( ibeg - ight : ibeg + Isize - 1 + ight , jbeg - jght : jbeg + Jsize - 1 + jght )) allocate ( VCellO % Cell_Cent ( Isize , Jsize , 2 )) allocate ( VCellO % MsCe ( Isize , Jsize , 2 )) allocate ( PCellO % vof ( ibeg : Isize , jbeg : Jsize )) allocate ( PCellO % phi ( ibeg : Isize , jbeg : Jsize )) allocate ( PCellO % nx ( ibeg : Isize , jbeg : Jsize )) allocate ( PCellO % ny ( ibeg : Isize , jbeg : Jsize )) allocate ( PCellO % vofS ( ibeg : Isize , jbeg : Jsize )) allocate ( PCellO % phiS ( ibeg : Isize , jbeg : Jsize )) allocate ( PCellO % nxS ( ibeg : Isize , jbeg : Jsize )) allocate ( PCellO % nyS ( ibeg : Isize , jbeg : Jsize )) allocate ( PCellO % EEdge_Area ( ibeg - 1 : Isize + 1 , jbeg - 1 : Jsize + 1 )) allocate ( PCellO % WEdge_Area ( ibeg - 1 : Isize + 1 , jbeg - 1 : Jsize + 1 )) allocate ( PCellO % NEdge_Area ( ibeg - 1 : Isize + 1 , jbeg - 1 : Jsize + 1 )) allocate ( PCellO % SEdge_Area ( ibeg - 1 : Isize + 1 , jbeg - 1 : Jsize + 1 )) allocate ( PCellO % FCE ( ibeg - ight : ibeg + Isize - 1 + ight , jbeg - jght : jbeg + Jsize - 1 + jght , 2 )) allocate ( PCellO % FCN ( ibeg - ight : ibeg + Isize - 1 + ight , jbeg - jght : jbeg + Jsize - 1 + jght , 2 )) allocate ( PCellO % PosNu ( ibeg - ight : ibeg + Isize - 1 + ight , jbeg - jght : jbeg + Jsize - 1 + jght )) allocate ( PCellO % Cell_Cent ( Isize , Jsize , 2 )) ! Calculate threshold for MUSCL limiter if ( RunAgain . eqv .. TRUE .) then Write ( curd , '(i8.8)' ) IttRun filename = trim ( adjustl ( dir )) // 'Tecplot/Pressure_' // trim ( curd ) // '.dat' call ReadOldDataPCell ( filename , PCell , TVar , Flux_n1 ) filename = trim ( adjustl ( dir )) // 'Tecplot/Uvelocity_' // trim ( curd ) // '.dat' call ReadOldDataVelocityCell ( filename , UCell , TVar % u ) filename = trim ( adjustl ( dir )) // 'Tecplot/Vvelocity_' // trim ( curd ) // '.dat' call ReadOldDataVelocityCell ( filename , VCell , TVar % v ) filename = trim ( adjustl ( dir )) // 'Tecplot/Particles_' // trim ( curd ) // '.dat' call ReadOldDataParticle ( filename , TraPar , TVar ) filename = trim ( adjustl ( dir )) // 'Convergence.dat' call ReadFileConvergence ( filename , Time , PConv , BoomCase ) BoomCase % XBar1 = BoomCase % Posp % x - BoomCase % Wobj / 2.d0 BoomCase % XBar2 = BoomCase % Posp % x + BoomCase % Wobj / 2.d0 BoomCase % LBar = 1.5d0 / Lref BoomCase % YBar = BoomCase % Posp % y - dsqrt (( BoomCase % Dobj / 2.d0 ) ** 2.d0 - & ( BoomCase % Wobj / 2.d0 ) ** 2.d0 ) - BoomCase % LBar call SolidVolumeFraction ( PGrid , PCell , BoomCase ) call SolidVolumeFraction ( UGrid , UCell , BoomCase ) call SolidVolumeFraction ( VGrid , VCell , BoomCase ) call Grid_Preprocess ( PGrid , UGrid , VGrid , PCell , UCell , VCell , TVar , IttRun ) call NewCellFace ( PCell , UCell , VCell , PGrid , UGrid , VGrid ) !       call Boundary_Condition_Var(PGrid,TVar,Time%NondiT) Time % PhysT = Time % Nondit * PGrid % Lref / TVar % URef IttBegin = IttRun + 1 !        BoomCase%us=0.d0 !        BoomCase%vs=0.d0 else IttBegin = 1 end if do itt = IttBegin , Time % iter !        if(itt>=610) then !          print*,itt !          iprint1=1 !        end if ! if(itt==365) pause call AdamBasforthCrankNicolson ( PGrid , UGrid , VGrid , PCellO , UCellO , VCellO , & PCell , UCell , VCell , TVar , UConv , VConv , PConv , Time , Flux_n1 , TraPar , & BoomCase , itt ) if ( mod ( itt , IParInlet ) == 0 ) then call ParticleInletCondition ( PGrid , PCell , TraPar ) end if call TrackingParticles ( PGrid , PCell , BoomCase , TVar , Time % dt , TraPar ) Time % NondiT = Time % NondiT + Time % dt Time % PhysT = Time % Nondit * PGrid % Lref / TVar % URef if ( itt == 1 ) then open ( unit = 5 , file = trim ( adjustl ( dir )) // 'Convergence.dat' ) close ( 5 , status = 'delete' ) open ( unit = 5 , file = trim ( adjustl ( dir )) // 'WaveJetVelocity.dat' ) close ( 5 , status = 'delete' ) open ( unit = 5 , file = trim ( adjustl ( dir )) // 'WaterHeight.dat' ) close ( 5 , status = 'delete' ) open ( unit = 5 , file = trim ( adjustl ( dir )) // 'WaterPressure.dat' ) close ( 5 , status = 'delete' ) open ( unit = 5 , file = trim ( adjustl ( dir )) // 'ObjectForce.dat' ) close ( 5 , status = 'delete' ) end if !    call PrintWaterJetVelocity(Time%NonDiT,PGrid,PCell,TVar,itt,tempvel,   & !                                                              velaver,timeb) !    call PrintWaveFront(Time%NonDiT,PGrid,PCell) !    call PrintWaterHeight(Time%NonDiT,I1,I2,I3,I4,PGrid,PCell) !    call PrintWaterPressure(Time%NonDiT,J1,J2,J3,J4,TVar) call PrintHistory ( itt , Time , PConv , BoomCase ) ite = INT ( itt ) if ( mod ( itt , iprint1 ) == 0 ) then write ( * , * ), itt , Time % PhysT , Time % NondiT call Print_Result_Tecplot_PCent ( PGrid , TVar , PCell , TraPar , Flux_n1 , itt , 1 ) call Print_Result_Tecplot_UCent ( UGrid , TVar , UCell , itt ) call Print_Result_Tecplot_VCent ( VGrid , TVar , VCell , itt ) call Print_Result_VTK_2D ( PGrid , TVar , PCell , itt ) end if if ( WavePrint /= 0 ) then call PrintWaterWave ( Time % PhysT , PGrid , PCell ) WavePrint = 0 end if end do deallocate ( GraP , Flux_n1 ) end subroutine IterationSolution SUBROUTINE AdamBasforthCrankNicolson ( PGrid , UGrid , VGrid , PCellO , UCellO , & VCellO , PCell , UCell , VCell , TVar , UConv , VConv , PConv , Time , Flux_n1 , & TraPar , BoomCase , itt ) IMPLICIT NONE TYPE ( Grid ), INTENT ( IN ) :: PGrid , UGrid , VGrid TYPE ( Cell ), INTENT ( INOUT ) :: PCellO , UCellO , VCellO , PCell , UCell , VCell TYPE ( Variables ), INTENT ( INOUT ) :: TVar TYPE ( SolverTime ), INTENT ( INOUT ) :: Time TYPE ( Particle ), INTENT ( INOUT ) :: TraPar TYPE ( SolverConvergence ), INTENT ( OUT ) :: UConv , VConv , PConv TYPE ( SolidObject ), INTENT ( INOUT ) :: BoomCase REAL ( KIND = dp ), DIMENSION (:,:,:), allocatable , INTENT ( INOUT ) :: Flux_n1 INTEGER ( kind = it8b ), INTENT ( IN ) :: itt INTEGER ( kind = it4b ) :: i , j REAL ( KIND = dp ) :: dt , Se , ForceObj if ( itt == 1 ) then BoomCase % us = 0.d0 BoomCase % vs = 0.d0 end if ! First Runge-Kutta substep call CopyNewCell ( PCellO , PCell ) call CopyNewCell ( UCellO , UCell ) call CopyNewCell ( VCellO , VCell ) call ComputeForceObject ( BoomCase , PGrid , PCell , VCell , TVar , ForceObj ) !   BoomCase%asy=-(1.14d0*omew)**2.d0*Amp0*dsin(1.14d0*omew*Time%NondiT+pi/2.d0)/    & !                 (TVar%Uref**2.d0/Lref) if ( RunAgain . eqv .. FALSE .) then BoomCase % asy = ( ForceObj - BoomCase % Mobj * g ) / BoomCase % Mobj elseif ( itt > ittRun + 1 ) then BoomCase % asy = ( ForceObj - BoomCase % Mobj * g ) / BoomCase % Mobj end if BoomCase % asx = 0.d0 if ( itt < 10 ) then BoomCase % us = 0.d0 BoomCase % vs = 0.d0 BoomCase % asy = 0.d0 end if call ComputeTimeStep ( UGrid , VGrid , TVar , BoomCase , Time ) open ( unit = 10 , file = trim ( adjustl ( dir )) // 'ObjectForce.dat' , access = 'append' ) write ( 10 , * ), Time % NondiT , ForceObj - BoomCase % Mobj * g , BoomCase % asy , itt close ( 10 ) dt = time % dt if ( itt > 1 ) then call Coupled_LS_VOF ( PGrid , PCell , UCell , VCell , TVar , BoomCase , & Time % NondiT , dt , itt ) call Initial_ClsVofUV ( PCell , PGrid , UCell , UGrid , BoomCase , 0 ) call Initial_ClsVofUV ( PCell , PGrid , VCell , VGrid , BoomCase , 1 ) call Grid_Preprocess ( PGrid , UGrid , VGrid , PCell , UCell , VCell , TVar , itt ) call NewCellFace ( PCell , UCell , VCell , PGrid , UGrid , VGrid ) call Boundary_Condition_Var ( PGrid , PCell , TVar , Time % NondiT ) call InterNewVar ( PCellO , UCellO , VCellO , PCell , UCell , VCell , PGrid , TVar , & BoomCase % vs ) else SParU (:,:) = 0.d0 ; SParV (:,:) = 0.d0 VolParU (:,:) = 0.d0 ; VolParV (:,:) = 0.d0 end if call UpdatePUV ( UGrid , VGrid , PGrid , PCellO , UCellO , VCellO , PCell , UCell , & VCell , TVar , Flux_n1 , TraPar , BoomCase , dt , itt ) ! Calculate the three kind of norm for convergence END SUBROUTINE AdamBasforthCrankNicolson SUBROUTINE ComputeTimeStep ( UGrid , VGrid , TVar , BoomCase , Time ) IMPLICIT NONE TYPE ( Grid ), INTENT ( IN ) :: UGrid , VGrid TYPE ( Variables ), INTENT ( IN ) :: TVar TYPE ( SolidObject ), INTENT ( IN ) :: BoomCase TYPE ( SolverTime ), INTENT ( OUT ) :: Time INTEGER ( kind = it4b ) :: i , j Time % dt = 1.d0 do j = jbeg , jbeg + Jsize - 1 do i = ibeg , ibeg + Isize - 1 Time % dt = dmin1 ( Time % dt , Time % cfl * Ugrid % dx ( i , j ) / dabs ( TVar % u ( i , j ))) Time % dt = dmin1 ( Time % dt , Time % cfl * VGrid % dy ( i , j ) / dabs ( TVar % v ( i , j ))) Time % dt = dmin1 ( Time % dt , 2.d0 * Time % cfl * VGrid % dy ( i , j ) / ( dabs ( TVar % v ( i , j )) + & dsqrt ( TVar % v ( i , j ) ** 2.d0 + 4.d0 * VGrid % dy ( i , j ) / Fr )), & Time % cfl * Vgrid % dy ( i , j ) / ( TVar % Vint / TVar % Uref )) Time % dt = dmin1 ( Time % dt , Time % cfl * Vgrid % dy ( i , j ) / ( TVar % Vint / TVar % Uref )) Time % dt = dmin1 ( Time % dt , Time % cfl * Vgrid % dy ( i , j ) / dabs ( BoomCase % vs )) Time % dt = dmin1 ( Time % dt ,( - BoomCase % vs + & dsqrt ( dmax1 ( dabs ( BoomCase % vs ** 2.d0 + 2.d0 * dabs ( BoomCase % asy ) * 0.05d0 * & VGrid % dy ( i , j )), 1 d - 30 ))) / dabs ( BoomCase % asy + 1.d-20 )) end do Time % dt = dmin1 ( Time % dt , Time % cfl * Ugrid % dx ( 1 , j ) / dabs ( TVar % u ( 0 , j ))) end do END SUBROUTINE ComputeTimeStep SUBROUTINE PrintHistory ( itt , Time , TNorm , BoomCase ) IMPLICIT NONE INTEGER ( kind = it8b ), INTENT ( IN ) :: itt TYPE ( SolverTime ), INTENT ( IN ) :: Time TYPE ( SolverConvergence ), INTENT ( IN ) :: TNorm TYPE ( SolidObject ), INTENT ( IN ) :: BoomCase open ( unit = 5 , file = trim ( adjustl ( dir )) // 'Convergence.dat' , access = 'append' ) write ( 5 , 76 ) itt , Time % NondiT , TNorm % N1 , TNorm % N2 , TNorm % Ninf , TNorm % N1c , & TNorm % N2c , TNorm % Ninfc , BoomCase % Posp % y , & BoomCase % PospO % y , BoomCase % vs , BoomCase % asy close ( 5 ) 76 format ( I10 , 11 ( f24 . 14 )) END SUBROUTINE SUBROUTINE InterNewVar ( PCellO , UCellO , VCellO , PCell , UCell , VCell , PGrid , TVar , vb ) IMPLICIT NONE TYPE ( Cell ), INTENT ( IN ) :: PCellO , UCellO , VCellO , PCell , UCell , VCell TYPE ( Variables ), INTENT ( INOUT ) :: TVar TYPE ( Grid ), INTENT ( IN ) :: PGrid REAL ( KIND = dp ), intent ( in ) :: vb INTEGER ( KIND = it4b ) :: i , j , ii , jj , temp REAL ( KIND = dp ) :: Pu , Pv , SumP , vfa , uleft , uright , vbot , vtop do i = ibeg , ibeg + Isize - 1 do j = jbeg , jbeg + Jsize - 1 ! For pressure cell ! from momentum exchange cell to normal cut cell if ( UCellO % MoExCell ( i , j ) == 1. and . UCell % MoExCell ( i , j ) == 0 ) then ii = UCellO % MsCe ( i , j , 1 ) jj = UCellO % MsCe ( i , j , 2 ) ! TVar%u(ii,jj) = TVar%u(ii,jj)*(UCellO%vof(i,j)+UCellO%vof(ii,jj))/  & !                 (UCellO%vof(ii,jj)+UCellO%vof(i,j)*UCell%delh(i,j)/& !                 UCell%delh(ii,jj)) ! TVar%u(ii,jj) = (TVar%u(ii,jj)*UCellO%vof(ii,jj)+TVar%u(i,j)*      & !                 UCellO%vof(i,j)*(1.d0-UCell%delh(i,j)/            & !                 UCell%delh(ii,jj)))/UCellO%vof(ii,jj) !  TVar%u(i,j) = TVar%u(i,j)*UCell%delh(i,j)/UCell%delh(ii,jj) end if ! from normal cut cell to momentum exchange cell if ( UCell % MoExCell ( i , j ) == 1. and . UCellO % MoExCell ( i , j ) == 0 ) then ii = UCell % MsCe ( i , j , 1 ) jj = UCell % MsCe ( i , j , 2 ) ! TVar%u(ii,jj) = (TVar%u(i,j)*UCellO%vof(i,j)+TVar%u(ii,jj)*        & !                UCellO%vof(ii,jj))/(UCellO%vof(i,j)+UCellO%vof(ii,jj)) ! TVar%u(i,j) = TVar%u(ii,jj) end if ! for U-velocity (New velocity cell) if ( UCellO % VofS ( i , j ) > 1.d0 - epsi . and . UCell % VofS ( i , j ) < 1.d0 - epsi ) then ii = UCell % MsCe ( i , j , 1 ) jj = UCell % MsCe ( i , j , 2 ) ! print*,'new u',i,j TVar % u ( i , j ) = 0.d0 !TVar%u(ii,jj) if ( PCell % EEdge_Area ( i , j ) > epsi ) then uleft = (( - TVar % v ( i , j ) * PCell % NEdge_Area ( i , j ) + & TVar % v ( i , j - 1 ) * PCell % SEdge_Area ( i , j )) * & PGrid % dx ( i , j ) + TVar % u ( i - 1 , j ) * & PCell % WEdge_Area ( i , j ) * PGrid % dy ( i , j ) + & vb * PCell % nyS ( i , j ) * PCell % Wllh ( i , j )) / & ( PCell % EEdge_Area ( i , j ) + 1.d-30 ) / PGrid % dy ( i , j ) else uleft = 0.d0 end if if ( PCell % WEdge_Area ( i + 1 , j ) > epsi ) then uright = (( TVar % v ( i + 1 , j ) * PCell % NEdge_Area ( i + 1 , j ) - & TVar % v ( i + 1 , j - 1 ) * PCell % SEdge_Area ( i + 1 , j )) * & PGrid % dx ( i + 1 , j ) + TVar % u ( i + 1 , j ) * & PCell % EEdge_Area ( i + 1 , j ) * PGrid % dy ( i + 1 , j ) - & vb * PCell % nyS ( i + 1 , j ) * PCell % Wllh ( i + 1 , j )) / & ( PCell % WEdge_Area ( i + 1 , j ) + 1.d-30 ) / PGrid % dy ( i + 1 , j ) else uright = 0.d0 end if !             TVar%u(i,j)=0.5d0*(uleft+uright) !             print*,'Interpolation var' !             print*,i,j !             print*,uleft,uright !             pause'pause to test' end if ! from momentum exchange cell to normal cut cell if ( VCellO % MoExCell ( i , j ) == 1. and . VCell % MoExCell ( i , j ) == 0 ) then ii = VCellO % MsCe ( i , j , 1 ) jj = VCellO % MsCe ( i , j , 2 ) !  TVar%v(ii,jj) = TVar%v(ii,jj)*(VCell%vof(i,j)+VCell%vof(ii,jj))/  & !                  (VCell%vof(ii,jj)+VCell%vof(i,j)*VCell1%delh(i,j)/& !                  VCell1%delh(ii,jj)) !  vfa = vb+(TVar%v(i,j)-vb)*VCell%delh(i,j)/VCell%delh(ii,jj) !  TVar%v(ii,jj) = (TVar%v(ii,jj)*VCell%vof(ii,jj)+TVar%v(i,j)*      & !                  VCell%vof(i,j)-vfa*VCell%vof(i,j))/VCell%vof(ii,jj) !  TVar%v(i,j) = vfa end if ! from normal cut cell to momentum exchange cell if ( VCell % MoExCell ( i , j ) == 1. and . VCellO % MoExCell ( i , j ) == 0 ) then ii = VCell % MsCe ( i , j , 1 ) jj = VCell % MsCe ( i , j , 2 ) !  TVar%v(ii,jj) = (TVar%v(i,j)*VCell%vof(i,j)+TVar%v(ii,jj)*        & !                 VCell%vof(ii,jj))/(VCell%vof(i,j)+VCell%vof(ii,jj)) !  TVar%v(i,j) = TVar%v(ii,jj) end if ! for V-velocity (new velocity cell) if ( VCellO % VofS ( i , j ) > 1.d0 - epsi . and . VCell % VofS ( i , j ) < 1.d0 - epsi ) then ii = VCell % MsCe ( i , j , 1 ) jj = VCell % MsCe ( i , j , 2 ) TVar % v ( i , j ) = vb !TVar%v(ii,jj)! if ( PCell % Nedge_Area ( i , j ) > epsi ) then vbot = (( - TVar % u ( i , j ) * PCell % EEdge_Area ( i , j ) & + TVar % u ( i - 1 , j ) * PCell % WEdge_Area ( i , j )) * PGrid % dy ( i , j ) & + TVar % v ( i , j - 1 ) * PCell % SEdge_Area ( i , j ) * PGrid % dx ( i , j )) & / PGrid % dx ( i , j ) / ( PCell % NEdge_Area ( i , j ) + 1.d-30 ) else vbot = vb end if if ( PCell % SEdge_Area ( i , j + 1 ) > epsi ) then vtop = (( TVar % u ( i , j + 1 ) * PCell % EEdge_Area ( i , j + 1 ) & - TVar % u ( i - 1 , j + 1 ) * PCell % WEdge_Area ( i , j + 1 )) * PGrid % dy ( i , j + 1 ) & + TVar % v ( i , j + 1 ) * PCell % NEdge_Area ( i , j + 1 ) * PGrid % dx ( i , j + 1 )) & / PGrid % dx ( i , j + 1 ) / ( PCell % SEdge_Area ( i , j + 1 ) + 1.d-30 ) else vbot = vb end if !             TVar%v(i,j)=0.5d0*(vbot+vtop) end if if ( PCell % NEdge_Area ( i , j ) > epsi . and . PCellO % NEdge_Area ( i , j ) > epsi ) then if ( PCell % NEdge_Area ( i , j ) > 0.5d0 . or . PCellO % NEdge_Area ( i , j ) > 0.5d0 ) then if ( PCellO % NEdge_Area ( i , j ) / PCell % NEdge_Area ( i , j ) < 0.6d0 ) then TVar % v ( i , j ) = TVar % v ( i , j ) * PCellO % NEdge_Area ( i , j ) / PCell % NEdge_Area ( i , j ) !                 print*,'this for interpolation VVVVVVVVVVVVVVV' !                 print*,i,j !                 print*,PCellO%NEdge_Area(i,j),PCell%NEdge_Area(i,j) !                 print*,PCellO%NEdge_Area(i,j)/PCell%NEdge_Area(i,j) !                 print*,TVar%v(i,j) !                 print*,'*************************' end if end if end if if ( PCell % EEdge_Area ( i , j ) > epsi . and . PCellO % EEdge_Area ( i , j ) > epsi ) then if ( PCell % EEdge_Area ( i , j ) > 0.5d0 . or . PCellO % EEdge_Area ( i , j ) > 0.5d0 ) then if ( PCellO % EEdge_Area ( i , j ) / PCell % EEdge_Area ( i , j ) < 0.6 ) then TVar % u ( i , j ) = TVar % u ( i , j ) * PCellO % EEdge_Area ( i , j ) / PCell % EEdge_Area ( i , j ) !                 print*,'this for interpolation UUUUUUUUUUUUUUU' !                 print*,i,j !                 print*,PCellO%EEdge_Area(i,j),PCell%EEdge_Area(i,j) !                 print*,PCellO%EEdge_Area(i,j)/PCell%EEdge_Area(i,j) !                 print*,TVar%u(i,j) !                 print*,'*************************' end if end if end if end do end do END SUBROUTINE InterNewVar SUBROUTINE ReadFileConvergence ( filename , Time , TNorm , BoomCase ) IMPLICIT NONE CHARACTER ( LEN = 80 ), INTENT ( IN ) :: filename TYPE ( SolverTime ), INTENT ( INOUT ) :: Time TYPE ( SolverConvergence ), INTENT ( INOUT ) :: TNorm TYPE ( SolidObject ), INTENT ( INOUT ) :: BoomCase INTEGER ( KIND = it4b ) :: i , j open ( unit = 5 , file = filename , action = 'read' ) do i = 1 , IttRun read ( 5 , 76 ) j , Time % NondiT , TNorm % N1 , TNorm % N2 , TNorm % Ninf , & TNorm % N1c , TNorm % N2c , TNorm % Ninfc , BoomCase % Posp % y , & BoomCase % PospO % y , BoomCase % vs , BoomCase % asy end do close ( 5 ) 76 format ( I10 , 11 ( f24 . 14 )) END SUBROUTINE ReadFileConvergence SUBROUTINE PrintWaterHeight ( NonTime , I1 , I2 , I3 , I4 , PGrid , PCell ) IMPLICIT NONE REAL ( KIND = dp ), INTENT ( IN ) :: NonTime INTEGER ( kind = it4b ), INTENT ( IN ) :: I1 , I2 , I3 , I4 TYPE ( Grid ), INTENT ( IN ) :: PGrid TYPE ( Cell ), INTENT ( IN ) :: PCell INTEGER ( kind = it4b ) :: j REAL ( KIND = dp ) :: H1 , H2 , H3 , H4 do j = 1 , Jsize if ( PCell % vof ( I1 , j ) > epsi . and . PCell % vof ( I1 , j ) < 1.d0 - epsi ) then H1 = PGrid % y ( I1 , j ) + ( PCell % vof ( I1 , j ) - 0.5d0 ) * PGrid % dy ( I1 , j ) end if if ( PCell % vof ( I2 , j ) > epsi . and . PCell % vof ( I2 , j ) < 1.d0 - epsi ) then H2 = PGrid % y ( I2 , j ) + ( PCell % vof ( I2 , j ) - 0.5d0 ) * PGrid % dy ( I2 , j ) end if if ( PCell % vof ( I3 , j ) > epsi . and . PCell % vof ( I3 , j ) < 1.d0 - epsi ) then H3 = PGrid % y ( I3 , j ) + ( PCell % vof ( I3 , j ) - 0.5d0 ) * PGrid % dy ( I3 , j ) end if if ( PCell % vof ( I4 , j ) > epsi . and . PCell % vof ( I4 , j ) < 1.d0 - epsi ) then H4 = PGrid % y ( I4 , j ) + ( PCell % vof ( I4 , j ) - 0.5d0 ) * PGrid % dy ( I4 , j ) end if end do open ( unit = 5 , file = trim ( adjustl ( dir )) // 'WaterHeight.dat' , access = 'append' ) write ( 5 , 78 ) NonTime , H1 , H2 , H3 , H4 close ( 5 ) 78 format ( f15 . 10 , f15 . 10 , f15 . 10 , f15 . 10 , f15 . 10 ) END SUBROUTINE PrintWaterHeight SUBROUTINE PrintWaterWave ( TimePrint , PGrid , PCell ) REAL ( KIND = dp ), INTENT ( IN ) :: TimePrint TYPE ( Grid ), INTENT ( IN ) :: PGrid TYPE ( Cell ), INTENT ( IN ) :: PCell INTEGER ( kind = it4b ) :: i , j character ( len = 250 ) :: curd REAL ( KIND = dp ) :: VolPrint , XPrint , HPrint , tol , Hmax tol = 1.d-24 write ( curd , '(f15.8)' ) TimePrint open ( unit = 5 , file = trim ( adjustl ( dir )) // 'WaveProfile_' // trim ( curd ) // '.dat' , & action = 'write' ) if ( WavePrint == 3 ) then Hmax = 2.d0 else Hmax = 0.d0 end if do i = 1 , Isize VolPrint = 1.d0 do j = 1 , Jsize if ( PCell % vof ( i , j ) > epsi . and . PCell % vof ( i , j ) < 1.d0 - epsi ) then ! Check for the cell which has liquid volume fraction closing to 0.5 if ( dabs ( PCell % vof ( i , j ) - 0.5d0 ) < VolPrint ) then VolPrint = dabs ( PCell % vof ( i , j ) - 0.5d0 ) XPrint = PGrid % x ( i , j ) ! Calculate the Liquid height HPrint = PGrid % y ( i , j ) - PCell % phi ( i , j ) / ( PCell % ny ( i , j ) + tol ) - & 0.05d0 / PGrid % Lref end if end if end do write ( 5 , 100 ) ( XPrint ) * 10 0.d0 , HPrint * 10 0.d0 end do close ( 5 ) 100 format ( f15 . 10 , f15 . 10 ) END SUBROUTINE PrintWaterWave SUBROUTINE PrintWaterPressure ( NonTime , J1 , J2 , J3 , J4 , Var ) REAL ( KIND = dp ), INTENT ( IN ) :: NonTime INTEGER ( kind = it4b ), INTENT ( IN ) :: J1 , J2 , J3 , J4 TYPE ( Variables ), INTENT ( IN ) :: Var REAL ( KIND = dp ) :: P1 , P2 , P3 , P4 P1 = Var % p ( Isize , J1 ) P2 = Var % p ( Isize , J2 ) P3 = Var % p ( Isize , J3 ) p4 = Var % p ( Isize , J4 ) open ( unit = 5 , file = trim ( adjustl ( dir )) // 'WaterPressure.dat' , access = 'append' ) write ( 5 , 78 ) NonTime , P1 , P2 , P3 , P4 close ( 5 ) 78 format ( f15 . 10 , f15 . 10 , f15 . 10 , f15 . 10 , f15 . 10 ) END SUBROUTINE PrintWaterPressure SUBROUTINE CopyNewCell ( TCellCo , TCellTa ) IMPLICIT NONE TYPE ( Cell ), INTENT ( IN ) :: TCellTa TYPE ( Cell ), INTENT ( INOUT ) :: TCellCo INTEGER ( kind = it4b ) :: i , j do i = ibeg , ibeg + Isize - 1 do j = jbeg , jbeg + Jsize - 1 TCellCo % vof ( i , j ) = TCellTa % vof ( i , j ) TCellCo % phi ( i , j ) = TCellTa % phi ( i , j ) TCellCo % nx ( i , j ) = TCellTa % nx ( i , j ) TCellCo % ny ( i , j ) = TCellTa % ny ( i , j ) TCellCo % vofS ( i , j ) = TCellTa % vofS ( i , j ) TCellCo % phiS ( i , j ) = TCellTa % phiS ( i , j ) TCellCo % nxS ( i , j ) = TCellTa % nxS ( i , j ) TCellCo % nyS ( i , j ) = TCellTa % nyS ( i , j ) TCellCo % EEdge_Area ( i , j ) = TCellTa % EEdge_Area ( i , j ) TCellCo % WEdge_Area ( i , j ) = TCellTa % WEdge_Area ( i , j ) TCellCo % NEdge_Area ( i , j ) = TCellTa % NEdge_Area ( i , j ) TCellCo % SEdge_Area ( i , j ) = TCellTa % SEdge_Area ( i , j ) if ( allocated ( TCellCo % MoExCell )) then TCellCo % MoExCell ( i , j ) = TCellTa % MoExCell ( i , j ) end if if ( allocated ( TCellCo % Cell_Cent )) then TCellCo % Cell_Cent ( i , j ,:) = TCellTa % Cell_Cent ( i , j ,:) end if if ( allocated ( TCellCo % EtaE )) TCellCo % EtaE ( i , j ) = TCellTa % EtaE ( i , j ) if ( allocated ( TCellCo % EtaE )) TCellCo % EtaN ( i , j ) = TCellTa % EtaN ( i , j ) if ( allocated ( TCellCo % AlE )) TCellCo % AlE ( i , j ) = TCellTa % AlE ( i , j ) if ( allocated ( TCellCo % AlN )) TCellCo % AlN ( i , j ) = TCellTa % AlN ( i , j ) if ( allocated ( TCellCo % DAlE )) TCellCo % DAlE ( i , j ) = TCellTa % DAlE ( i , j ) if ( allocated ( TCellCo % DAlN )) TCellCo % DAlN ( i , j ) = TCellTa % DAlN ( i , j ) if ( allocated ( TCellCo % SxE )) TCellCo % SxE ( i , j ) = TCellTa % SxE ( i , j ) if ( allocated ( TCellCo % SyN )) TCellCo % SyN ( i , j ) = TCellTa % SyN ( i , j ) if ( allocated ( TCellCo % FCE )) TCellCo % FCE ( i , j ,:) = TCellTa % FCE ( i , j ,:) if ( allocated ( TCellCo % FCN )) TCellCo % FCN ( i , j ,:) = TCellTa % FCN ( i , j ,:) if ( allocated ( TCellCo % WlLh )) TCellCo % WlLh ( i , j ) = TCellTa % WlLh ( i , j ) if ( allocated ( TCellCo % delh )) TCellCo % delh ( i , j ) = TCellTa % delh ( i , j ) if ( allocated ( TCellCo % MsCe )) TCellCo % MsCe ( i , j ,:) = TCellTa % MsCe ( i , j ,:) TCellCo % ExtCell = TCellTa % ExtCell end do end do do i = ibeg - 1 , ibeg + Isize - 1 + 1 do j = jbeg - 1 , jbeg + Jsize - 1 + 1 TCellCo % EEdge_Area ( i , j ) = TCellTa % EEdge_Area ( i , j ) TCellCo % WEdge_Area ( i , j ) = TCellTa % WEdge_Area ( i , j ) TCellCo % NEdge_Area ( i , j ) = TCellTa % NEdge_Area ( i , j ) TCellCo % SEdge_Area ( i , j ) = TCellTa % SEdge_Area ( i , j ) end do end do END SUBROUTINE CopyNewCell !    SUBROUTINE WaveBoundaryCondition(PGrid,Vari,Time) !      TYPE(Grid),INTENT(IN):: PGrid !      TYPE(Variables),INTENT(INOUT):: Vari !      TYPE(SolverTime),INTENT(IN):: Time !      INTEGER(kind=it8b):: i,j !      REAL(KIND=dp):: etau,etav !      etau=amp0*dsin(2.d0*pi/Lamdaw*(-cw0*Time%NondiT)) !      etav=amp0*dsin(2.d0*pi/Lamdaw*(-PGrid%dx(1,1)/2.d0-cw0*Time%NondiT)) !      do j=jbeg,Jsize+jbeg-1 !      ! Left inlet wall !        Vari%p(ibeg-ight,j)=Vari%p(ibeg,j) !Vari%Pint/(Vari%Pref) !        Vari%t(ibeg-ight,j)=Vari%t(ibeg,j) !        if(PGrid%y(1,j)-PGrid%dy(1,j)/2.d0<Hw+etau) then !        ! for water entry velocity !          Vari%u(ibeg-ight,j)=2.d0*pi/Lamdaw*cw0*etau*                         & !                 dcosh(2.d0*pi*PGrid%y(1,j))/dsinh(2.d0*pi*Hw) !        else !        ! for gas entry velocity !          Vari%u(ibeg-ight,j)=-2.d0*pi/Lamdaw*cw0*etau*                        & !                 dcosh(2.d0*pi*(HChannel-PGrid%y(1,j)))/dsinh(2.d0*pi*Ha) !        end if !        if(PGrid%y(1,j)-PGrid%dy(1,j)/2.d0<Hw+etav) then !          Vari%v(ibeg-ight,j)=-Amp0*2.d0*pi/cw0*                               & !                dcos(2.d0*pi/Lamdaw*(-PGrid%dx(1,1)/2.d0-cw0*Time%NondiT))*    & !                dsinh(2.d0*pi*PGrid%y(1,j))/dsinh(2.d0*pi*Hw) !        else !          Vari%v(ibeg-ight,j)=Amp0*2.d0*pi/cw0*                                & !                dcos(2.d0*pi/Lamdaw*(-PGrid%dx(1,1)/2.d0-cw0*Time%NondiT))*    & !                dsinh(2.d0*pi*(HChannel-PGrid%y(1,j)))/dsinh(2.d0*pi*Ha) !        end if !      ! Right Wall non-Slip wall !        Vari%p(Isize+ibeg+ight-1,j)=Vari%p(Isize+ibeg-1,j) !        Vari%t(Isize+ibeg+ight-1,j)=Vari%t(ibeg+Isize-1,j) !        Vari%u(Isize+ibeg+ight-1,j)=0.d0!-Vari%u(Isize+ibeg-1,j) !Vari%Uint/Vari%Uref !        Vari%u(Isize+ibeg-1,j)=0.d0 !        Vari%v(Isize+ibeg+ight-1,j)=0.d0-Vari%v(Isize+ibeg-1,j) !Vari%Vint/Vari%Uref !      end do !      do i = ibeg,Isize+ibeg-1 !      ! Bottom wall non-slip wall !        Vari%p(i,jbeg-jght)=Vari%p(i,jbeg) !        Vari%t(i,jbeg-jght)=Vari%t(i,jbeg) !        Vari%u(i,jbeg-jght)=Vari%u(i,jbeg) !        Vari%v(i,jbeg-jght)=0.d0 !Vari%Vint/Vari%Uref !      ! Open air !        Vari%p(i,Jsize+jbeg+jght-1)=0.d0 !        Vari%t(i,jbeg+Jsize+jght-1)=Vari%t(i,jbeg+Jsize-1) !        Vari%u(i,Jsize+jbeg+jght-1)=Vari%u(i,Jsize+jbeg-1) !     !   Vari%v(i,Jsize+jbeg-1) = Vari%v(i,Jsize+jbeg-2) !     !   Vari%v(i,Jsize+jbeg+jght-1) = Vari%v(i,Jsize+jbeg-1) !      end do !    END SUBROUTINE WaveBoundaryCondition END MODULE Solver","tags":"","loc":"sourcefile/solver_mod.f90.html","title":"Solver_Mod.f90 – Fortran Program"},{"text":"type, public :: VTK_file_handle Contents Variables prefix unit ni nj nk counter restart first Components Type Visibility Attributes Name Initial character(len=80), private :: prefix integer, private :: unit integer, private :: ni integer, private :: nj integer, private :: nk integer, private :: counter = 0 integer, private :: restart = 0 logical, private :: first = .true.","tags":"","loc":"type/vtk_file_handle.html","title":"VTK_file_handle – Fortran Program "},{"text":"type, public :: Point Contents Variables x y Components Type Visibility Attributes Name Initial real(kind=dp), public :: x real(kind=dp), public :: y","tags":"","loc":"type/point.html","title":"Point – Fortran Program "},{"text":"type, public :: Grid Contents Variables Grid_Id x y dx dy Lref Components Type Visibility Attributes Name Initial integer(kind=8), public :: Grid_Id real(kind=dp), public, DIMENSION(:,:), allocatable :: x real(kind=dp), public, DIMENSION(:,:), allocatable :: y real(kind=dp), public, DIMENSION(:,:), allocatable :: dx real(kind=dp), public, DIMENSION(:,:), allocatable :: dy real(kind=dp), public :: Lref","tags":"","loc":"type/grid.html","title":"Grid – Fortran Program "},{"text":"type, public :: Cell Contents Variables PosNu MoExCell ExtCell Vof Phi VofS PhiS nx ny nxS nyS EEdge_Area WEdge_Area NEdge_Area SEdge_Area Cell_Cent MsCe WlLh delh FCE FCN EtaE EtaN DAlE DAlN AlE AlN SxE SyN Components Type Visibility Attributes Name Initial integer(kind=it4b), public, DIMENSION(:,:), allocatable :: PosNu integer(kind=it4b), public, DIMENSION(:,:), allocatable :: MoExCell integer(kind=it4b), public :: ExtCell real(kind=dp), public, DIMENSION(:,:), allocatable :: Vof real(kind=dp), public, DIMENSION(:,:), allocatable :: Phi real(kind=dp), public, DIMENSION(:,:), allocatable :: VofS real(kind=dp), public, DIMENSION(:,:), allocatable :: PhiS real(kind=dp), public, DIMENSION(:,:), allocatable :: nx real(kind=dp), public, DIMENSION(:,:), allocatable :: ny real(kind=dp), public, DIMENSION(:,:), allocatable :: nxS real(kind=dp), public, DIMENSION(:,:), allocatable :: nyS real(kind=dp), public, DIMENSION(:,:), allocatable :: EEdge_Area real(kind=dp), public, DIMENSION(:,:), allocatable :: WEdge_Area real(kind=dp), public, DIMENSION(:,:), allocatable :: NEdge_Area real(kind=dp), public, DIMENSION(:,:), allocatable :: SEdge_Area real(kind=dp), public, DIMENSION(:,:,:), allocatable :: Cell_Cent real(kind=dp), public, DIMENSION(:,:,:), allocatable :: MsCe real(kind=dp), public, DIMENSION(:,:), allocatable :: WlLh real(kind=dp), public, DIMENSION(:,:), allocatable :: delh real(kind=dp), public, DIMENSION(:,:,:), allocatable :: FCE real(kind=dp), public, DIMENSION(:,:,:), allocatable :: FCN real(kind=dp), public, DIMENSION(:,:), allocatable :: EtaE real(kind=dp), public, DIMENSION(:,:), allocatable :: EtaN real(kind=dp), public, DIMENSION(:,:), allocatable :: DAlE real(kind=dp), public, DIMENSION(:,:), allocatable :: DAlN real(kind=dp), public, DIMENSION(:,:), allocatable :: AlE real(kind=dp), public, DIMENSION(:,:), allocatable :: AlN real(kind=dp), public, DIMENSION(:,:), allocatable :: SxE real(kind=dp), public, DIMENSION(:,:), allocatable :: SyN","tags":"","loc":"type/cell.html","title":"Cell – Fortran Program "},{"text":"type, private :: ParVel Contents Variables u v Components Type Visibility Attributes Name Initial real(kind=dp), public :: u real(kind=dp), public :: v","tags":"","loc":"type/parvel.html","title":"ParVel – Fortran Program "},{"text":"type, public :: Particle Contents Variables np Posp uvp mp dp tp t VrelG y dydt Components Type Visibility Attributes Name Initial integer(kind=it4b), public :: np type(Point), public, DIMENSION(:), allocatable :: Posp type( ParVel ), public, DIMENSION(:), allocatable :: uvp real(kind=dp), public, DIMENSION(:), allocatable :: mp real(kind=dp), public, DIMENSION(:), allocatable :: dp real(kind=dp), public, DIMENSION(:), allocatable :: tp real(kind=dp), public, DIMENSION(:), allocatable :: t real(kind=dp), public, DIMENSION(:), allocatable :: VrelG real(kind=dp), public, DIMENSION(:), allocatable :: y real(kind=dp), public, DIMENSION(:), allocatable :: dydt","tags":"","loc":"type/particle.html","title":"Particle – Fortran Program "},{"text":"type, public :: SolidObject Contents Variables Posp PospO us vs asx asy Dobj Wobj Mobj Xbar1 Xbar2 Ybar Lbar Components Type Visibility Attributes Name Initial type(Point), public :: Posp The object position type(Point), public :: PospO The object previous position real(kind=dp), public :: us The object velocity real(kind=dp), public :: vs The object velocity real(kind=dp), public :: asx The object acceleration real(kind=dp), public :: asy The object acceleration real(kind=dp), public :: Dobj The Boom diameter real(kind=dp), public :: Wobj The Boom width real(kind=dp), public :: Mobj The Boom Weight real(kind=dp), public :: Xbar1 The x position bottom left corner of boom real(kind=dp), public :: Xbar2 The x position bottom right corner of boom real(kind=dp), public :: Ybar The y position bottom of boom real(kind=dp), public :: Lbar The length of boom tail","tags":"","loc":"type/solidobject.html","title":"SolidObject – Fortran Program "},{"text":"type, public :: Variables Contents Variables u v p t Gpu Gpv ures vres pres mres Uint Vint Pint Tint Uref Roref Pref Tref Components Type Visibility Attributes Name Initial real(kind=dp), public, DIMENSION(:,:), allocatable :: u real(kind=dp), public, DIMENSION(:,:), allocatable :: v real(kind=dp), public, DIMENSION(:,:), allocatable :: p real(kind=dp), public, DIMENSION(:,:), allocatable :: t real(kind=dp), public, DIMENSION(:,:), allocatable :: Gpu real(kind=dp), public, DIMENSION(:,:), allocatable :: Gpv real(kind=dp), public, DIMENSION(:,:), allocatable :: ures real(kind=dp), public, DIMENSION(:,:), allocatable :: vres real(kind=dp), public, DIMENSION(:,:), allocatable :: pres real(kind=dp), public, DIMENSION(:,:), allocatable :: mres real(kind=dp), public :: Uint real(kind=dp), public :: Vint real(kind=dp), public :: Pint real(kind=dp), public :: Tint real(kind=dp), public :: Uref real(kind=dp), public :: Roref real(kind=dp), public :: Pref real(kind=dp), public :: Tref","tags":"","loc":"type/variables.html","title":"Variables – Fortran Program "},{"text":"type, public :: Predictor Contents Variables u v Components Type Visibility Attributes Name Initial real(kind=dp), public, DIMENSION(:,:), allocatable :: u real(kind=dp), public, DIMENSION(:,:), allocatable :: v","tags":"","loc":"type/predictor.html","title":"Predictor – Fortran Program "},{"text":"type, public :: PoissonCoefficient Contents Variables Dp Components Type Visibility Attributes Name Initial real(kind=dp), public, DIMENSION(:,:), allocatable :: Dp","tags":"","loc":"type/poissoncoefficient.html","title":"PoissonCoefficient – Fortran Program "},{"text":"type, public :: VTR_file_handle Contents Variables prefix unit ni nj nk counter restart first Components Type Visibility Attributes Name Initial character(len=80), private :: prefix integer, private :: unit integer, private :: ni integer, private :: nj integer, private :: nk integer, private :: counter = 0 integer, private :: restart = 0 logical, private :: first = .true.","tags":"","loc":"type/vtr_file_handle.html","title":"VTR_file_handle – Fortran Program "},{"text":"type, public :: Projection Contents Variables Pp Components Type Visibility Attributes Name Initial real(kind=dp), public, DIMENSION(:,:), ALLOCATABLE :: Pp","tags":"","loc":"type/projection.html","title":"Projection – Fortran Program "},{"text":"type, public :: SolverTime Contents Variables iter cfl dt PhysT NondiT Components Type Visibility Attributes Name Initial integer(kind=it8b), public :: iter real(kind=dp), public :: cfl real(kind=dp), public :: dt real(kind=dp), public :: PhysT real(kind=dp), public :: NondiT","tags":"","loc":"type/solvertime.html","title":"SolverTime – Fortran Program "},{"text":"type, public :: SolverConvergence Contents Variables N1 N2 NInf N1c N2c NInfc Components Type Visibility Attributes Name Initial real(kind=dp), public :: N1 real(kind=dp), public :: N2 real(kind=dp), public :: NInf real(kind=dp), public :: N1c real(kind=dp), public :: N2c real(kind=dp), public :: NInfc","tags":"","loc":"type/solverconvergence.html","title":"SolverConvergence – Fortran Program "},{"text":"private subroutine handle_error(name, message) The subroutine is used to print out the error with opening or writting vtk file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name The error message character(len=*), intent(in) :: message The error message Contents None","tags":"","loc":"proc/handle_error.html","title":"handle_error – Fortran Program"},{"text":"private subroutine handle_warning(name, message) The subroutine is used to print out the warning with opening or writting vtk file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name The warning message character(len=*), intent(in) :: message The warning message Contents None","tags":"","loc":"proc/handle_warning.html","title":"handle_warning – Fortran Program"},{"text":"private subroutine handle_info(name, message) The subroutine is used to print out the information about the opening or writting vtk file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name The info message character(len=*), intent(in) :: message The info message Contents None","tags":"","loc":"proc/handle_info.html","title":"handle_info – Fortran Program"},{"text":"public subroutine VTK_open_file(prefix, proc_rank, num_procs, restart, fd) The subroutine is used to open a .vtk file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: prefix The directory where the output files are stored integer, intent(in), optional :: proc_rank Arguments for MPI integer, intent(in), optional :: num_procs Arguments for MPI integer, intent(in), optional :: restart Arguments for MPI type( VTK_file_handle ), intent(inout) :: fd The Contents None","tags":"","loc":"proc/vtk_open_file.html","title":"VTK_open_file – Fortran Program"},{"text":"private subroutine VTK_write_mesh_2d(fd, x, y) Arguments Type Intent Optional Attributes Name type( VTK_file_handle ), intent(inout) :: fd real(kind=dp), intent(in), DIMENSION(:) :: x real(kind=dp), intent(in), DIMENSION(:) :: y Contents None","tags":"","loc":"proc/vtk_write_mesh_2d.html","title":"VTK_write_mesh_2d – Fortran Program"},{"text":"private subroutine VTK_write_mesh_3d(fd, x, y, z) Arguments Type Intent Optional Attributes Name type( VTK_file_handle ), intent(inout) :: fd real(kind=dp), intent(in), DIMENSION(:) :: x real(kind=dp), intent(in), DIMENSION(:) :: y real(kind=dp), intent(in), DIMENSION(:) :: z Contents None","tags":"","loc":"proc/vtk_write_mesh_3d.html","title":"VTK_write_mesh_3d – Fortran Program"},{"text":"private subroutine VTK_write_vector_2d(fd, name, vx, vy) Arguments Type Intent Optional Attributes Name type( VTK_file_handle ), intent(in) :: fd character(len=*), intent(in) :: name real(kind=dp), intent(in), DIMENSION(:,:) :: vx real(kind=dp), intent(in), DIMENSION(:,:) :: vy Contents None","tags":"","loc":"proc/vtk_write_vector_2d.html","title":"VTK_write_vector_2d – Fortran Program"},{"text":"private subroutine VTK_write_vector_3d(fd, name, vx, vy, vz) Arguments Type Intent Optional Attributes Name type( VTK_file_handle ), intent(in) :: fd character(len=*), intent(in) :: name real(kind=dp), intent(in), DIMENSION(:,:,:) :: vx real(kind=dp), intent(in), DIMENSION(:,:,:) :: vy real(kind=dp), intent(in), DIMENSION(:,:,:) :: vz Contents None","tags":"","loc":"proc/vtk_write_vector_3d.html","title":"VTK_write_vector_3d – Fortran Program"},{"text":"private subroutine VTK_write_scalar_2d(fd, name, field) Arguments Type Intent Optional Attributes Name type( VTK_file_handle ), intent(in) :: fd character(len=*), intent(in) :: name real(kind=dp), intent(in), DIMENSION(:,:) :: field Contents None","tags":"","loc":"proc/vtk_write_scalar_2d.html","title":"VTK_write_scalar_2d – Fortran Program"},{"text":"private subroutine VTK_write_scalar_3d(fd, name, field) Arguments Type Intent Optional Attributes Name type( VTK_file_handle ), intent(in) :: fd character(len=*), intent(in) :: name real(kind=dp), intent(in), DIMENSION(:,:,:) :: field Contents None","tags":"","loc":"proc/vtk_write_scalar_3d.html","title":"VTK_write_scalar_3d – Fortran Program"},{"text":"public subroutine VTK_close_file(fd) Arguments Type Intent Optional Attributes Name type( VTK_file_handle ), intent(in) :: fd Contents None","tags":"","loc":"proc/vtk_close_file.html","title":"VTK_close_file – Fortran Program"},{"text":"public subroutine VTK_collect_file(fd) Arguments Type Intent Optional Attributes Name type( VTK_file_handle ), intent(inout) :: fd Contents None","tags":"","loc":"proc/vtk_collect_file.html","title":"VTK_collect_file – Fortran Program"},{"text":"public interface VTK_write_mesh Contents Module Procedures VTK_write_mesh_2d VTK_write_mesh_3d Module Procedures private subroutine VTK_write_mesh_2d (fd, x, y) Arguments Type Intent Optional Attributes Name type( VTK_file_handle ), intent(inout) :: fd real(kind=dp), intent(in), DIMENSION(:) :: x real(kind=dp), intent(in), DIMENSION(:) :: y private subroutine VTK_write_mesh_3d (fd, x, y, z) Arguments Type Intent Optional Attributes Name type( VTK_file_handle ), intent(inout) :: fd real(kind=dp), intent(in), DIMENSION(:) :: x real(kind=dp), intent(in), DIMENSION(:) :: y real(kind=dp), intent(in), DIMENSION(:) :: z","tags":"","loc":"interface/vtk_write_mesh.html","title":"VTK_write_mesh – Fortran Program"},{"text":"public interface VTK_write_var Contents Module Procedures VTK_write_scalar_2d VTK_write_scalar_3d VTK_write_vector_2d VTK_write_vector_3d Module Procedures private subroutine VTK_write_scalar_2d (fd, name, field) Arguments Type Intent Optional Attributes Name type( VTK_file_handle ), intent(in) :: fd character(len=*), intent(in) :: name real(kind=dp), intent(in), DIMENSION(:,:) :: field private subroutine VTK_write_scalar_3d (fd, name, field) Arguments Type Intent Optional Attributes Name type( VTK_file_handle ), intent(in) :: fd character(len=*), intent(in) :: name real(kind=dp), intent(in), DIMENSION(:,:,:) :: field private subroutine VTK_write_vector_2d (fd, name, vx, vy) Arguments Type Intent Optional Attributes Name type( VTK_file_handle ), intent(in) :: fd character(len=*), intent(in) :: name real(kind=dp), intent(in), DIMENSION(:,:) :: vx real(kind=dp), intent(in), DIMENSION(:,:) :: vy private subroutine VTK_write_vector_3d (fd, name, vx, vy, vz) Arguments Type Intent Optional Attributes Name type( VTK_file_handle ), intent(in) :: fd character(len=*), intent(in) :: name real(kind=dp), intent(in), DIMENSION(:,:,:) :: vx real(kind=dp), intent(in), DIMENSION(:,:,:) :: vy real(kind=dp), intent(in), DIMENSION(:,:,:) :: vz","tags":"","loc":"interface/vtk_write_var.html","title":"VTK_write_var – Fortran Program"},{"text":"public subroutine UpdatePUV(UGrid, VGrid, PGrid, PCellO, UCellO, VCellO, PCell, UCell, VCell, TVar, Flux_n1, TraPar, BoomCase, dt, itt) The subroutine computes the flow field parameters in the next time step. Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: UGrid The input grid type(Grid), intent(in) :: VGrid The input grid type(Grid), intent(in) :: PGrid The input grid type(Cell), intent(inout) :: PCellO The input and output cell a previous time step type(Cell), intent(inout) :: UCellO The input and output cell a previous time step type(Cell), intent(inout) :: VCellO The input and output cell a previous time step type(Cell), intent(inout) :: PCell The input and output cell type(Cell), intent(inout) :: UCell The input and output cell type(Cell), intent(inout) :: VCell The input and output cell type(Variables), intent(inout) :: TVar The state variables real(kind=dp), intent(inout), DIMENSION(:,:,:), allocatable :: Flux_n1 The total flux at the previous time step type(Particle), intent(inout) :: TraPar The particle information type(SolidObject), intent(in) :: BoomCase The boom real(kind=dp), intent(in) :: dt The time step integer(kind=it8b), intent(in) :: itt Contents None","tags":"","loc":"proc/updatepuv.html","title":"UpdatePUV – Fortran Program"},{"text":"private subroutine VariablesInternalCellCondition(TVar, PCell, UCell, VCell) Arguments Type Intent Optional Attributes Name type(Variables), intent(inout) :: TVar type(Cell), intent(in) :: PCell type(Cell), intent(in) :: UCell type(Cell), intent(in) :: VCell Contents None","tags":"","loc":"proc/variablesinternalcellcondition.html","title":"VariablesInternalCellCondition – Fortran Program"},{"text":"private interface UpdatePUV Contents Module Procedures UpdatePUV Module Procedures private interface UpdatePUV () Arguments None","tags":"","loc":"interface/updatepuv.html","title":"UpdatePUV – Fortran Program"},{"text":"public subroutine Grid_Preprocess(PGrid, UGrid, VGrid, PCell, UCell, VCell, TVar, itt) The subroutine compute the surface area and define solid cells. Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: PGrid The grid type(Grid), intent(in) :: UGrid The grid type(Grid), intent(in) :: VGrid The grid type(Cell), intent(inout) :: PCell The cell type(Cell), intent(inout) :: UCell The cell type(Cell), intent(inout) :: VCell The cell type(Variables), intent(in) :: TVar The state variables integer(kind=it8b), intent(in) :: itt The number of iterations Contents None","tags":"","loc":"proc/grid_preprocess.html","title":"Grid_Preprocess – Fortran Program"},{"text":"private subroutine Cell_Geo_Cal(TGrid, TCell) The subroutine computes the surface area for cut cell. Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: TGrid The grid type(Cell), intent(inout) :: TCell The cell Contents None","tags":"","loc":"proc/cell_geo_cal.html","title":"Cell_Geo_Cal – Fortran Program"},{"text":"private subroutine Edge_Geo_Cal(Pt1, Pt2, nxx, nyy, diss, Edge_Area, Face) Arguments Type Intent Optional Attributes Name type(point), intent(in) :: Pt1 type(point), intent(in) :: Pt2 real(kind=dp), intent(in) :: nxx real(kind=dp), intent(in) :: nyy real(kind=dp), intent(in) :: diss real(kind=dp), intent(out) :: Edge_Area type(point), intent(out) :: Face Contents None","tags":"","loc":"proc/edge_geo_cal.html","title":"Edge_Geo_Cal – Fortran Program"},{"text":"public subroutine NumberExternalCell(TCell, iu, iv) Arguments Type Intent Optional Attributes Name type(Cell), intent(inout) :: TCell integer(kind=it4b), intent(in) :: iu integer(kind=it4b), intent(in) :: iv Contents None","tags":"","loc":"proc/numberexternalcell.html","title":"NumberExternalCell – Fortran Program"},{"text":"private subroutine DefineMomentumExchangeCell(PCell, UCell, VCell) Arguments Type Intent Optional Attributes Name type(Cell), intent(inout) :: PCell type(Cell), intent(inout) :: UCell type(Cell), intent(inout) :: VCell Contents None","tags":"","loc":"proc/definemomentumexchangecell.html","title":"DefineMomentumExchangeCell – Fortran Program"},{"text":"public subroutine NewCellFace(PCell, UCell, VCell, PGrid, UGrid, VGrid) Arguments Type Intent Optional Attributes Name type(Cell), intent(inout) :: PCell type(Cell), intent(inout) :: UCell type(Cell), intent(inout) :: VCell type(Grid), intent(in) :: PGrid type(Grid), intent(in) :: UGrid type(Grid), intent(in) :: VGrid Contents None","tags":"","loc":"proc/newcellface.html","title":"NewCellFace – Fortran Program"},{"text":"private subroutine EastFaceInterpolationInf(TCell, TGrid, BGrid, iu) Arguments Type Intent Optional Attributes Name type(Cell), intent(inout) :: TCell type(Grid), intent(in) :: TGrid type(Grid), intent(in) :: BGrid integer(kind=it4b), intent(in) :: iu Contents None","tags":"","loc":"proc/eastfaceinterpolationinf.html","title":"EastFaceInterpolationInf – Fortran Program"},{"text":"private subroutine NorthFaceInterpolationInf(TCell, TGrid, BGrid, iv) Arguments Type Intent Optional Attributes Name type(Cell), intent(inout) :: TCell type(Grid), intent(in) :: TGrid type(Grid), intent(in) :: BGrid integer(kind=it4b), intent(in) :: iv Contents None","tags":"","loc":"proc/northfaceinterpolationinf.html","title":"NorthFaceInterpolationInf – Fortran Program"},{"text":"private subroutine CellLinking(TGrid, TCell, i, j) Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: TGrid type(Cell), intent(inout) :: TCell integer(kind=it4b), intent(in) :: i integer(kind=it4b), intent(in) :: j Contents None","tags":"","loc":"proc/celllinking.html","title":"CellLinking – Fortran Program"},{"text":"private interface Grid_Preprocess Contents Module Procedures Grid_Preprocess Module Procedures private interface Grid_Preprocess () Arguments None","tags":"","loc":"interface/grid_preprocess.html","title":"Grid_Preprocess – Fortran Program"},{"text":"private interface NumberExternalCell Contents Module Procedures NumberExternalCell Module Procedures private interface NumberExternalCell () Arguments None","tags":"","loc":"interface/numberexternalcell.html","title":"NumberExternalCell – Fortran Program"},{"text":"private interface NewCellFace Contents Module Procedures NewCellFace Module Procedures private interface NewCellFace () Arguments None","tags":"","loc":"interface/newcellface.html","title":"NewCellFace – Fortran Program"},{"text":"public subroutine Initial_Grid(Start_Point, End_Point, ReS, ReE, NI, NJ, Irec, Jrec, TGrid, Lref, NonUniformMesh) Arguments Type Intent Optional Attributes Name type( Point ), intent(in) :: Start_Point type( Point ), intent(in) :: End_Point type( Point ), intent(in) :: ReS type( Point ), intent(in) :: ReE integer(kind=it4b), intent(in) :: NI integer(kind=it4b), intent(in) :: NJ integer(kind=it4b), intent(in) :: Irec integer(kind=it4b), intent(in) :: Jrec type( Grid ), intent(inout) :: TGrid real(kind=dp), intent(in) :: Lref integer(kind=it4b), intent(in) :: NonUniformMesh Contents None","tags":"","loc":"proc/initial_grid.html","title":"Initial_Grid – Fortran Program"},{"text":"public subroutine InitialUVGrid(PGrid, TGrid, UV, Lref) Arguments Type Intent Optional Attributes Name type( Grid ), intent(in) :: PGrid type( Grid ), intent(inout) :: TGrid integer(kind=it4b), intent(in) :: UV real(kind=dp), intent(in) :: Lref Contents None","tags":"","loc":"proc/initialuvgrid.html","title":"InitialUVGrid – Fortran Program"},{"text":"public subroutine HYPRE_CreateGrid(TGrid) Arguments Type Intent Optional Attributes Name type( Grid ), intent(inout) :: TGrid Contents None","tags":"","loc":"proc/hypre_creategrid.html","title":"HYPRE_CreateGrid – Fortran Program"},{"text":"private subroutine NewtonRaphson(beta, dl, dx, IJsize) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: beta real(kind=dp), intent(in) :: dl real(kind=dp), intent(in) :: dx integer(kind=it4b), intent(in) :: IJsize Contents None","tags":"","loc":"proc/newtonraphson.html","title":"NewtonRaphson – Fortran Program"},{"text":"private interface Initial_Grid Contents Module Procedures Initial_Grid Module Procedures private interface Initial_Grid () Arguments None","tags":"","loc":"interface/initial_grid.html","title":"Initial_Grid – Fortran Program"},{"text":"private interface HYPRE_CreateGrid Contents Module Procedures HYPRE_CreateGrid Module Procedures private interface HYPRE_CreateGrid () Arguments None","tags":"","loc":"interface/hypre_creategrid.html","title":"HYPRE_CreateGrid – Fortran Program"},{"text":"private interface InitialUVGrid Contents Module Procedures InitialUVGrid Module Procedures private interface InitialUVGrid () Arguments None","tags":"","loc":"interface/initialuvgrid.html","title":"InitialUVGrid – Fortran Program"},{"text":"public function Drag(Reyp) result(Cd) Arguments Type Intent Optional Attributes Name real(kind=dp) :: Reyp Return Value real(kind=dp) Contents None","tags":"","loc":"proc/drag.html","title":"Drag – Fortran Program"},{"text":"public subroutine InitializeParticles(PGrid, Var, TraPar) Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: PGrid type(Variables), intent(in) :: Var type( Particle ), intent(inout) :: TraPar Contents None","tags":"","loc":"proc/initializeparticles.html","title":"InitializeParticles – Fortran Program"},{"text":"public subroutine TrackingParticles(PGrid, PCell, BoomCase, Var, dt, TraPar) Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: PGrid type(Cell), intent(in) :: PCell type( SolidObject ), intent(inout) :: BoomCase type(Variables), intent(in) :: Var real(kind=dp), intent(in) :: dt type( Particle ), intent(inout) :: TraPar Contents None","tags":"","loc":"proc/trackingparticles.html","title":"TrackingParticles – Fortran Program"},{"text":"public subroutine ParticlePosition(Posi, TGrid, ii, jj) Arguments Type Intent Optional Attributes Name type(Point), intent(in) :: Posi type(Grid), intent(in) :: TGrid integer(kind=it4b), intent(out) :: ii integer(kind=it4b), intent(out) :: jj Contents None","tags":"","loc":"proc/particleposition.html","title":"ParticlePosition – Fortran Program"},{"text":"public subroutine ParticleInletCondition(PGrid, PCell, TraPar) Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: PGrid type(Cell), intent(in) :: PCell type( Particle ), intent(inout) :: TraPar Contents None","tags":"","loc":"proc/particleinletcondition.html","title":"ParticleInletCondition – Fortran Program"},{"text":"private interface TrackingParticles Contents Module Procedures TrackingParticles Module Procedures private interface TrackingParticles () Arguments None","tags":"","loc":"interface/trackingparticles.html","title":"TrackingParticles – Fortran Program"},{"text":"private interface InitializeParticels Contents Module Procedures InitializeParticles Module Procedures public subroutine InitializeParticles (PGrid, Var, TraPar) Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: PGrid type(Variables), intent(in) :: Var type( Particle ), intent(inout) :: TraPar","tags":"","loc":"interface/initializeparticels.html","title":"InitializeParticels – Fortran Program"},{"text":"private interface ParticlePosition Contents Module Procedures ParticlePosition Module Procedures private interface ParticlePosition () Arguments None","tags":"","loc":"interface/particleposition.html","title":"ParticlePosition – Fortran Program"},{"text":"private interface ParticleInletCondition Contents Module Procedures ParticleInletCondition Module Procedures private interface ParticleInletCondition () Arguments None","tags":"","loc":"interface/particleinletcondition.html","title":"ParticleInletCondition – Fortran Program"},{"text":"private interface Drag Contents Module Procedures Drag Module Procedures private interface Drag () Arguments None","tags":"","loc":"interface/drag.html","title":"Drag – Fortran Program"},{"text":"private function LagrangePoly(posi, valu, PosTar) result(ValTar) Arguments Type Intent Optional Attributes Name real(kind=dp) :: posi (4) real(kind=dp) :: valu (4) real(kind=dp) :: PosTar Return Value real(kind=dp) Contents None","tags":"","loc":"proc/lagrangepoly.html","title":"LagrangePoly – Fortran Program"},{"text":"private function isinsiderect(xp, yp, del_x, del_y) result(logic) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: xp real(kind=dp), intent(in) :: yp real(kind=dp), intent(in) :: del_x real(kind=dp), intent(in) :: del_y Return Value logical Contents None","tags":"","loc":"proc/isinsiderect.html","title":"isinsiderect – Fortran Program"},{"text":"public subroutine Initial_Clsvof(TGrid, TCell, BoomCase) The subroutine computes the initial condition for volume of fluid and \n level set function in the pressure cell. For computing the liquid volume fraction, the intersections between free surface and cell \n edge will be determined first. Then a special method will be \n used to compute the area. Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: TGrid The grid type(Cell), intent(inout), target :: TCell The cell which contains level set, volume of fluid and normal vector type( SolidObject ), intent(in) :: BoomCase The Boom position Contents None","tags":"","loc":"proc/initial_clsvof.html","title":"Initial_Clsvof – Fortran Program"},{"text":"public subroutine Initial_ClsVofUV(PCell, PGrid, TCell, TGrid, BoomCase, uv) The subroutine computes the initial condition for volume of fluid and \n level set function in velocity cells. The liquid volume fraction in the \n velocity cell is the combination of two half parts of two connecting pressure cells. Arguments Type Intent Optional Attributes Name type(Cell), intent(in) :: PCell The data from pressure cell type(Grid), intent(in) :: PGrid The pressure grid type(Cell), intent(inout) :: TCell The target cell which can be u cell or v cell type(Grid), intent(in) :: TGrid The target grid type( SolidObject ), intent(in) :: BoomCase The Boom position integer(kind=it4b), intent(in) :: uv The parameter to determine the target cell is Ucell or VCell Contents None","tags":"","loc":"proc/initial_clsvofuv.html","title":"Initial_ClsVofUV – Fortran Program"},{"text":"public subroutine Coupled_LS_VOF(PGrid, PCell, UCell, VCell, TVar, BoomCase, NondiT, dt, itt) The subroutine solves the coupling level set and volume of fluid to update \n the new position of interface Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: PGrid The pressure grid type(Cell), intent(inout), target :: PCell The pressure cell type(Cell), intent(in) :: UCell The velocity cell type(Cell), intent(in) :: VCell The velocity cell type(Variables), intent(in) :: TVar The state variables type( SolidObject ), intent(inout) :: BoomCase The Boom position real(kind=dp), intent(in) :: NondiT The time step and nondimensional time real(kind=dp), intent(in) :: dt The time step and nondimensional time integer(kind=it8b), intent(in) :: itt The number of iterations Contents None","tags":"","loc":"proc/coupled_ls_vof.html","title":"Coupled_LS_VOF – Fortran Program"},{"text":"private subroutine Boundary_Condition(vari) Arguments Type Intent Optional Attributes Name real(kind=dp), DIMENSION(:,:) :: vari Contents None","tags":"","loc":"proc/boundary_condition.html","title":"Boundary_Condition – Fortran Program"},{"text":"private subroutine Boundary_Condition_Vof(vari) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), DIMENSION(:,:) :: vari Contents None","tags":"","loc":"proc/boundary_condition_vof.html","title":"Boundary_Condition_Vof – Fortran Program"},{"text":"private subroutine X_Sweep(PGrid, PCell, temvf, temls, ue, ve, nx, ny, dis, dtv, itt, UpdateNorVec, NondiT, k) The subroutine compute the advection equation in x direction volume of fluid Arguments Type Intent Optional Attributes Name type(Grid) :: PGrid type(Cell) :: PCell real(kind=dp), DIMENSION(:,:), allocatable :: temvf The temporary volume of fluid and level set real(kind=dp), DIMENSION(:,:), allocatable :: temls The temporary volume of fluid and level set real(kind=dp), intent(in), DIMENSION(:,:), allocatable :: ue The velocity field real(kind=dp), intent(in), DIMENSION(:,:), allocatable :: ve The velocity field real(kind=dp), intent(inout), DIMENSION(:,:), allocatable :: nx The normal vector of interface real(kind=dp), intent(inout), DIMENSION(:,:), allocatable :: ny The normal vector of interface real(kind=dp), intent(inout), DIMENSION(:,:), allocatable :: dis The distance from cell centre to the interface real(kind=dp), intent(in) :: dtv integer(kind=it8b), intent(in) :: itt The iteration number integer(kind=it4b), intent(in) :: UpdateNorVec Option for updating the normal vector real(kind=dp), intent(in) :: NondiT integer(kind=it4b), intent(in) :: k The present sub-step. It is used for inlet boundary condition Contents None","tags":"","loc":"proc/x_sweep.html","title":"X_Sweep – Fortran Program"},{"text":"private subroutine Y_Sweep(PGrid, PCell, temvf, temls, ue, ve, nx, ny, dis, dtv, itt, UpdateNorVec) The subroutine compute the advection equation in y direction Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: PGrid type(Cell), intent(in) :: PCell real(kind=dp), DIMENSION(:,:), allocatable :: temvf real(kind=dp), DIMENSION(:,:), allocatable :: temls real(kind=dp), intent(in), DIMENSION(:,:), allocatable :: ue real(kind=dp), intent(in), DIMENSION(:,:), allocatable :: ve real(kind=dp), intent(inout), DIMENSION(:,:), allocatable :: nx real(kind=dp), intent(inout), DIMENSION(:,:), allocatable :: ny real(kind=dp), intent(inout), DIMENSION(:,:), allocatable :: dis real(kind=dp), intent(in) :: dtv integer(kind=it8b), intent(in) :: itt integer(kind=it4b), intent(in) :: UpdateNorVec Contents None","tags":"","loc":"proc/y_sweep.html","title":"Y_Sweep – Fortran Program"},{"text":"private subroutine Interface_Reconstruct(PGrid, nx, ny, dis, UpdateNorVec) The subroutine will compute the interface normal vector and distance from \n the cell center to the interface. Basically, we need all information \n about the equation of a line. Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: PGrid real(kind=dp), intent(inout), DIMENSION(:,:), allocatable :: nx real(kind=dp), intent(inout), DIMENSION(:,:), allocatable :: ny real(kind=dp), intent(inout), DIMENSION(:,:), allocatable :: dis integer(kind=it4b), intent(in) :: UpdateNorVec Contents None","tags":"","loc":"proc/interface_reconstruct.html","title":"Interface_Reconstruct – Fortran Program"},{"text":"private subroutine distance(i, j, dx, dy, nxx, nyy, diss) The subroutine will compute the distance from a point to the interface.\n It will compute based on the normal vector and volume of fluid. Arguments Type Intent Optional Attributes Name integer :: i integer :: j real(kind=dp) :: dx real(kind=dp) :: dy real(kind=dp) :: nxx real(kind=dp) :: nyy real(kind=dp) :: diss Contents None","tags":"","loc":"proc/distance.html","title":"distance – Fortran Program"},{"text":"private subroutine frac(nx, ny, diss, dx, dy, vrt) The subroutine computes the volume of fluid in a cell with height of dy \n and width of dx. Arguments Type Intent Optional Attributes Name real(kind=dp) :: nx real(kind=dp) :: ny real(kind=dp) :: diss real(kind=dp) :: dx real(kind=dp) :: dy real(kind=dp) :: vrt Contents None","tags":"","loc":"proc/frac.html","title":"frac – Fortran Program"},{"text":"private subroutine swap(a, b) Arguments Type Intent Optional Attributes Name real(kind=dp) :: a real(kind=dp) :: b Contents None","tags":"","loc":"proc/swap.html","title":"swap – Fortran Program"},{"text":"private subroutine topflux(nxx, nyy, diss, volf, nxss, nyss, phiss, vols, dx, dy, vdt, flux) The subroutine calculate flux through the top of cell Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: nxx real(kind=dp), intent(in) :: nyy real(kind=dp), intent(in) :: diss real(kind=dp), intent(in) :: volf real(kind=dp), intent(in) :: nxss real(kind=dp), intent(in) :: nyss real(kind=dp), intent(in) :: phiss real(kind=dp), intent(in) :: vols real(kind=dp), intent(in) :: dx real(kind=dp), intent(in) :: dy real(kind=dp), intent(in) :: vdt real(kind=dp), intent(out) :: flux Contents None","tags":"","loc":"proc/topflux.html","title":"topflux – Fortran Program"},{"text":"private subroutine bottomflux(nxx, nyy, diss, volf, nxss, nyss, phiss, vols, dx, dy, vdt, flux) The subroutine calculates flux through the bottom of cell Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: nxx real(kind=dp), intent(in) :: nyy real(kind=dp), intent(in) :: diss real(kind=dp), intent(in) :: volf real(kind=dp), intent(in) :: nxss real(kind=dp), intent(in) :: nyss real(kind=dp), intent(in) :: phiss real(kind=dp), intent(in) :: vols real(kind=dp), intent(in) :: dx real(kind=dp), intent(in) :: dy real(kind=dp), intent(in) :: vdt real(kind=dp), intent(out) :: flux Contents None","tags":"","loc":"proc/bottomflux.html","title":"bottomflux – Fortran Program"},{"text":"private subroutine rightflux(nxx, nyy, diss, volf, nxss, nyss, phiss, vols, dx, dy, udt, flux) The subroutine calculates flux through the right of cell Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: nxx real(kind=dp), intent(in) :: nyy real(kind=dp), intent(in) :: diss real(kind=dp), intent(in) :: volf real(kind=dp), intent(in) :: nxss real(kind=dp), intent(in) :: nyss real(kind=dp), intent(in) :: phiss real(kind=dp), intent(in) :: vols real(kind=dp), intent(in) :: dx real(kind=dp), intent(in) :: dy real(kind=dp), intent(in) :: udt real(kind=dp), intent(out) :: flux Contents None","tags":"","loc":"proc/rightflux.html","title":"rightflux – Fortran Program"},{"text":"private subroutine leftflux(nxx, nyy, diss, volf, nxss, nyss, phiss, vols, dx, dy, udt, flux) The subroutine calculates flux throught the left of cell Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: nxx real(kind=dp), intent(in) :: nyy real(kind=dp), intent(in) :: diss real(kind=dp), intent(in) :: volf real(kind=dp), intent(in) :: nxss real(kind=dp), intent(in) :: nyss real(kind=dp), intent(in) :: phiss real(kind=dp), intent(in) :: vols real(kind=dp), intent(in) :: dx real(kind=dp), intent(in) :: dy real(kind=dp), intent(in) :: udt real(kind=dp), intent(out) :: flux Contents None","tags":"","loc":"proc/leftflux.html","title":"leftflux – Fortran Program"},{"text":"private subroutine Redistance(PGrid, nxx1, nyy1, diss1) The subroutine will recompute level set from present interface configuration Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: PGrid real(kind=dp), intent(in), DIMENSION(:,:), allocatable :: nxx1 real(kind=dp), intent(in), DIMENSION(:,:), allocatable :: nyy1 real(kind=dp), intent(in), DIMENSION(:,:), allocatable :: diss1 Contents None","tags":"","loc":"proc/redistance.html","title":"Redistance – Fortran Program"},{"text":"private subroutine Normal_Vector_Irre(PGrid, i, j, nx, ny) The subroutine computes normal vector based on level set Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: PGrid integer, intent(in) :: i integer, intent(in) :: j real(kind=dp), intent(out) :: nx real(kind=dp), intent(out) :: ny Contents None","tags":"","loc":"proc/normal_vector_irre.html","title":"Normal_Vector_Irre – Fortran Program"},{"text":"private subroutine DistanceFluidCalculate(nxss, nyss, phiss, nxf, nyf, volf, dx, dy, phif) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: nxss real(kind=dp), intent(in) :: nyss real(kind=dp), intent(in) :: phiss real(kind=dp), intent(in) :: nxf real(kind=dp), intent(in) :: nyf real(kind=dp), intent(in) :: volf real(kind=dp), intent(in) :: dx real(kind=dp), intent(in) :: dy real(kind=dp), intent(inout) :: phif Contents None","tags":"","loc":"proc/distancefluidcalculate.html","title":"DistanceFluidCalculate – Fortran Program"},{"text":"private subroutine zriddr(nxf, nyf, volf, dx, dy, phif, node, x1, x2, tol, ITMAX) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: nxf real(kind=dp), intent(in) :: nyf real(kind=dp), intent(in) :: volf real(kind=dp), intent(in) :: dx real(kind=dp), intent(in) :: dy real(kind=dp), intent(inout) :: phif real(kind=dp), intent(in) :: node (6,2) real(kind=dp), intent(in) :: x1 (2) real(kind=dp), intent(in) :: x2 (2) real(kind=dp), intent(in) :: tol integer(kind=it4b), intent(in) :: ITMAX Contents None","tags":"","loc":"proc/zriddr.html","title":"zriddr – Fortran Program"},{"text":"private subroutine LiqFuncVol(nxf, nyf, volf, dx, dy, node, xf, fvol) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: nxf real(kind=dp), intent(in) :: nyf real(kind=dp), intent(in) :: volf real(kind=dp), intent(in) :: dx real(kind=dp), intent(in) :: dy real(kind=dp), intent(in) :: node (6,2) real(kind=dp), intent(in) :: xf (2) real(kind=dp) :: fvol Contents None","tags":"","loc":"proc/liqfuncvol.html","title":"LiqFuncVol – Fortran Program"},{"text":"private subroutine CellGeoCal(nxs, nys, phis, nxl, nyl, phil, dx, dy, vols, volf) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: nxs real(kind=dp), intent(in) :: nys real(kind=dp), intent(in) :: phis real(kind=dp), intent(in) :: nxl real(kind=dp), intent(in) :: nyl real(kind=dp), intent(in) :: phil real(kind=dp), intent(in) :: dx real(kind=dp), intent(in) :: dy real(kind=dp), intent(out) :: vols real(kind=dp), intent(out) :: volf Contents None","tags":"","loc":"proc/cellgeocal.html","title":"CellGeoCal – Fortran Program"},{"text":"private subroutine Boundary_Condition_Vof_Phi(TGrid, Time) The subroutine computes the volume fraction and the level set at \n the inlet and outlet boundary. The subroutine will be applied for \n the sinusoidal wave. Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: TGrid real(kind=dp), intent(in) :: Time Contents None","tags":"","loc":"proc/boundary_condition_vof_phi.html","title":"Boundary_Condition_Vof_Phi – Fortran Program"},{"text":"private subroutine ObjectMovement(BoomCase, dtv) The subroutine compute the Boom position and its velocity Arguments Type Intent Optional Attributes Name type( SolidObject ), intent(inout) :: BoomCase real(kind=dp), intent(in) :: dtv Contents None","tags":"","loc":"proc/objectmovement.html","title":"ObjectMovement – Fortran Program"},{"text":"public subroutine ComputeForceObject(BoomCase, PGrid, PCell, VCell, TVar, ForceObj) The subroutine calculates the force acting on object Arguments Type Intent Optional Attributes Name type( SolidObject ), intent(inout) :: BoomCase type(Grid), intent(in) :: PGrid type(Cell), intent(in) :: PCell type(Cell), intent(in) :: VCell type(Variables), intent(in) :: TVar real(kind=dp), intent(out) :: ForceObj Contents None","tags":"","loc":"proc/computeforceobject.html","title":"ComputeForceObject – Fortran Program"},{"text":"public subroutine SolidVolumeFraction(TGrid, TCell, BoomCase) The subroutine computes solid volume fraction in the next sub-steps Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: TGrid type(Cell), intent(inout) :: TCell type( SolidObject ), intent(in) :: BoomCase Contents None","tags":"","loc":"proc/solidvolumefraction.html","title":"SolidVolumeFraction – Fortran Program"},{"text":"private subroutine EdgeGeoCalCyl(BoomCase, Pt1, Pt2, CutP, ctr) The subroutine calculates the intersection between the interface and \n the cell edges in the case of cylinder. Arguments Type Intent Optional Attributes Name type( SolidObject ), intent(in) :: BoomCase type(point), intent(in) :: Pt1 type(point), intent(in) :: Pt2 type(point), intent(inout), DIMENSION(4) :: CutP integer(kind=it4b), intent(inout) :: ctr Contents None","tags":"","loc":"proc/edgegeocalcyl.html","title":"EdgeGeoCalCyl – Fortran Program"},{"text":"private interface Initial_Clsvof Contents Module Procedures Initial_Clsvof Module Procedures private interface Initial_Clsvof () Arguments None","tags":"","loc":"interface/initial_clsvof.html","title":"Initial_Clsvof – Fortran Program"},{"text":"private interface Initial_ClsvofUV Contents Module Procedures Initial_ClsvofUV Module Procedures private interface Initial_ClsvofUV () Arguments None","tags":"","loc":"interface/initial_clsvofuv.html","title":"Initial_ClsvofUV – Fortran Program"},{"text":"private interface Coupled_LS_VOF Contents Module Procedures Coupled_LS_VOF Module Procedures private interface Coupled_LS_VOF () Arguments None","tags":"","loc":"interface/coupled_ls_vof.html","title":"Coupled_LS_VOF – Fortran Program"},{"text":"private interface ComputeForceObject Contents Module Procedures ComputeForceObject Module Procedures private interface ComputeForceObject () Arguments None","tags":"","loc":"interface/computeforceobject.html","title":"ComputeForceObject – Fortran Program"},{"text":"private interface SolidVolumeFraction Contents Module Procedures SolidVolumeFraction Module Procedures private interface SolidVolumeFraction () Arguments None","tags":"","loc":"interface/solidvolumefraction.html","title":"SolidVolumeFraction – Fortran Program"},{"text":"public subroutine Initial_Var(PCell, PGrid, Vari, Uint, Vint, Pint, Tint, Uref, Tref, Roref, Lref) Arguments Type Intent Optional Attributes Name type(Cell), intent(in) :: PCell type(Grid), intent(in) :: PGrid type( Variables ), intent(inout) :: Vari real(kind=dp), intent(in) :: Uint real(kind=dp), intent(in) :: Vint real(kind=dp), intent(in) :: Pint real(kind=dp), intent(in) :: Tint real(kind=dp), intent(in) :: Uref real(kind=dp), intent(in) :: Tref real(kind=dp), intent(in) :: Roref real(kind=dp), intent(in) :: Lref Contents None","tags":"","loc":"proc/initial_var.html","title":"Initial_Var – Fortran Program"},{"text":"public subroutine Boundary_Condition_Var(PGrid, PCell, Vari, Time) Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: PGrid type(Cell), intent(in) :: PCell type( Variables ), intent(inout) :: Vari real(kind=dp), intent(in) :: Time Contents None","tags":"","loc":"proc/boundary_condition_var.html","title":"Boundary_Condition_Var – Fortran Program"},{"text":"private interface Initial_Var Contents Module Procedures Initial_Var Module Procedures private interface Initial_Var () Arguments None","tags":"","loc":"interface/initial_var.html","title":"Initial_Var – Fortran Program"},{"text":"private interface Boundary_Condition_Var Contents Module Procedures Boundary_Condition_Var Module Procedures private interface Boundary_Condition_Var () Arguments None","tags":"","loc":"interface/boundary_condition_var.html","title":"Boundary_Condition_Var – Fortran Program"},{"text":"private function MUSCLLimiter(x, opt, tolim) result(y) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x integer(kind=it4b), intent(in) :: opt real(kind=dp), intent(in) :: tolim Return Value real(kind=dp) Contents None","tags":"","loc":"proc/muscllimiter.html","title":"MUSCLLimiter – Fortran Program"},{"text":"public subroutine Predictor_UV(PGrid, UGrid, VGrid, PCellO, UCellO, VCellO, PCell, UCell, VCell, TVar, PU, PV, Pred, Flux_n1, TraPar, BoomCase, dt, itt) The subroutine is the predictor step for velocities Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: PGrid The grid type(Grid), intent(in) :: UGrid The grid type(Grid), intent(in) :: VGrid The grid type(Cell), intent(in) :: PCellO The pressure cell at current time step (n) type(Cell), intent(in), target :: UCellO The velocities cell at next time step (n) type(Cell), intent(in), target :: VCellO The velocities cell at next time step (n) type(Cell), intent(in) :: PCell The pressure cell at next time step (n+1) type(Cell), intent(in), target :: UCell The velocities cell at next time step (n+1) type(Cell), intent(in), target :: VCell The velocities cell at next time step (n+1) type(Variables), intent(in), target :: TVar The state variables type( PoissonCoefficient ), intent(inout) :: PU The cofficient for solving Poisson equation type( PoissonCoefficient ), intent(inout) :: PV The cofficient for solving Poisson equation type( Predictor ), intent(inout) :: Pred The predictor velocity real(kind=dp), intent(inout), DIMENSION(:,:,:), allocatable :: Flux_n1 The total flux from the previous time step type(Particle), intent(inout) :: TraPar The particles information type(SolidObject), intent(in) :: BoomCase The Boom real(kind=dp), intent(in) :: dt The time step integer(kind=it8b), intent(in) :: itt The iterations number Contents None","tags":"","loc":"proc/predictor_uv.html","title":"Predictor_UV – Fortran Program"},{"text":"private subroutine SetBasicSolver(solver, precond) The subroutine set up methods for HYPRE solver Arguments Type Intent Optional Attributes Name integer(kind=8), intent(inout) :: solver integer(kind=8), intent(inout), optional :: precond Contents None","tags":"","loc":"proc/setbasicsolver.html","title":"SetBasicSolver – Fortran Program"},{"text":"private subroutine SetMatrix(A, parcsr_A, TGrid, TCell, DifFluxEW, DifFluxNS, EDFluxEW, EDFluxNS, PUV, CWE, CSN, matr, itt, dt, iu, iv) The subroutine set up the matrix for HYPRE Arguments Type Intent Optional Attributes Name integer(kind=8), intent(inout) :: A An ID for matrix integer(kind=8), intent(inout) :: parcsr_A An ID for matrix type(Grid), intent(in) :: TGrid The grid type(Cell), intent(in) :: TCell The cell real(kind=dp), intent(in), DIMENSION(:,:,:), allocatable :: DifFluxEW The diffusive flux coefficient real(kind=dp), intent(in), DIMENSION(:,:,:), allocatable :: DifFluxNS The diffusive flux coefficient real(kind=dp), intent(in), DIMENSION(:,:,:), allocatable :: EDFluxEW The diffusive flux coefficient real(kind=dp), intent(in), DIMENSION(:,:,:), allocatable :: EDFluxNS The diffusive flux coefficient type( PoissonCoefficient ), intent(inout) :: PUV The cofficient from predicted step real(kind=dp), intent(inout), DIMENSION(:,:), allocatable :: CWE The boundary condition real(kind=dp), intent(inout), DIMENSION(:,:), allocatable :: CSN The boundary condition real(kind=dp), intent(inout), DIMENSION(:,:,:), allocatable :: matr The matrix for testing solver integer(kind=it8b), intent(in) :: itt The iteration step real(kind=dp), intent(in) :: dt The time step integer, intent(in) :: iu The input number to determine this subroutine is applied for x or y direction integer, intent(in) :: iv The input number to determine this subroutine is applied for x or y direction Contents None","tags":"","loc":"proc/setmatrix.html","title":"SetMatrix – Fortran Program"},{"text":"private subroutine SetVectors(b, x, par_b, par_x, PGrid, TGrid, TCell, CWE, CSN, IJFlux, rhm, dt, iu, iv) The subroutine set up a right hand side vector for HYPRE solver Arguments Type Intent Optional Attributes Name integer(kind=8), intent(in) :: b The ID for vector integer(kind=8), intent(in) :: x The ID for vector integer(kind=8), intent(in) :: par_b The ID for vector integer(kind=8), intent(in) :: par_x The ID for vector type(Grid), intent(in) :: PGrid The grid type(Grid), intent(in) :: TGrid The grid type(Cell), intent(in) :: TCell The cell real(kind=dp), intent(in), DIMENSION(:,:), allocatable :: CWE The boundary condition real(kind=dp), intent(in), DIMENSION(:,:), allocatable :: CSN The boundary condition real(kind=dp), intent(in), DIMENSION(:,:) :: IJFlux The total flux which is set to be right hand side vector real(kind=dp), intent(inout), DIMENSION(:,:) :: rhm The output right hand side vector which is used for checking solver real(kind=dp), intent(in) :: dt The time step integer, intent(in) :: iu The input number to determine this subroutine is applied for x or y direction integer, intent(in) :: iv The input number to determine this subroutine is applied for x or y direction Contents None","tags":"","loc":"proc/setvectors.html","title":"SetVectors – Fortran Program"},{"text":"private subroutine DeltaGetValues(x, TCell, Var, iu, iv) The subroutine get the result for HYPRE Arguments Type Intent Optional Attributes Name integer(kind=8), intent(in) :: x The ID for result vector type(Cell), intent(in) :: TCell The cell real(kind=dp), intent(inout), DIMENSION(:,:), allocatable :: Var The output variable integer, intent(in) :: iu The input number to determine this subroutine is applied for x or y direction integer, intent(in) :: iv The input number to determine this subroutine is applied for x or y direction Contents None","tags":"","loc":"proc/deltagetvalues.html","title":"DeltaGetValues – Fortran Program"},{"text":"private subroutine ModifiedConvectiveFlux(PGrid, UGrid, VGrid, PCell, UCell, VCell, flux, vb, idir, jdir) The subroutine computes the convective flux through velocity cell faces. \n The method is first order upwind for whole computational domain except \n the boundary cells, where, central scheme is applied. Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: PGrid The grid type(Grid), intent(in) :: UGrid The grid type(Grid), intent(in) :: VGrid The grid type(Cell), intent(in) :: PCell The cell type(Cell), intent(in) :: UCell The cell type(Cell), intent(in) :: VCell The cell real(kind=dp), intent(inout), DIMENSION(:,:,:), allocatable :: flux The output convective flux real(kind=dp), intent(in) :: vb The boundary velocity integer(kind=it4b), intent(in) :: idir The parameter indicating the subroutine applied for x or y direction integer(kind=it4b), intent(in) :: jdir The parameter indicating the subroutine applied for x or y direction Contents None","tags":"","loc":"proc/modifiedconvectiveflux.html","title":"ModifiedConvectiveFlux – Fortran Program"},{"text":"private subroutine HighOrderConvectiveFluxForXDir(PGrid, UGrid, VGrid, UCell, VCell, vb, flux) The subroutine used the MUSCL scheme for computing the covective flux \n in x direction. It is applied for both u and v. The work is based on 'A MUSCL scheme on staggered grids with kinetic-like fluxes\n for the barotropic Euler system', Thierry Goundon, Julie Llobell Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: PGrid The grid type(Grid), intent(in) :: UGrid The grid type(Grid), intent(in) :: VGrid The grid type(Cell), intent(in) :: UCell The cell type(Cell), intent(in) :: VCell The cell real(kind=dp), intent(in) :: vb The boundary velocity real(kind=dp), intent(inout), DIMENSION(:,:,:), allocatable :: flux The output convective flux Contents None","tags":"","loc":"proc/highorderconvectivefluxforxdir.html","title":"HighOrderConvectiveFluxForXDir – Fortran Program"},{"text":"private subroutine HighOrderConvectiveFluxForYDir(PGrid, UGrid, VGrid, UCell, VCell, vb, flux) The subroutine used the MUSCL scheme for computing the covective flux \n in y direction. It is applied for both u and v. Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: PGrid The grid type(Grid), intent(in) :: UGrid The grid type(Grid), intent(in) :: VGrid The grid type(Cell), intent(in) :: UCell The cell type(Cell), intent(in) :: VCell The cell real(kind=dp), intent(in) :: vb The boundary velocity real(kind=dp), intent(inout), DIMENSION(:,:,:), allocatable :: flux The output convective flux Contents None","tags":"","loc":"proc/highorderconvectivefluxforydir.html","title":"HighOrderConvectiveFluxForYDir – Fortran Program"},{"text":"private subroutine FaceDensityFlux(PGrid, UGrid, VGrid, PCell, UCell, VCell, flux, VFlux, vb, dt, idir, jdir) The subroutine compute the mass flux through cell face. \n It also determine the mixture density at cell faces, which is used for computing\n the convective fluxes. Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: PGrid The grid type(Grid), intent(in) :: UGrid The grid type(Grid), intent(in) :: VGrid The grid type(Cell), intent(in) :: PCell The cell type(Cell), intent(in) :: UCell The cell type(Cell), intent(in) :: VCell The cell real(kind=dp), intent(inout), DIMENSION(:,:,:), allocatable :: flux The mass flux real(kind=dp), intent(inout), DIMENSION(:,:,:), allocatable :: VFlux The mixture density at cell faces real(kind=dp), intent(in) :: vb The boundary velocity real(kind=dp), intent(in) :: dt The time step integer(kind=it4b), intent(in) :: idir The parameter indicating the subroutine applied for x or y direction integer(kind=it4b), intent(in) :: jdir The parameter indicating the subroutine applied for x or y direction Contents None","tags":"","loc":"proc/facedensityflux.html","title":"FaceDensityFlux – Fortran Program"},{"text":"private subroutine DensityBasedConvectiveFlux(PGrid, UGrid, VGrid, PCell, UCell, VCell, flux, Vflux, vb, idir, jdir) The subroutine computes convective fluxes through cell faces. Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: PGrid The grid type(Grid), intent(in) :: UGrid The grid type(Grid), intent(in) :: VGrid The grid type(Cell), intent(in) :: PCell The cell type(Cell), intent(in) :: UCell The cell type(Cell), intent(in) :: VCell The cell real(kind=dp), intent(inout), DIMENSION(:,:,:), allocatable :: flux The convective flux real(kind=dp), intent(in), DIMENSION(:,:,:), allocatable :: Vflux The mixture density at cell faces real(kind=dp), intent(in) :: vb The boundary velocity integer(kind=it4b), intent(in) :: idir The parameter indicating the subroutine applied for x or y direction integer(kind=it4b), intent(in) :: jdir The parameter indicating the subroutine applied for x or y direction Contents None","tags":"","loc":"proc/densitybasedconvectiveflux.html","title":"DensityBasedConvectiveFlux – Fortran Program"},{"text":"private subroutine DiffusiveFlux(PGrid, UGrid, VGrid, PCell, UCell, VCell, flux, Eflux, ExEFlux, vb, idir, jdir) The subroutine computes the diffusive fluxes and extra correction for diffusive fluxes Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: PGrid The grid type(Grid), intent(in) :: UGrid The grid type(Grid), intent(in) :: VGrid The grid type(Cell), intent(in) :: PCell The cell type(Cell), intent(in) :: UCell The cell type(Cell), intent(in) :: VCell The cell real(kind=dp), intent(inout), DIMENSION(:,:,:), allocatable :: flux The diffusive flux real(kind=dp), intent(inout), DIMENSION(:,:,:), allocatable :: Eflux The extra diffusive flux coefficient real(kind=dp), intent(inout), DIMENSION(:,:,:), allocatable :: ExEFlux The extra diffusive flux which involve boundary velocity real(kind=dp), intent(in) :: vb The boundary velocity integer(kind=it4b), intent(in) :: idir The parameter indicating the subroutine applied for x or y direction integer(kind=it4b), intent(in) :: jdir The parameter indicating the subroutine applied for x or y direction Contents None","tags":"","loc":"proc/diffusiveflux.html","title":"DiffusiveFlux – Fortran Program"},{"text":"private subroutine Mixing_Procedure(TGrid, TCell, idir, jdir, flux_mix) The subroutine compute the total flux and redistribute it such that the \n resulted flux doesn't cause any problems to small cell. Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: TGrid The grid type(Cell), intent(in) :: TCell The cell integer(kind=it4b), intent(in) :: idir The parameter indicating the subroutine applied for x or y direction integer(kind=it4b), intent(in) :: jdir The parameter indicating the subroutine applied for x or y direction real(kind=dp), intent(inout), DIMENSION(:,:) :: flux_mix The total flux Contents None","tags":"","loc":"proc/mixing_procedure.html","title":"Mixing_Procedure – Fortran Program"},{"text":"private subroutine PredictorVelocityBoundaryCondition(Pred, TVar) Arguments Type Intent Optional Attributes Name type( Predictor ), intent(inout) :: Pred type(Variables), intent(in) :: TVar Contents None","tags":"","loc":"proc/predictorvelocityboundarycondition.html","title":"PredictorVelocityBoundaryCondition – Fortran Program"},{"text":"private subroutine frac(nx, ny, diss, dx, dy, vrt) Arguments Type Intent Optional Attributes Name real(kind=dp) :: nx real(kind=dp) :: ny real(kind=dp) :: diss real(kind=dp) :: dx real(kind=dp) :: dy real(kind=dp) :: vrt Contents None","tags":"","loc":"proc/frac~2.html","title":"frac – Fortran Program"},{"text":"private subroutine CellGeoCal(nxs, nys, phis, nxl, nyl, phil, dx, dy, vols, volf) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: nxs real(kind=dp), intent(in) :: nys real(kind=dp), intent(in) :: phis real(kind=dp), intent(in) :: nxl real(kind=dp), intent(in) :: nyl real(kind=dp), intent(in) :: phil real(kind=dp), intent(in) :: dx real(kind=dp), intent(in) :: dy real(kind=dp), intent(out) :: vols real(kind=dp), intent(out) :: volf Contents None","tags":"","loc":"proc/cellgeocal~2.html","title":"CellGeoCal – Fortran Program"},{"text":"private interface Predictor_UV Contents Module Procedures Predictor_UV Module Procedures private interface Predictor_UV () Arguments None","tags":"","loc":"interface/predictor_uv.html","title":"Predictor_UV – Fortran Program"},{"text":"public function sech(x) result(y) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x Return Value real(kind=dp) Contents None","tags":"","loc":"proc/sech.html","title":"sech – Fortran Program"},{"text":"public function dsech(x) result(y) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x Return Value real(kind=dp) Contents None","tags":"","loc":"proc/dsech.html","title":"dsech – Fortran Program"},{"text":"public subroutine inverse(a, c, n) Arguments Type Intent Optional Attributes Name real(kind=dp) :: a (n,n) real(kind=dp) :: c (n,n) integer :: n Contents None","tags":"","loc":"proc/inverse.html","title":"inverse – Fortran Program"},{"text":"public subroutine Matrixinv(a, b, n) Arguments Type Intent Optional Attributes Name double precision :: a (n,n) double precision :: b (n,n) integer :: n Contents None","tags":"","loc":"proc/matrixinv.html","title":"Matrixinv – Fortran Program"},{"text":"public subroutine MPI_Initial() Arguments None Contents None","tags":"","loc":"proc/mpi_initial.html","title":"MPI_Initial – Fortran Program"},{"text":"private subroutine handle_error(name, message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name character(len=*), intent(in) :: message Contents None","tags":"","loc":"proc/handle_error~2.html","title":"handle_error – Fortran Program"},{"text":"private subroutine handle_warning(name, message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name character(len=*), intent(in) :: message Contents None","tags":"","loc":"proc/handle_warning~2.html","title":"handle_warning – Fortran Program"},{"text":"private subroutine handle_info(name, message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name character(len=*), intent(in) :: message Contents None","tags":"","loc":"proc/handle_info~2.html","title":"handle_info – Fortran Program"},{"text":"public subroutine VTR_open_file(prefix, proc_rank, num_procs, restart, itera, fd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: prefix integer, intent(in), optional :: proc_rank integer, intent(in), optional :: num_procs integer, intent(in), optional :: restart integer(kind=it8b), intent(in), optional :: itera type( VTR_file_handle ), intent(inout) :: fd Contents None","tags":"","loc":"proc/vtr_open_file.html","title":"VTR_open_file – Fortran Program"},{"text":"private subroutine VTR_write_mesh_2d(fd, x, y) Arguments Type Intent Optional Attributes Name type( VTR_file_handle ), intent(inout) :: fd real(kind=dp), intent(in), DIMENSION(:) :: x real(kind=dp), intent(in), DIMENSION(:) :: y Contents None","tags":"","loc":"proc/vtr_write_mesh_2d.html","title":"VTR_write_mesh_2d – Fortran Program"},{"text":"private subroutine VTR_write_mesh_3d(fd, x, y, z) Arguments Type Intent Optional Attributes Name type( VTR_file_handle ), intent(inout) :: fd real(kind=dp), intent(in), DIMENSION(:) :: x real(kind=dp), intent(in), DIMENSION(:) :: y real(kind=dp), intent(in), DIMENSION(:) :: z Contents None","tags":"","loc":"proc/vtr_write_mesh_3d.html","title":"VTR_write_mesh_3d – Fortran Program"},{"text":"private subroutine VTR_write_vector_2d(fd, name, vx, vy) Arguments Type Intent Optional Attributes Name type( VTR_file_handle ), intent(in) :: fd character(len=*), intent(in) :: name real(kind=dp), intent(in), DIMENSION(:,:) :: vx real(kind=dp), intent(in), DIMENSION(:,:) :: vy Contents None","tags":"","loc":"proc/vtr_write_vector_2d.html","title":"VTR_write_vector_2d – Fortran Program"},{"text":"private subroutine VTR_write_vector_3d(fd, name, vx, vy, vz) Arguments Type Intent Optional Attributes Name type( VTR_file_handle ), intent(in) :: fd character(len=*), intent(in) :: name real(kind=dp), intent(in), DIMENSION(:,:,:) :: vx real(kind=dp), intent(in), DIMENSION(:,:,:) :: vy real(kind=dp), intent(in), DIMENSION(:,:,:) :: vz Contents None","tags":"","loc":"proc/vtr_write_vector_3d.html","title":"VTR_write_vector_3d – Fortran Program"},{"text":"private subroutine VTR_write_scalar_2d(fd, name, field) Arguments Type Intent Optional Attributes Name type( VTR_file_handle ), intent(in) :: fd character(len=*), intent(in) :: name real(kind=dp), intent(in), DIMENSION(:,:) :: field Contents None","tags":"","loc":"proc/vtr_write_scalar_2d.html","title":"VTR_write_scalar_2d – Fortran Program"},{"text":"private subroutine VTR_write_scalar_3d(fd, name, field) Arguments Type Intent Optional Attributes Name type( VTR_file_handle ), intent(in) :: fd character(len=*), intent(in) :: name real(kind=dp), intent(in), DIMENSION(:,:,:) :: field Contents None","tags":"","loc":"proc/vtr_write_scalar_3d.html","title":"VTR_write_scalar_3d – Fortran Program"},{"text":"public subroutine VTR_close_file(fd) Arguments Type Intent Optional Attributes Name type( VTR_file_handle ), intent(inout) :: fd Contents None","tags":"","loc":"proc/vtr_close_file.html","title":"VTR_close_file – Fortran Program"},{"text":"public subroutine VTR_collect_file(fd) Arguments Type Intent Optional Attributes Name type( VTR_file_handle ), intent(inout) :: fd Contents None","tags":"","loc":"proc/vtr_collect_file.html","title":"VTR_collect_file – Fortran Program"},{"text":"public interface VTR_write_mesh Contents Module Procedures VTR_write_mesh_2d VTR_write_mesh_3d Module Procedures private subroutine VTR_write_mesh_2d (fd, x, y) Arguments Type Intent Optional Attributes Name type( VTR_file_handle ), intent(inout) :: fd real(kind=dp), intent(in), DIMENSION(:) :: x real(kind=dp), intent(in), DIMENSION(:) :: y private subroutine VTR_write_mesh_3d (fd, x, y, z) Arguments Type Intent Optional Attributes Name type( VTR_file_handle ), intent(inout) :: fd real(kind=dp), intent(in), DIMENSION(:) :: x real(kind=dp), intent(in), DIMENSION(:) :: y real(kind=dp), intent(in), DIMENSION(:) :: z","tags":"","loc":"interface/vtr_write_mesh.html","title":"VTR_write_mesh – Fortran Program"},{"text":"public interface VTR_write_var Contents Module Procedures VTR_write_scalar_2d VTR_write_scalar_3d VTR_write_vector_2d VTR_write_vector_3d Module Procedures private subroutine VTR_write_scalar_2d (fd, name, field) Arguments Type Intent Optional Attributes Name type( VTR_file_handle ), intent(in) :: fd character(len=*), intent(in) :: name real(kind=dp), intent(in), DIMENSION(:,:) :: field private subroutine VTR_write_scalar_3d (fd, name, field) Arguments Type Intent Optional Attributes Name type( VTR_file_handle ), intent(in) :: fd character(len=*), intent(in) :: name real(kind=dp), intent(in), DIMENSION(:,:,:) :: field private subroutine VTR_write_vector_2d (fd, name, vx, vy) Arguments Type Intent Optional Attributes Name type( VTR_file_handle ), intent(in) :: fd character(len=*), intent(in) :: name real(kind=dp), intent(in), DIMENSION(:,:) :: vx real(kind=dp), intent(in), DIMENSION(:,:) :: vy private subroutine VTR_write_vector_3d (fd, name, vx, vy, vz) Arguments Type Intent Optional Attributes Name type( VTR_file_handle ), intent(in) :: fd character(len=*), intent(in) :: name real(kind=dp), intent(in), DIMENSION(:,:,:) :: vx real(kind=dp), intent(in), DIMENSION(:,:,:) :: vy real(kind=dp), intent(in), DIMENSION(:,:,:) :: vz","tags":"","loc":"interface/vtr_write_var.html","title":"VTR_write_var – Fortran Program"},{"text":"public subroutine Print_Result_Tecplot_PCent(TGrid, TVar, TCell, TraPar, FluxP, iter, PriPar) Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: TGrid type( Variables ), intent(inout) :: TVar type(Cell), intent(in) :: TCell type(Particle), intent(in) :: TraPar real(kind=dp), intent(in), DIMENSION(:,:,:), ALLOCATABLE :: FluxP integer(kind=it8b), intent(in) :: iter integer(kind=it4b), intent(in) :: PriPar Contents None","tags":"","loc":"proc/print_result_tecplot_pcent.html","title":"Print_Result_Tecplot_PCent – Fortran Program"},{"text":"public subroutine Print_Result_Tecplot_UCent(TGrid, TVar, TCell, itt) Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: TGrid type( Variables ), intent(in) :: TVar type(Cell), intent(in) :: TCell integer(kind=it8b), intent(in) :: itt Contents None","tags":"","loc":"proc/print_result_tecplot_ucent.html","title":"Print_Result_Tecplot_UCent – Fortran Program"},{"text":"public subroutine Print_Result_Tecplot_VCent(TGrid, TVar, TCell, itt) Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: TGrid type( Variables ), intent(in) :: TVar type(Cell), intent(in) :: TCell integer(kind=it8b), intent(in) :: itt Contents None","tags":"","loc":"proc/print_result_tecplot_vcent.html","title":"Print_Result_Tecplot_VCent – Fortran Program"},{"text":"public subroutine Print_Result_VTK_2D(TGrid, TVar, TCell, itt) Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: TGrid type( Variables ), intent(in) :: TVar type(Cell), intent(in) :: TCell integer(kind=it8b), intent(in) :: itt Contents None","tags":"","loc":"proc/print_result_vtk_2d.html","title":"Print_Result_VTK_2D – Fortran Program"},{"text":"public subroutine ReadOldDataPCell(filename, TCell, TVar, FluxP) Arguments Type Intent Optional Attributes Name character(len=80), intent(in) :: filename type(Cell), intent(inout) :: TCell type( Variables ), intent(inout) :: TVar real(kind=dp), intent(inout), DIMENSION(:,:,:), ALLOCATABLE :: FluxP Contents None","tags":"","loc":"proc/readolddatapcell.html","title":"ReadOldDataPCell – Fortran Program"},{"text":"public subroutine ReadOldDataVelocityCell(filename, TCell, UVVel) Arguments Type Intent Optional Attributes Name character(len=80), intent(in) :: filename type(Cell), intent(inout) :: TCell real(kind=dp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: UVVel Contents None","tags":"","loc":"proc/readolddatavelocitycell.html","title":"ReadOldDataVelocityCell – Fortran Program"},{"text":"public subroutine ReadOldDataParticle(filename, TraPar, TVar) Arguments Type Intent Optional Attributes Name character(len=80), intent(in) :: filename type(Particle), intent(inout) :: TraPar type( Variables ) :: TVar Contents None","tags":"","loc":"proc/readolddataparticle.html","title":"ReadOldDataParticle – Fortran Program"},{"text":"private interface Print_Result_Tecplot_PCent Contents Module Procedures Print_Result_Tecplot_PCent Module Procedures private interface Print_Result_Tecplot_PCent () Arguments None","tags":"","loc":"interface/print_result_tecplot_pcent.html","title":"Print_Result_Tecplot_PCent – Fortran Program"},{"text":"private interface Print_Result_Tecplot_UCent Contents Module Procedures Print_Result_Tecplot_UCent Module Procedures private interface Print_Result_Tecplot_UCent () Arguments None","tags":"","loc":"interface/print_result_tecplot_ucent.html","title":"Print_Result_Tecplot_UCent – Fortran Program"},{"text":"private interface Print_Result_Tecplot_VCent Contents Module Procedures Print_Result_Tecplot_VCent Module Procedures private interface Print_Result_Tecplot_VCent () Arguments None","tags":"","loc":"interface/print_result_tecplot_vcent.html","title":"Print_Result_Tecplot_VCent – Fortran Program"},{"text":"private interface Print_Result_VTK_2D Contents Module Procedures Print_Result_VTK_2D Module Procedures private interface Print_Result_VTK_2D () Arguments None","tags":"","loc":"interface/print_result_vtk_2d.html","title":"Print_Result_VTK_2D – Fortran Program"},{"text":"private interface ReadOldDataPCell Contents Module Procedures ReadOldDataPCell Module Procedures private interface ReadOldDataPCell () Arguments None","tags":"","loc":"interface/readolddatapcell.html","title":"ReadOldDataPCell – Fortran Program"},{"text":"private interface ReadOldDataVelocityCell Contents Module Procedures ReadOldDataVelocityCell Module Procedures private interface ReadOldDataVelocityCell () Arguments None","tags":"","loc":"interface/readolddatavelocitycell.html","title":"ReadOldDataVelocityCell – Fortran Program"},{"text":"private interface ReadOldDataParticle Contents Module Procedures ReadOldDataParticle Module Procedures private interface ReadOldDataParticle () Arguments None","tags":"","loc":"interface/readolddataparticle.html","title":"ReadOldDataParticle – Fortran Program"},{"text":"public subroutine PoissonEquationSolver(PGrid, UGrid, VGrid, PCellO, PCell, UCell, VCell, TVar, TPred, PU, PV, Proj, vb, dt, itt) Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: PGrid type(Grid), intent(in) :: UGrid type(Grid), intent(in) :: VGrid type(Cell), intent(in) :: PCellO type(Cell), intent(in) :: PCell type(Cell), intent(in) :: UCell type(Cell), intent(in) :: VCell type(Variables), intent(in), target :: TVar type(Predictor), intent(in), target :: TPred type(PoissonCoefficient), intent(in) :: PU type(PoissonCoefficient), intent(in) :: PV type( Projection ), intent(inout), target :: Proj real(kind=dp), intent(in) :: vb real(kind=dp), intent(in) :: dt integer(kind=it8b), intent(in) :: itt Contents None","tags":"","loc":"proc/poissonequationsolver.html","title":"PoissonEquationSolver – Fortran Program"},{"text":"private subroutine SetBasicSolver(solver, precond) Arguments Type Intent Optional Attributes Name integer(kind=8), intent(inout) :: solver integer(kind=8), intent(inout), optional :: precond Contents None","tags":"","loc":"proc/setbasicsolver~2.html","title":"SetBasicSolver – Fortran Program"},{"text":"private subroutine SetPoissonMatrix(A, parcsr_A, PGrid, PCell, WB, EB, SB, NB, matr, itt) Arguments Type Intent Optional Attributes Name integer(kind=8), intent(inout) :: A integer(kind=8), intent(inout) :: parcsr_A type(Grid), intent(in) :: PGrid type(Cell), intent(in) :: PCell integer(kind=it4b), intent(in) :: WB integer(kind=it4b), intent(in) :: EB integer(kind=it4b), intent(in) :: SB integer(kind=it4b), intent(in) :: NB real(kind=dp), DIMENSION(:,:,:), allocatable :: matr integer(kind=it8b), intent(in) :: itt Contents None","tags":"","loc":"proc/setpoissonmatrix.html","title":"SetPoissonMatrix – Fortran Program"},{"text":"private subroutine SetPoissonVectors(b, x, par_b, par_x, PGrid, PCellO, PCell, vb, dt, rhm, itt) Arguments Type Intent Optional Attributes Name integer(kind=8) :: b integer(kind=8) :: x integer(kind=8) :: par_b integer(kind=8) :: par_x type(Grid), intent(in) :: PGrid type(Cell), intent(in) :: PCellO type(Cell), intent(in) :: PCell real(kind=dp), intent(in) :: vb real(kind=dp), intent(in) :: dt real(kind=dp), DIMENSION(:,:), allocatable :: rhm integer(kind=it8b), intent(in) :: itt Contents None","tags":"","loc":"proc/setpoissonvectors.html","title":"SetPoissonVectors – Fortran Program"},{"text":"private subroutine DeltaPressureGetValues(x, PCell, Projp) Arguments Type Intent Optional Attributes Name integer(kind=8), intent(in) :: x type(Cell), intent(in) :: PCell type( Projection ), intent(inout) :: Projp Contents None","tags":"","loc":"proc/deltapressuregetvalues.html","title":"DeltaPressureGetValues – Fortran Program"},{"text":"private subroutine ComputePossionMatrixCoefficient(PGrid, UGrid, VGrid, PCell, UCell, VCell, PU, PV) Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: PGrid type(Grid), intent(in) :: UGrid type(Grid), intent(in) :: VGrid type(Cell), intent(in) :: PCell type(Cell), intent(in) :: UCell type(Cell), intent(in) :: VCell type(PoissonCoefficient), intent(in) :: PU type(PoissonCoefficient), intent(in) :: PV Contents None","tags":"","loc":"proc/computepossionmatrixcoefficient.html","title":"ComputePossionMatrixCoefficient – Fortran Program"},{"text":"private subroutine DeltaPressureBoundaryCondition(Proj, WB, EB, SB, NB) Arguments Type Intent Optional Attributes Name type( Projection ), intent(inout) :: Proj integer(kind=it4b), intent(in) :: WB integer(kind=it4b), intent(in) :: EB integer(kind=it4b), intent(in) :: SB integer(kind=it4b), intent(in) :: NB Contents None","tags":"","loc":"proc/deltapressureboundarycondition.html","title":"DeltaPressureBoundaryCondition – Fortran Program"},{"text":"private interface PoissonEquationSolver Contents Module Procedures PoissonEquationSolver Module Procedures private interface PoissonEquationSolver () Arguments None","tags":"","loc":"interface/poissonequationsolver.html","title":"PoissonEquationSolver – Fortran Program"},{"text":"public subroutine IterationSolution(PGrid, UGrid, VGrid, PCell, UCell, VCell, TVar, TraPar, BoomCase, iprint) Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: PGrid type(Grid), intent(in) :: UGrid type(Grid), intent(in) :: VGrid type(Cell), intent(inout) :: PCell type(Cell), intent(inout) :: UCell type(Cell), intent(inout) :: VCell type(Variables), intent(inout) :: TVar type(Particle), intent(inout) :: TraPar type(SolidObject), intent(inout) :: BoomCase integer(kind=it4b), intent(in) :: iprint Contents None","tags":"","loc":"proc/iterationsolution.html","title":"IterationSolution – Fortran Program"},{"text":"private subroutine AdamBasforthCrankNicolson(PGrid, UGrid, VGrid, PCellO, UCellO, VCellO, PCell, UCell, VCell, TVar, UConv, VConv, PConv, Time, Flux_n1, TraPar, BoomCase, itt) Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: PGrid type(Grid), intent(in) :: UGrid type(Grid), intent(in) :: VGrid type(Cell), intent(inout) :: PCellO type(Cell), intent(inout) :: UCellO type(Cell), intent(inout) :: VCellO type(Cell), intent(inout) :: PCell type(Cell), intent(inout) :: UCell type(Cell), intent(inout) :: VCell type(Variables), intent(inout) :: TVar type( SolverConvergence ), intent(out) :: UConv type( SolverConvergence ), intent(out) :: VConv type( SolverConvergence ), intent(out) :: PConv type( SolverTime ), intent(inout) :: Time real(kind=dp), intent(inout), DIMENSION(:,:,:), allocatable :: Flux_n1 type(Particle), intent(inout) :: TraPar type(SolidObject), intent(inout) :: BoomCase integer(kind=it8b), intent(in) :: itt Contents None","tags":"","loc":"proc/adambasforthcranknicolson.html","title":"AdamBasforthCrankNicolson – Fortran Program"},{"text":"private subroutine ComputeTimeStep(UGrid, VGrid, TVar, BoomCase, Time) Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: UGrid type(Grid), intent(in) :: VGrid type(Variables), intent(in) :: TVar type(SolidObject), intent(in) :: BoomCase type( SolverTime ), intent(out) :: Time Contents None","tags":"","loc":"proc/computetimestep.html","title":"ComputeTimeStep – Fortran Program"},{"text":"private subroutine PrintHistory(itt, Time, TNorm, BoomCase) Arguments Type Intent Optional Attributes Name integer(kind=it8b), intent(in) :: itt type( SolverTime ), intent(in) :: Time type( SolverConvergence ), intent(in) :: TNorm type(SolidObject), intent(in) :: BoomCase Contents None","tags":"","loc":"proc/printhistory.html","title":"PrintHistory – Fortran Program"},{"text":"private subroutine InterNewVar(PCellO, UCellO, VCellO, PCell, UCell, VCell, PGrid, TVar, vb) Arguments Type Intent Optional Attributes Name type(Cell), intent(in) :: PCellO type(Cell), intent(in) :: UCellO type(Cell), intent(in) :: VCellO type(Cell), intent(in) :: PCell type(Cell), intent(in) :: UCell type(Cell), intent(in) :: VCell type(Grid), intent(in) :: PGrid type(Variables), intent(inout) :: TVar real(kind=dp), intent(in) :: vb Contents None","tags":"","loc":"proc/internewvar.html","title":"InterNewVar – Fortran Program"},{"text":"private subroutine ReadFileConvergence(filename, Time, TNorm, BoomCase) Arguments Type Intent Optional Attributes Name character(len=80), intent(in) :: filename type( SolverTime ), intent(inout) :: Time type( SolverConvergence ), intent(inout) :: TNorm type(SolidObject), intent(inout) :: BoomCase Contents None","tags":"","loc":"proc/readfileconvergence.html","title":"ReadFileConvergence – Fortran Program"},{"text":"private subroutine PrintWaterHeight(NonTime, I1, I2, I3, I4, PGrid, PCell) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: NonTime integer(kind=it4b), intent(in) :: I1 integer(kind=it4b), intent(in) :: I2 integer(kind=it4b), intent(in) :: I3 integer(kind=it4b), intent(in) :: I4 type(Grid), intent(in) :: PGrid type(Cell), intent(in) :: PCell Contents None","tags":"","loc":"proc/printwaterheight.html","title":"PrintWaterHeight – Fortran Program"},{"text":"private subroutine PrintWaterWave(TimePrint, PGrid, PCell) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: TimePrint type(Grid), intent(in) :: PGrid type(Cell), intent(in) :: PCell Contents None","tags":"","loc":"proc/printwaterwave.html","title":"PrintWaterWave – Fortran Program"},{"text":"private subroutine PrintWaterPressure(NonTime, J1, J2, J3, J4, Var) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: NonTime integer(kind=it4b), intent(in) :: J1 integer(kind=it4b), intent(in) :: J2 integer(kind=it4b), intent(in) :: J3 integer(kind=it4b), intent(in) :: J4 type(Variables), intent(in) :: Var Contents None","tags":"","loc":"proc/printwaterpressure.html","title":"PrintWaterPressure – Fortran Program"},{"text":"private subroutine CopyNewCell(TCellCo, TCellTa) Arguments Type Intent Optional Attributes Name type(Cell), intent(inout) :: TCellCo type(Cell), intent(in) :: TCellTa Contents None","tags":"","loc":"proc/copynewcell.html","title":"CopyNewCell – Fortran Program"},{"text":"private interface IterationSolution Contents Module Procedures IterationSolution Module Procedures private interface IterationSolution () Arguments None","tags":"","loc":"interface/iterationsolution.html","title":"IterationSolution – Fortran Program"},{"text":"VTK_mod.f90 --- VTK data file format Auteur          : Jalel Chergui (LIMSI-CNRS) Jalel.Chergui@limsi.fr Dern. mod. par  : Jalel Chergui (LIMSI-CNRS) Jalel.Chergui@limsi.fr Dern. mod. le   : Wed Sep 16 14:35:06 2009 Uses PrecisionVar Contents Variables s d newline iproc nb_procs Interfaces VTK_write_mesh VTK_write_var Derived Types VTK_file_handle Subroutines handle_error handle_warning handle_info VTK_open_file VTK_write_mesh_2d VTK_write_mesh_3d VTK_write_vector_2d VTK_write_vector_3d VTK_write_scalar_2d VTK_write_scalar_3d VTK_close_file VTK_collect_file Variables Type Visibility Attributes Name Initial integer, private, parameter :: s = selected_real_kind(6) integer, private, parameter :: d = selected_real_kind(12) character(len=1), private, parameter :: newline = achar(10) integer, private :: iproc = 0 integer, private :: nb_procs = 1 Interfaces public interface VTK_write_mesh private subroutine VTK_write_mesh_2d (fd, x, y) Arguments Type Intent Optional Attributes Name type( VTK_file_handle ), intent(inout) :: fd real(kind=dp), intent(in), DIMENSION(:) :: x real(kind=dp), intent(in), DIMENSION(:) :: y private subroutine VTK_write_mesh_3d (fd, x, y, z) Arguments Type Intent Optional Attributes Name type( VTK_file_handle ), intent(inout) :: fd real(kind=dp), intent(in), DIMENSION(:) :: x real(kind=dp), intent(in), DIMENSION(:) :: y real(kind=dp), intent(in), DIMENSION(:) :: z public interface VTK_write_var private subroutine VTK_write_scalar_2d (fd, name, field) Arguments Type Intent Optional Attributes Name type( VTK_file_handle ), intent(in) :: fd character(len=*), intent(in) :: name real(kind=dp), intent(in), DIMENSION(:,:) :: field private subroutine VTK_write_scalar_3d (fd, name, field) Arguments Type Intent Optional Attributes Name type( VTK_file_handle ), intent(in) :: fd character(len=*), intent(in) :: name real(kind=dp), intent(in), DIMENSION(:,:,:) :: field private subroutine VTK_write_vector_2d (fd, name, vx, vy) Arguments Type Intent Optional Attributes Name type( VTK_file_handle ), intent(in) :: fd character(len=*), intent(in) :: name real(kind=dp), intent(in), DIMENSION(:,:) :: vx real(kind=dp), intent(in), DIMENSION(:,:) :: vy private subroutine VTK_write_vector_3d (fd, name, vx, vy, vz) Arguments Type Intent Optional Attributes Name type( VTK_file_handle ), intent(in) :: fd character(len=*), intent(in) :: name real(kind=dp), intent(in), DIMENSION(:,:,:) :: vx real(kind=dp), intent(in), DIMENSION(:,:,:) :: vy real(kind=dp), intent(in), DIMENSION(:,:,:) :: vz Derived Types type, public :: VTK_file_handle Components Type Visibility Attributes Name Initial character(len=80), private :: prefix integer, private :: unit integer, private :: ni integer, private :: nj integer, private :: nk integer, private :: counter = 0 integer, private :: restart = 0 logical, private :: first = .true. Subroutines private subroutine handle_error (name, message) The subroutine is used to print out the error with opening or writting vtk file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name The error message character(len=*), intent(in) :: message The error message private subroutine handle_warning (name, message) The subroutine is used to print out the warning with opening or writting vtk file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name The warning message character(len=*), intent(in) :: message The warning message private subroutine handle_info (name, message) The subroutine is used to print out the information about the opening or writting vtk file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name The info message character(len=*), intent(in) :: message The info message public subroutine VTK_open_file (prefix, proc_rank, num_procs, restart, fd) The subroutine is used to open a .vtk file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: prefix The directory where the output files are stored integer, intent(in), optional :: proc_rank Arguments for MPI integer, intent(in), optional :: num_procs Arguments for MPI integer, intent(in), optional :: restart Arguments for MPI type( VTK_file_handle ), intent(inout) :: fd The private subroutine VTK_write_mesh_2d (fd, x, y) Arguments Type Intent Optional Attributes Name type( VTK_file_handle ), intent(inout) :: fd real(kind=dp), intent(in), DIMENSION(:) :: x real(kind=dp), intent(in), DIMENSION(:) :: y private subroutine VTK_write_mesh_3d (fd, x, y, z) Arguments Type Intent Optional Attributes Name type( VTK_file_handle ), intent(inout) :: fd real(kind=dp), intent(in), DIMENSION(:) :: x real(kind=dp), intent(in), DIMENSION(:) :: y real(kind=dp), intent(in), DIMENSION(:) :: z private subroutine VTK_write_vector_2d (fd, name, vx, vy) Arguments Type Intent Optional Attributes Name type( VTK_file_handle ), intent(in) :: fd character(len=*), intent(in) :: name real(kind=dp), intent(in), DIMENSION(:,:) :: vx real(kind=dp), intent(in), DIMENSION(:,:) :: vy private subroutine VTK_write_vector_3d (fd, name, vx, vy, vz) Arguments Type Intent Optional Attributes Name type( VTK_file_handle ), intent(in) :: fd character(len=*), intent(in) :: name real(kind=dp), intent(in), DIMENSION(:,:,:) :: vx real(kind=dp), intent(in), DIMENSION(:,:,:) :: vy real(kind=dp), intent(in), DIMENSION(:,:,:) :: vz private subroutine VTK_write_scalar_2d (fd, name, field) Arguments Type Intent Optional Attributes Name type( VTK_file_handle ), intent(in) :: fd character(len=*), intent(in) :: name real(kind=dp), intent(in), DIMENSION(:,:) :: field private subroutine VTK_write_scalar_3d (fd, name, field) Arguments Type Intent Optional Attributes Name type( VTK_file_handle ), intent(in) :: fd character(len=*), intent(in) :: name real(kind=dp), intent(in), DIMENSION(:,:,:) :: field public subroutine VTK_close_file (fd) Arguments Type Intent Optional Attributes Name type( VTK_file_handle ), intent(in) :: fd public subroutine VTK_collect_file (fd) Arguments Type Intent Optional Attributes Name type( VTK_file_handle ), intent(inout) :: fd","tags":"","loc":"module/vtk.html","title":"vtk – Fortran Program"},{"text":"The module calculates the pressure and velocities (correction step). lied. Uses PrecisionVar Mesh Clsvof Cutcell StateVariables PredictorUV ProjectionP Particles Contents Interfaces UpdatePUV Subroutines UpdatePUV VariablesInternalCellCondition Interfaces private interface UpdatePUV private interface UpdatePUV () Arguments None Subroutines public subroutine UpdatePUV (UGrid, VGrid, PGrid, PCellO, UCellO, VCellO, PCell, UCell, VCell, TVar, Flux_n1, TraPar, BoomCase, dt, itt) The subroutine computes the flow field parameters in the next time step. Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: UGrid The input grid type(Grid), intent(in) :: VGrid The input grid type(Grid), intent(in) :: PGrid The input grid type(Cell), intent(inout) :: PCellO The input and output cell a previous time step type(Cell), intent(inout) :: UCellO The input and output cell a previous time step type(Cell), intent(inout) :: VCellO The input and output cell a previous time step type(Cell), intent(inout) :: PCell The input and output cell type(Cell), intent(inout) :: UCell The input and output cell type(Cell), intent(inout) :: VCell The input and output cell type(Variables), intent(inout) :: TVar The state variables real(kind=dp), intent(inout), DIMENSION(:,:,:), allocatable :: Flux_n1 The total flux at the previous time step type(Particle), intent(inout) :: TraPar The particle information type(SolidObject), intent(in) :: BoomCase The boom real(kind=dp), intent(in) :: dt The time step integer(kind=it8b), intent(in) :: itt private subroutine VariablesInternalCellCondition (TVar, PCell, UCell, VCell) Arguments Type Intent Optional Attributes Name type(Variables), intent(inout) :: TVar type(Cell), intent(in) :: PCell type(Cell), intent(in) :: UCell type(Cell), intent(in) :: VCell","tags":"","loc":"module/computepuv.html","title":"ComputePUV – Fortran Program"},{"text":"The module provides all information about cut-cell. \n Cells inside the solid will be excluded from computational work. Uses PrecisionVar Mesh StateVariables Contents Interfaces Grid_Preprocess NumberExternalCell NewCellFace Subroutines Grid_Preprocess Cell_Geo_Cal Edge_Geo_Cal NumberExternalCell DefineMomentumExchangeCell NewCellFace EastFaceInterpolationInf NorthFaceInterpolationInf CellLinking Interfaces private interface Grid_Preprocess private interface Grid_Preprocess () Arguments None private interface NumberExternalCell private interface NumberExternalCell () Arguments None private interface NewCellFace private interface NewCellFace () Arguments None Subroutines public subroutine Grid_Preprocess (PGrid, UGrid, VGrid, PCell, UCell, VCell, TVar, itt) The subroutine compute the surface area and define solid cells. Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: PGrid The grid type(Grid), intent(in) :: UGrid The grid type(Grid), intent(in) :: VGrid The grid type(Cell), intent(inout) :: PCell The cell type(Cell), intent(inout) :: UCell The cell type(Cell), intent(inout) :: VCell The cell type(Variables), intent(in) :: TVar The state variables integer(kind=it8b), intent(in) :: itt The number of iterations private subroutine Cell_Geo_Cal (TGrid, TCell) The subroutine computes the surface area for cut cell. Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: TGrid The grid type(Cell), intent(inout) :: TCell The cell private subroutine Edge_Geo_Cal (Pt1, Pt2, nxx, nyy, diss, Edge_Area, Face) Arguments Type Intent Optional Attributes Name type(point), intent(in) :: Pt1 type(point), intent(in) :: Pt2 real(kind=dp), intent(in) :: nxx real(kind=dp), intent(in) :: nyy real(kind=dp), intent(in) :: diss real(kind=dp), intent(out) :: Edge_Area type(point), intent(out) :: Face public subroutine NumberExternalCell (TCell, iu, iv) Arguments Type Intent Optional Attributes Name type(Cell), intent(inout) :: TCell integer(kind=it4b), intent(in) :: iu integer(kind=it4b), intent(in) :: iv private subroutine DefineMomentumExchangeCell (PCell, UCell, VCell) Arguments Type Intent Optional Attributes Name type(Cell), intent(inout) :: PCell type(Cell), intent(inout) :: UCell type(Cell), intent(inout) :: VCell public subroutine NewCellFace (PCell, UCell, VCell, PGrid, UGrid, VGrid) Arguments Type Intent Optional Attributes Name type(Cell), intent(inout) :: PCell type(Cell), intent(inout) :: UCell type(Cell), intent(inout) :: VCell type(Grid), intent(in) :: PGrid type(Grid), intent(in) :: UGrid type(Grid), intent(in) :: VGrid private subroutine EastFaceInterpolationInf (TCell, TGrid, BGrid, iu) Arguments Type Intent Optional Attributes Name type(Cell), intent(inout) :: TCell type(Grid), intent(in) :: TGrid type(Grid), intent(in) :: BGrid integer(kind=it4b), intent(in) :: iu private subroutine NorthFaceInterpolationInf (TCell, TGrid, BGrid, iv) Arguments Type Intent Optional Attributes Name type(Cell), intent(inout) :: TCell type(Grid), intent(in) :: TGrid type(Grid), intent(in) :: BGrid integer(kind=it4b), intent(in) :: iv private subroutine CellLinking (TGrid, TCell, i, j) Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: TGrid type(Cell), intent(inout) :: TCell integer(kind=it4b), intent(in) :: i integer(kind=it4b), intent(in) :: j","tags":"","loc":"module/cutcell.html","title":"Cutcell – Fortran Program"},{"text":"Uses PrecisionVar MPI Contents Variables ibeg jbeg Isize Jsize Interfaces Initial_Grid HYPRE_CreateGrid InitialUVGrid Derived Types Point Grid Cell Subroutines Initial_Grid InitialUVGrid HYPRE_CreateGrid NewtonRaphson Variables Type Visibility Attributes Name Initial integer(kind=it4b), public :: ibeg = 1 integer(kind=it4b), public :: jbeg = 1 integer(kind=it4b), public :: Isize integer(kind=it4b), public :: Jsize Interfaces private interface Initial_Grid private interface Initial_Grid () Arguments None private interface HYPRE_CreateGrid private interface HYPRE_CreateGrid () Arguments None private interface InitialUVGrid private interface InitialUVGrid () Arguments None Derived Types type, public :: Point Components Type Visibility Attributes Name Initial real(kind=dp), public :: x real(kind=dp), public :: y type, public :: Grid Components Type Visibility Attributes Name Initial integer(kind=8), public :: Grid_Id real(kind=dp), public, DIMENSION(:,:), allocatable :: x real(kind=dp), public, DIMENSION(:,:), allocatable :: y real(kind=dp), public, DIMENSION(:,:), allocatable :: dx real(kind=dp), public, DIMENSION(:,:), allocatable :: dy real(kind=dp), public :: Lref type, public :: Cell Components Type Visibility Attributes Name Initial integer(kind=it4b), public, DIMENSION(:,:), allocatable :: PosNu integer(kind=it4b), public, DIMENSION(:,:), allocatable :: MoExCell integer(kind=it4b), public :: ExtCell real(kind=dp), public, DIMENSION(:,:), allocatable :: Vof real(kind=dp), public, DIMENSION(:,:), allocatable :: Phi real(kind=dp), public, DIMENSION(:,:), allocatable :: VofS real(kind=dp), public, DIMENSION(:,:), allocatable :: PhiS real(kind=dp), public, DIMENSION(:,:), allocatable :: nx real(kind=dp), public, DIMENSION(:,:), allocatable :: ny real(kind=dp), public, DIMENSION(:,:), allocatable :: nxS real(kind=dp), public, DIMENSION(:,:), allocatable :: nyS real(kind=dp), public, DIMENSION(:,:), allocatable :: EEdge_Area real(kind=dp), public, DIMENSION(:,:), allocatable :: WEdge_Area real(kind=dp), public, DIMENSION(:,:), allocatable :: NEdge_Area real(kind=dp), public, DIMENSION(:,:), allocatable :: SEdge_Area real(kind=dp), public, DIMENSION(:,:,:), allocatable :: Cell_Cent real(kind=dp), public, DIMENSION(:,:,:), allocatable :: MsCe real(kind=dp), public, DIMENSION(:,:), allocatable :: WlLh real(kind=dp), public, DIMENSION(:,:), allocatable :: delh real(kind=dp), public, DIMENSION(:,:,:), allocatable :: FCE real(kind=dp), public, DIMENSION(:,:,:), allocatable :: FCN real(kind=dp), public, DIMENSION(:,:), allocatable :: EtaE real(kind=dp), public, DIMENSION(:,:), allocatable :: EtaN real(kind=dp), public, DIMENSION(:,:), allocatable :: DAlE real(kind=dp), public, DIMENSION(:,:), allocatable :: DAlN real(kind=dp), public, DIMENSION(:,:), allocatable :: AlE real(kind=dp), public, DIMENSION(:,:), allocatable :: AlN real(kind=dp), public, DIMENSION(:,:), allocatable :: SxE real(kind=dp), public, DIMENSION(:,:), allocatable :: SyN Subroutines public subroutine Initial_Grid (Start_Point, End_Point, ReS, ReE, NI, NJ, Irec, Jrec, TGrid, Lref, NonUniformMesh) Arguments Type Intent Optional Attributes Name type( Point ), intent(in) :: Start_Point type( Point ), intent(in) :: End_Point type( Point ), intent(in) :: ReS type( Point ), intent(in) :: ReE integer(kind=it4b), intent(in) :: NI integer(kind=it4b), intent(in) :: NJ integer(kind=it4b), intent(in) :: Irec integer(kind=it4b), intent(in) :: Jrec type( Grid ), intent(inout) :: TGrid real(kind=dp), intent(in) :: Lref integer(kind=it4b), intent(in) :: NonUniformMesh public subroutine InitialUVGrid (PGrid, TGrid, UV, Lref) Arguments Type Intent Optional Attributes Name type( Grid ), intent(in) :: PGrid type( Grid ), intent(inout) :: TGrid integer(kind=it4b), intent(in) :: UV real(kind=dp), intent(in) :: Lref public subroutine HYPRE_CreateGrid (TGrid) Arguments Type Intent Optional Attributes Name type( Grid ), intent(inout) :: TGrid private subroutine NewtonRaphson (beta, dl, dx, IJsize) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: beta real(kind=dp), intent(in) :: dl real(kind=dp), intent(in) :: dx integer(kind=it4b), intent(in) :: IJsize","tags":"","loc":"module/mesh.html","title":"Mesh – Fortran Program"},{"text":"Uses PrecisionVar MPI Mesh StateVariables Clsvof Contents Variables itp tol Ca Interfaces TrackingParticles InitializeParticels ParticlePosition ParticleInletCondition Drag Derived Types ParVel Particle Functions Drag Subroutines InitializeParticles TrackingParticles ParticlePosition ParticleInletCondition Variables Type Visibility Attributes Name Initial integer(kind=it4b), private, parameter :: itp = 10 real(kind=dp), private, parameter :: tol = 1.d-20 real(kind=dp), private, parameter :: Ca = 0.5d0 Interfaces private interface TrackingParticles private interface TrackingParticles () Arguments None private interface InitializeParticels public subroutine InitializeParticles (PGrid, Var, TraPar) Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: PGrid type(Variables), intent(in) :: Var type( Particle ), intent(inout) :: TraPar private interface ParticlePosition private interface ParticlePosition () Arguments None private interface ParticleInletCondition private interface ParticleInletCondition () Arguments None private interface Drag private interface Drag () Arguments None Derived Types type, private :: ParVel Components Type Visibility Attributes Name Initial real(kind=dp), public :: u real(kind=dp), public :: v type, public :: Particle Components Type Visibility Attributes Name Initial integer(kind=it4b), public :: np type(Point), public, DIMENSION(:), allocatable :: Posp type( ParVel ), public, DIMENSION(:), allocatable :: uvp real(kind=dp), public, DIMENSION(:), allocatable :: mp real(kind=dp), public, DIMENSION(:), allocatable :: dp real(kind=dp), public, DIMENSION(:), allocatable :: tp real(kind=dp), public, DIMENSION(:), allocatable :: t real(kind=dp), public, DIMENSION(:), allocatable :: VrelG real(kind=dp), public, DIMENSION(:), allocatable :: y real(kind=dp), public, DIMENSION(:), allocatable :: dydt Functions public function Drag (Reyp) result(Cd) Arguments Type Intent Optional Attributes Name real(kind=dp) :: Reyp Return Value real(kind=dp) Subroutines public subroutine InitializeParticles (PGrid, Var, TraPar) Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: PGrid type(Variables), intent(in) :: Var type( Particle ), intent(inout) :: TraPar public subroutine TrackingParticles (PGrid, PCell, BoomCase, Var, dt, TraPar) Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: PGrid type(Cell), intent(in) :: PCell type( SolidObject ), intent(inout) :: BoomCase type(Variables), intent(in) :: Var real(kind=dp), intent(in) :: dt type( Particle ), intent(inout) :: TraPar public subroutine ParticlePosition (Posi, TGrid, ii, jj) Arguments Type Intent Optional Attributes Name type(Point), intent(in) :: Posi type(Grid), intent(in) :: TGrid integer(kind=it4b), intent(out) :: ii integer(kind=it4b), intent(out) :: jj public subroutine ParticleInletCondition (PGrid, PCell, TraPar) Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: PGrid type(Cell), intent(in) :: PCell type( Particle ), intent(inout) :: TraPar","tags":"","loc":"module/particles.html","title":"Particles – Fortran Program"},{"text":"The module solves the coupled level set and volume of fluid method. \n Method:\n The interface tracking method is used to solve volume of fluid. \n The level set function is used to compute the normal vector which give a better\n accuracy than using volume fraction. When the new position of interface is \n determined the redistance for level set will be applied. Uses PrecisionVar Mesh Cutcell StateVariables Matrix Contents Variables band_width vofeps tolp TolDeno vfl vflS nxs nys phi phiS nx ny Vset Interfaces Initial_Clsvof Initial_ClsvofUV Coupled_LS_VOF ComputeForceObject SolidVolumeFraction Derived Types SolidObject Functions LagrangePoly isinsiderect Subroutines Initial_Clsvof Initial_ClsVofUV Coupled_LS_VOF Boundary_Condition Boundary_Condition_Vof X_Sweep Y_Sweep Interface_Reconstruct distance frac swap topflux bottomflux rightflux leftflux Redistance Normal_Vector_Irre DistanceFluidCalculate zriddr LiqFuncVol CellGeoCal Boundary_Condition_Vof_Phi ObjectMovement ComputeForceObject SolidVolumeFraction EdgeGeoCalCyl Variables Type Visibility Attributes Name Initial integer, private, parameter :: band_width = 4 The number of layer from the interface for recomputing the level set function real(kind=dp), public, parameter :: vofeps = 1.d-14 The tolerant value for volume of fluid real(kind=dp), public, parameter :: tolp = 1.d-10 The tolerant value for boom case position real(kind=dp), public, parameter :: TolDeno = 1.d-24 The tolerant value for denominator real(kind=dp), private, DIMENSION(:,:), pointer :: vfl The pointer for liquid volume fraction real(kind=dp), private, DIMENSION(:,:), pointer :: vflS The pointer for solid volume fraction real(kind=dp), private, DIMENSION(:,:), pointer :: nxs The normal vector for solid interface real(kind=dp), private, DIMENSION(:,:), pointer :: nys The normal vector for solid interface real(kind=dp), private, DIMENSION(:,:), pointer :: phi The pointer for liquid level set real(kind=dp), private, DIMENSION(:,:), pointer :: phiS The pointer for solid level set real(kind=dp), private, DIMENSION(:,:), allocatable :: nx The pointer for liquid interface real(kind=dp), private, DIMENSION(:,:), allocatable :: ny The pointer for liquid interface real(kind=dp), private, DIMENSION(8,2) :: Vset The vector setup for normal computation Interfaces private interface Initial_Clsvof private interface Initial_Clsvof () Arguments None private interface Initial_ClsvofUV private interface Initial_ClsvofUV () Arguments None private interface Coupled_LS_VOF private interface Coupled_LS_VOF () Arguments None private interface ComputeForceObject private interface ComputeForceObject () Arguments None private interface SolidVolumeFraction private interface SolidVolumeFraction () Arguments None Derived Types type, public :: SolidObject Components Type Visibility Attributes Name Initial type(Point), public :: Posp The object position type(Point), public :: PospO The object previous position real(kind=dp), public :: us The object velocity real(kind=dp), public :: vs The object velocity real(kind=dp), public :: asx The object acceleration real(kind=dp), public :: asy The object acceleration real(kind=dp), public :: Dobj The Boom diameter real(kind=dp), public :: Wobj The Boom width real(kind=dp), public :: Mobj The Boom Weight real(kind=dp), public :: Xbar1 The x position bottom left corner of boom real(kind=dp), public :: Xbar2 The x position bottom right corner of boom real(kind=dp), public :: Ybar The y position bottom of boom real(kind=dp), public :: Lbar The length of boom tail Functions private function LagrangePoly (posi, valu, PosTar) result(ValTar) Arguments Type Intent Optional Attributes Name real(kind=dp) :: posi (4) real(kind=dp) :: valu (4) real(kind=dp) :: PosTar Return Value real(kind=dp) private function isinsiderect (xp, yp, del_x, del_y) result(logic) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: xp real(kind=dp), intent(in) :: yp real(kind=dp), intent(in) :: del_x real(kind=dp), intent(in) :: del_y Return Value logical Subroutines public subroutine Initial_Clsvof (TGrid, TCell, BoomCase) The subroutine computes the initial condition for volume of fluid and \n level set function in the pressure cell. For computing the liquid volume fraction, the intersections between free surface and cell \n edge will be determined first. Then a special method will be \n used to compute the area. Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: TGrid The grid type(Cell), intent(inout), target :: TCell The cell which contains level set, volume of fluid and normal vector type( SolidObject ), intent(in) :: BoomCase The Boom position public subroutine Initial_ClsVofUV (PCell, PGrid, TCell, TGrid, BoomCase, uv) The subroutine computes the initial condition for volume of fluid and \n level set function in velocity cells. The liquid volume fraction in the \n velocity cell is the combination of two half parts of two connecting pressure cells. Arguments Type Intent Optional Attributes Name type(Cell), intent(in) :: PCell The data from pressure cell type(Grid), intent(in) :: PGrid The pressure grid type(Cell), intent(inout) :: TCell The target cell which can be u cell or v cell type(Grid), intent(in) :: TGrid The target grid type( SolidObject ), intent(in) :: BoomCase The Boom position integer(kind=it4b), intent(in) :: uv The parameter to determine the target cell is Ucell or VCell public subroutine Coupled_LS_VOF (PGrid, PCell, UCell, VCell, TVar, BoomCase, NondiT, dt, itt) The subroutine solves the coupling level set and volume of fluid to update \n the new position of interface Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: PGrid The pressure grid type(Cell), intent(inout), target :: PCell The pressure cell type(Cell), intent(in) :: UCell The velocity cell type(Cell), intent(in) :: VCell The velocity cell type(Variables), intent(in) :: TVar The state variables type( SolidObject ), intent(inout) :: BoomCase The Boom position real(kind=dp), intent(in) :: NondiT The time step and nondimensional time real(kind=dp), intent(in) :: dt The time step and nondimensional time integer(kind=it8b), intent(in) :: itt The number of iterations private subroutine Boundary_Condition (vari) Arguments Type Intent Optional Attributes Name real(kind=dp), DIMENSION(:,:) :: vari private subroutine Boundary_Condition_Vof (vari) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), DIMENSION(:,:) :: vari private subroutine X_Sweep (PGrid, PCell, temvf, temls, ue, ve, nx, ny, dis, dtv, itt, UpdateNorVec, NondiT, k) The subroutine compute the advection equation in x direction volume of fluid Arguments Type Intent Optional Attributes Name type(Grid) :: PGrid type(Cell) :: PCell real(kind=dp), DIMENSION(:,:), allocatable :: temvf The temporary volume of fluid and level set real(kind=dp), DIMENSION(:,:), allocatable :: temls The temporary volume of fluid and level set real(kind=dp), intent(in), DIMENSION(:,:), allocatable :: ue The velocity field real(kind=dp), intent(in), DIMENSION(:,:), allocatable :: ve The velocity field real(kind=dp), intent(inout), DIMENSION(:,:), allocatable :: nx The normal vector of interface real(kind=dp), intent(inout), DIMENSION(:,:), allocatable :: ny The normal vector of interface real(kind=dp), intent(inout), DIMENSION(:,:), allocatable :: dis The distance from cell centre to the interface real(kind=dp), intent(in) :: dtv integer(kind=it8b), intent(in) :: itt The iteration number integer(kind=it4b), intent(in) :: UpdateNorVec Option for updating the normal vector real(kind=dp), intent(in) :: NondiT integer(kind=it4b), intent(in) :: k The present sub-step. It is used for inlet boundary condition private subroutine Y_Sweep (PGrid, PCell, temvf, temls, ue, ve, nx, ny, dis, dtv, itt, UpdateNorVec) The subroutine compute the advection equation in y direction Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: PGrid type(Cell), intent(in) :: PCell real(kind=dp), DIMENSION(:,:), allocatable :: temvf real(kind=dp), DIMENSION(:,:), allocatable :: temls real(kind=dp), intent(in), DIMENSION(:,:), allocatable :: ue real(kind=dp), intent(in), DIMENSION(:,:), allocatable :: ve real(kind=dp), intent(inout), DIMENSION(:,:), allocatable :: nx real(kind=dp), intent(inout), DIMENSION(:,:), allocatable :: ny real(kind=dp), intent(inout), DIMENSION(:,:), allocatable :: dis real(kind=dp), intent(in) :: dtv integer(kind=it8b), intent(in) :: itt integer(kind=it4b), intent(in) :: UpdateNorVec private subroutine Interface_Reconstruct (PGrid, nx, ny, dis, UpdateNorVec) The subroutine will compute the interface normal vector and distance from \n the cell center to the interface. Basically, we need all information \n about the equation of a line. Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: PGrid real(kind=dp), intent(inout), DIMENSION(:,:), allocatable :: nx real(kind=dp), intent(inout), DIMENSION(:,:), allocatable :: ny real(kind=dp), intent(inout), DIMENSION(:,:), allocatable :: dis integer(kind=it4b), intent(in) :: UpdateNorVec private subroutine distance (i, j, dx, dy, nxx, nyy, diss) The subroutine will compute the distance from a point to the interface.\n It will compute based on the normal vector and volume of fluid. Arguments Type Intent Optional Attributes Name integer :: i integer :: j real(kind=dp) :: dx real(kind=dp) :: dy real(kind=dp) :: nxx real(kind=dp) :: nyy real(kind=dp) :: diss private subroutine frac (nx, ny, diss, dx, dy, vrt) The subroutine computes the volume of fluid in a cell with height of dy \n and width of dx. Arguments Type Intent Optional Attributes Name real(kind=dp) :: nx real(kind=dp) :: ny real(kind=dp) :: diss real(kind=dp) :: dx real(kind=dp) :: dy real(kind=dp) :: vrt private subroutine swap (a, b) Arguments Type Intent Optional Attributes Name real(kind=dp) :: a real(kind=dp) :: b private subroutine topflux (nxx, nyy, diss, volf, nxss, nyss, phiss, vols, dx, dy, vdt, flux) The subroutine calculate flux through the top of cell Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: nxx real(kind=dp), intent(in) :: nyy real(kind=dp), intent(in) :: diss real(kind=dp), intent(in) :: volf real(kind=dp), intent(in) :: nxss real(kind=dp), intent(in) :: nyss real(kind=dp), intent(in) :: phiss real(kind=dp), intent(in) :: vols real(kind=dp), intent(in) :: dx real(kind=dp), intent(in) :: dy real(kind=dp), intent(in) :: vdt real(kind=dp), intent(out) :: flux private subroutine bottomflux (nxx, nyy, diss, volf, nxss, nyss, phiss, vols, dx, dy, vdt, flux) The subroutine calculates flux through the bottom of cell Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: nxx real(kind=dp), intent(in) :: nyy real(kind=dp), intent(in) :: diss real(kind=dp), intent(in) :: volf real(kind=dp), intent(in) :: nxss real(kind=dp), intent(in) :: nyss real(kind=dp), intent(in) :: phiss real(kind=dp), intent(in) :: vols real(kind=dp), intent(in) :: dx real(kind=dp), intent(in) :: dy real(kind=dp), intent(in) :: vdt real(kind=dp), intent(out) :: flux private subroutine rightflux (nxx, nyy, diss, volf, nxss, nyss, phiss, vols, dx, dy, udt, flux) The subroutine calculates flux through the right of cell Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: nxx real(kind=dp), intent(in) :: nyy real(kind=dp), intent(in) :: diss real(kind=dp), intent(in) :: volf real(kind=dp), intent(in) :: nxss real(kind=dp), intent(in) :: nyss real(kind=dp), intent(in) :: phiss real(kind=dp), intent(in) :: vols real(kind=dp), intent(in) :: dx real(kind=dp), intent(in) :: dy real(kind=dp), intent(in) :: udt real(kind=dp), intent(out) :: flux private subroutine leftflux (nxx, nyy, diss, volf, nxss, nyss, phiss, vols, dx, dy, udt, flux) The subroutine calculates flux throught the left of cell Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: nxx real(kind=dp), intent(in) :: nyy real(kind=dp), intent(in) :: diss real(kind=dp), intent(in) :: volf real(kind=dp), intent(in) :: nxss real(kind=dp), intent(in) :: nyss real(kind=dp), intent(in) :: phiss real(kind=dp), intent(in) :: vols real(kind=dp), intent(in) :: dx real(kind=dp), intent(in) :: dy real(kind=dp), intent(in) :: udt real(kind=dp), intent(out) :: flux private subroutine Redistance (PGrid, nxx1, nyy1, diss1) The subroutine will recompute level set from present interface configuration Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: PGrid real(kind=dp), intent(in), DIMENSION(:,:), allocatable :: nxx1 real(kind=dp), intent(in), DIMENSION(:,:), allocatable :: nyy1 real(kind=dp), intent(in), DIMENSION(:,:), allocatable :: diss1 private subroutine Normal_Vector_Irre (PGrid, i, j, nx, ny) The subroutine computes normal vector based on level set Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: PGrid integer, intent(in) :: i integer, intent(in) :: j real(kind=dp), intent(out) :: nx real(kind=dp), intent(out) :: ny private subroutine DistanceFluidCalculate (nxss, nyss, phiss, nxf, nyf, volf, dx, dy, phif) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: nxss real(kind=dp), intent(in) :: nyss real(kind=dp), intent(in) :: phiss real(kind=dp), intent(in) :: nxf real(kind=dp), intent(in) :: nyf real(kind=dp), intent(in) :: volf real(kind=dp), intent(in) :: dx real(kind=dp), intent(in) :: dy real(kind=dp), intent(inout) :: phif private subroutine zriddr (nxf, nyf, volf, dx, dy, phif, node, x1, x2, tol, ITMAX) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: nxf real(kind=dp), intent(in) :: nyf real(kind=dp), intent(in) :: volf real(kind=dp), intent(in) :: dx real(kind=dp), intent(in) :: dy real(kind=dp), intent(inout) :: phif real(kind=dp), intent(in) :: node (6,2) real(kind=dp), intent(in) :: x1 (2) real(kind=dp), intent(in) :: x2 (2) real(kind=dp), intent(in) :: tol integer(kind=it4b), intent(in) :: ITMAX private subroutine LiqFuncVol (nxf, nyf, volf, dx, dy, node, xf, fvol) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: nxf real(kind=dp), intent(in) :: nyf real(kind=dp), intent(in) :: volf real(kind=dp), intent(in) :: dx real(kind=dp), intent(in) :: dy real(kind=dp), intent(in) :: node (6,2) real(kind=dp), intent(in) :: xf (2) real(kind=dp) :: fvol private subroutine CellGeoCal (nxs, nys, phis, nxl, nyl, phil, dx, dy, vols, volf) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: nxs real(kind=dp), intent(in) :: nys real(kind=dp), intent(in) :: phis real(kind=dp), intent(in) :: nxl real(kind=dp), intent(in) :: nyl real(kind=dp), intent(in) :: phil real(kind=dp), intent(in) :: dx real(kind=dp), intent(in) :: dy real(kind=dp), intent(out) :: vols real(kind=dp), intent(out) :: volf private subroutine Boundary_Condition_Vof_Phi (TGrid, Time) The subroutine computes the volume fraction and the level set at \n the inlet and outlet boundary. The subroutine will be applied for \n the sinusoidal wave. Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: TGrid real(kind=dp), intent(in) :: Time private subroutine ObjectMovement (BoomCase, dtv) The subroutine compute the Boom position and its velocity Arguments Type Intent Optional Attributes Name type( SolidObject ), intent(inout) :: BoomCase real(kind=dp), intent(in) :: dtv public subroutine ComputeForceObject (BoomCase, PGrid, PCell, VCell, TVar, ForceObj) The subroutine calculates the force acting on object Arguments Type Intent Optional Attributes Name type( SolidObject ), intent(inout) :: BoomCase type(Grid), intent(in) :: PGrid type(Cell), intent(in) :: PCell type(Cell), intent(in) :: VCell type(Variables), intent(in) :: TVar real(kind=dp), intent(out) :: ForceObj public subroutine SolidVolumeFraction (TGrid, TCell, BoomCase) The subroutine computes solid volume fraction in the next sub-steps Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: TGrid type(Cell), intent(inout) :: TCell type( SolidObject ), intent(in) :: BoomCase private subroutine EdgeGeoCalCyl (BoomCase, Pt1, Pt2, CutP, ctr) The subroutine calculates the intersection between the interface and \n the cell edges in the case of cylinder. Arguments Type Intent Optional Attributes Name type( SolidObject ), intent(in) :: BoomCase type(point), intent(in) :: Pt1 type(point), intent(in) :: Pt2 type(point), intent(inout), DIMENSION(4) :: CutP integer(kind=it4b), intent(inout) :: ctr","tags":"","loc":"module/clsvof.html","title":"Clsvof – Fortran Program"},{"text":"Uses PrecisionVar Mesh Matrix Contents Variables ight jght ite Start_Point End_Point pi Cp kT kTw g factor Lref Rey Fr wa Ta xc yc UwInlet UgInlet xmax Roref Hw Ha VofInlet nuref IttRun IttBegin RunAgain ICorProb zp UParInlet HParInlet DParInlet rop gx gy NParInlet IParInlet y0 y1 t0 cw0 Amp0 Depthw Lamdaw twp HChannel LChannel kw omew HDomain nuw nua roa row epsi epsiF BetaVis dir Interfaces Initial_Var Boundary_Condition_Var Derived Types Variables Subroutines Initial_Var Boundary_Condition_Var Variables Type Visibility Attributes Name Initial integer(kind=it4b), public :: ight = 1 integer(kind=it4b), public :: jght = 1 integer(kind=it4b), public :: ite type(Point), public :: Start_Point type(Point), public :: End_Point real(kind=dp), public, parameter :: pi = 4.d0*datan(1.d0) real(kind=dp), public, parameter :: Cp = 1.005d3 real(kind=dp), public, parameter :: kT = 0.0271d0 real(kind=dp), public, parameter :: kTw = 0.0271d0 real(kind=dp), public, parameter :: g = 9.81d0 real(kind=dp), public, parameter :: factor = 0.5d0 real(kind=dp), public :: Lref real(kind=dp), public :: Rey real(kind=dp), public :: Fr real(kind=dp), public :: wa real(kind=dp), public :: Ta real(kind=dp), public :: xc real(kind=dp), public :: yc real(kind=dp), public :: UwInlet real(kind=dp), public :: UgInlet real(kind=dp), public :: xmax real(kind=dp), public :: Roref real(kind=dp), public :: Hw real(kind=dp), public :: Ha real(kind=dp), public :: VofInlet real(kind=dp), public :: nuref integer(kind=it8b), public :: IttRun integer(kind=it8b), public :: IttBegin logical, public :: RunAgain logical, public :: ICorProb real(kind=dp), public :: zp real(kind=dp), public :: UParInlet real(kind=dp), public :: HParInlet real(kind=dp), public :: DParInlet real(kind=dp), public :: rop real(kind=dp), public :: gx real(kind=dp), public :: gy integer(kind=it4b), public :: NParInlet integer(kind=it4b), public :: IParInlet real(kind=dp), public :: y0 real(kind=dp), public :: y1 real(kind=dp), public :: t0 real(kind=dp), public :: cw0 real(kind=dp), public :: Amp0 real(kind=dp), public :: Depthw real(kind=dp), public :: Lamdaw real(kind=dp), public :: twp real(kind=dp), public :: HChannel real(kind=dp), public :: LChannel real(kind=dp), public :: kw real(kind=dp), public :: omew real(kind=dp), public :: HDomain real(kind=dp), public, parameter :: nuw = 1.0034d-6 real(kind=dp), public, parameter :: nua = 1.506d-5 real(kind=dp), public, parameter :: roa = 1.225d0 real(kind=dp), public, parameter :: row = 998.2d0 real(kind=dp), public, parameter :: epsi = 1.d-3 real(kind=dp), public, parameter :: epsiF = 1.d-2 real(kind=dp), public, parameter :: BetaVis = 0.5d0 character(len=70), public :: dir Interfaces private interface Initial_Var private interface Initial_Var () Arguments None private interface Boundary_Condition_Var private interface Boundary_Condition_Var () Arguments None Derived Types type, public :: Variables Components Type Visibility Attributes Name Initial real(kind=dp), public, DIMENSION(:,:), allocatable :: u real(kind=dp), public, DIMENSION(:,:), allocatable :: v real(kind=dp), public, DIMENSION(:,:), allocatable :: p real(kind=dp), public, DIMENSION(:,:), allocatable :: t real(kind=dp), public, DIMENSION(:,:), allocatable :: Gpu real(kind=dp), public, DIMENSION(:,:), allocatable :: Gpv real(kind=dp), public, DIMENSION(:,:), allocatable :: ures real(kind=dp), public, DIMENSION(:,:), allocatable :: vres real(kind=dp), public, DIMENSION(:,:), allocatable :: pres real(kind=dp), public, DIMENSION(:,:), allocatable :: mres real(kind=dp), public :: Uint real(kind=dp), public :: Vint real(kind=dp), public :: Pint real(kind=dp), public :: Tint real(kind=dp), public :: Uref real(kind=dp), public :: Roref real(kind=dp), public :: Pref real(kind=dp), public :: Tref Subroutines public subroutine Initial_Var (PCell, PGrid, Vari, Uint, Vint, Pint, Tint, Uref, Tref, Roref, Lref) Arguments Type Intent Optional Attributes Name type(Cell), intent(in) :: PCell type(Grid), intent(in) :: PGrid type( Variables ), intent(inout) :: Vari real(kind=dp), intent(in) :: Uint real(kind=dp), intent(in) :: Vint real(kind=dp), intent(in) :: Pint real(kind=dp), intent(in) :: Tint real(kind=dp), intent(in) :: Uref real(kind=dp), intent(in) :: Tref real(kind=dp), intent(in) :: Roref real(kind=dp), intent(in) :: Lref public subroutine Boundary_Condition_Var (PGrid, PCell, Vari, Time) Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: PGrid type(Cell), intent(in) :: PCell type( Variables ), intent(inout) :: Vari real(kind=dp), intent(in) :: Time","tags":"","loc":"module/statevariables.html","title":"StateVariables – Fortran Program"},{"text":"The module compute the predictor step for velocities\n Method:\n Adam-Bashforth for convective flux and Crank-Nicolson or fully implicit \n for diffusive flux (it is decided by BetaVis). All extra The first order upwind will be applied for convective flux in the first time step.\n Then, high order 3rd MUSCL will be applied. For the cells near solid boundary, \n first order upwind will be applied. The density-based convective will be applied \n for cell containing only liquid and gas.\n The source term will be handled implicitly Uses PrecisionVar Mesh Cutcell Clsvof StateVariables Matrix PrintResult MPI Particles Contents Variables u Uvolf v Vvolf p tol Interfaces Predictor_UV Derived Types Predictor PoissonCoefficient Functions MUSCLLimiter Subroutines Predictor_UV SetBasicSolver SetMatrix SetVectors DeltaGetValues ModifiedConvectiveFlux HighOrderConvectiveFluxForXDir HighOrderConvectiveFluxForYDir FaceDensityFlux DensityBasedConvectiveFlux DiffusiveFlux Mixing_Procedure PredictorVelocityBoundaryCondition frac CellGeoCal Variables Type Visibility Attributes Name Initial real(kind=dp), private, DIMENSION(:,:), pointer :: u real(kind=dp), private, DIMENSION(:,:), pointer :: Uvolf real(kind=dp), private, DIMENSION(:,:), pointer :: v real(kind=dp), private, DIMENSION(:,:), pointer :: Vvolf real(kind=dp), private, DIMENSION(:,:), pointer :: p real(kind=dp), private, parameter :: tol = 1.d-14 Interfaces private interface Predictor_UV private interface Predictor_UV () Arguments None Derived Types type, public :: Predictor Components Type Visibility Attributes Name Initial real(kind=dp), public, DIMENSION(:,:), allocatable :: u real(kind=dp), public, DIMENSION(:,:), allocatable :: v type, public :: PoissonCoefficient Components Type Visibility Attributes Name Initial real(kind=dp), public, DIMENSION(:,:), allocatable :: Dp Functions private function MUSCLLimiter (x, opt, tolim) result(y) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x integer(kind=it4b), intent(in) :: opt real(kind=dp), intent(in) :: tolim Return Value real(kind=dp) Subroutines public subroutine Predictor_UV (PGrid, UGrid, VGrid, PCellO, UCellO, VCellO, PCell, UCell, VCell, TVar, PU, PV, Pred, Flux_n1, TraPar, BoomCase, dt, itt) The subroutine is the predictor step for velocities Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: PGrid The grid type(Grid), intent(in) :: UGrid The grid type(Grid), intent(in) :: VGrid The grid type(Cell), intent(in) :: PCellO The pressure cell at current time step (n) type(Cell), intent(in), target :: UCellO The velocities cell at next time step (n) type(Cell), intent(in), target :: VCellO The velocities cell at next time step (n) type(Cell), intent(in) :: PCell The pressure cell at next time step (n+1) type(Cell), intent(in), target :: UCell The velocities cell at next time step (n+1) type(Cell), intent(in), target :: VCell The velocities cell at next time step (n+1) type(Variables), intent(in), target :: TVar The state variables type( PoissonCoefficient ), intent(inout) :: PU The cofficient for solving Poisson equation type( PoissonCoefficient ), intent(inout) :: PV The cofficient for solving Poisson equation type( Predictor ), intent(inout) :: Pred The predictor velocity real(kind=dp), intent(inout), DIMENSION(:,:,:), allocatable :: Flux_n1 The total flux from the previous time step type(Particle), intent(inout) :: TraPar The particles information type(SolidObject), intent(in) :: BoomCase The Boom real(kind=dp), intent(in) :: dt The time step integer(kind=it8b), intent(in) :: itt The iterations number private subroutine SetBasicSolver (solver, precond) The subroutine set up methods for HYPRE solver Arguments Type Intent Optional Attributes Name integer(kind=8), intent(inout) :: solver integer(kind=8), intent(inout), optional :: precond private subroutine SetMatrix (A, parcsr_A, TGrid, TCell, DifFluxEW, DifFluxNS, EDFluxEW, EDFluxNS, PUV, CWE, CSN, matr, itt, dt, iu, iv) The subroutine set up the matrix for HYPRE Arguments Type Intent Optional Attributes Name integer(kind=8), intent(inout) :: A An ID for matrix integer(kind=8), intent(inout) :: parcsr_A An ID for matrix type(Grid), intent(in) :: TGrid The grid type(Cell), intent(in) :: TCell The cell real(kind=dp), intent(in), DIMENSION(:,:,:), allocatable :: DifFluxEW The diffusive flux coefficient real(kind=dp), intent(in), DIMENSION(:,:,:), allocatable :: DifFluxNS The diffusive flux coefficient real(kind=dp), intent(in), DIMENSION(:,:,:), allocatable :: EDFluxEW The diffusive flux coefficient real(kind=dp), intent(in), DIMENSION(:,:,:), allocatable :: EDFluxNS The diffusive flux coefficient type( PoissonCoefficient ), intent(inout) :: PUV The cofficient from predicted step real(kind=dp), intent(inout), DIMENSION(:,:), allocatable :: CWE The boundary condition real(kind=dp), intent(inout), DIMENSION(:,:), allocatable :: CSN The boundary condition real(kind=dp), intent(inout), DIMENSION(:,:,:), allocatable :: matr The matrix for testing solver integer(kind=it8b), intent(in) :: itt The iteration step real(kind=dp), intent(in) :: dt The time step integer, intent(in) :: iu The input number to determine this subroutine is applied for x or y direction integer, intent(in) :: iv The input number to determine this subroutine is applied for x or y direction private subroutine SetVectors (b, x, par_b, par_x, PGrid, TGrid, TCell, CWE, CSN, IJFlux, rhm, dt, iu, iv) The subroutine set up a right hand side vector for HYPRE solver Arguments Type Intent Optional Attributes Name integer(kind=8), intent(in) :: b The ID for vector integer(kind=8), intent(in) :: x The ID for vector integer(kind=8), intent(in) :: par_b The ID for vector integer(kind=8), intent(in) :: par_x The ID for vector type(Grid), intent(in) :: PGrid The grid type(Grid), intent(in) :: TGrid The grid type(Cell), intent(in) :: TCell The cell real(kind=dp), intent(in), DIMENSION(:,:), allocatable :: CWE The boundary condition real(kind=dp), intent(in), DIMENSION(:,:), allocatable :: CSN The boundary condition real(kind=dp), intent(in), DIMENSION(:,:) :: IJFlux The total flux which is set to be right hand side vector real(kind=dp), intent(inout), DIMENSION(:,:) :: rhm The output right hand side vector which is used for checking solver real(kind=dp), intent(in) :: dt The time step integer, intent(in) :: iu The input number to determine this subroutine is applied for x or y direction integer, intent(in) :: iv The input number to determine this subroutine is applied for x or y direction private subroutine DeltaGetValues (x, TCell, Var, iu, iv) The subroutine get the result for HYPRE Arguments Type Intent Optional Attributes Name integer(kind=8), intent(in) :: x The ID for result vector type(Cell), intent(in) :: TCell The cell real(kind=dp), intent(inout), DIMENSION(:,:), allocatable :: Var The output variable integer, intent(in) :: iu The input number to determine this subroutine is applied for x or y direction integer, intent(in) :: iv The input number to determine this subroutine is applied for x or y direction private subroutine ModifiedConvectiveFlux (PGrid, UGrid, VGrid, PCell, UCell, VCell, flux, vb, idir, jdir) The subroutine computes the convective flux through velocity cell faces. \n The method is first order upwind for whole computational domain except \n the boundary cells, where, central scheme is applied. Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: PGrid The grid type(Grid), intent(in) :: UGrid The grid type(Grid), intent(in) :: VGrid The grid type(Cell), intent(in) :: PCell The cell type(Cell), intent(in) :: UCell The cell type(Cell), intent(in) :: VCell The cell real(kind=dp), intent(inout), DIMENSION(:,:,:), allocatable :: flux The output convective flux real(kind=dp), intent(in) :: vb The boundary velocity integer(kind=it4b), intent(in) :: idir The parameter indicating the subroutine applied for x or y direction integer(kind=it4b), intent(in) :: jdir The parameter indicating the subroutine applied for x or y direction private subroutine HighOrderConvectiveFluxForXDir (PGrid, UGrid, VGrid, UCell, VCell, vb, flux) The subroutine used the MUSCL scheme for computing the covective flux \n in x direction. It is applied for both u and v. The work is based on 'A MUSCL scheme on staggered grids with kinetic-like fluxes\n for the barotropic Euler system', Thierry Goundon, Julie Llobell Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: PGrid The grid type(Grid), intent(in) :: UGrid The grid type(Grid), intent(in) :: VGrid The grid type(Cell), intent(in) :: UCell The cell type(Cell), intent(in) :: VCell The cell real(kind=dp), intent(in) :: vb The boundary velocity real(kind=dp), intent(inout), DIMENSION(:,:,:), allocatable :: flux The output convective flux private subroutine HighOrderConvectiveFluxForYDir (PGrid, UGrid, VGrid, UCell, VCell, vb, flux) The subroutine used the MUSCL scheme for computing the covective flux \n in y direction. It is applied for both u and v. Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: PGrid The grid type(Grid), intent(in) :: UGrid The grid type(Grid), intent(in) :: VGrid The grid type(Cell), intent(in) :: UCell The cell type(Cell), intent(in) :: VCell The cell real(kind=dp), intent(in) :: vb The boundary velocity real(kind=dp), intent(inout), DIMENSION(:,:,:), allocatable :: flux The output convective flux private subroutine FaceDensityFlux (PGrid, UGrid, VGrid, PCell, UCell, VCell, flux, VFlux, vb, dt, idir, jdir) The subroutine compute the mass flux through cell face. \n It also determine the mixture density at cell faces, which is used for computing\n the convective fluxes. Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: PGrid The grid type(Grid), intent(in) :: UGrid The grid type(Grid), intent(in) :: VGrid The grid type(Cell), intent(in) :: PCell The cell type(Cell), intent(in) :: UCell The cell type(Cell), intent(in) :: VCell The cell real(kind=dp), intent(inout), DIMENSION(:,:,:), allocatable :: flux The mass flux real(kind=dp), intent(inout), DIMENSION(:,:,:), allocatable :: VFlux The mixture density at cell faces real(kind=dp), intent(in) :: vb The boundary velocity real(kind=dp), intent(in) :: dt The time step integer(kind=it4b), intent(in) :: idir The parameter indicating the subroutine applied for x or y direction integer(kind=it4b), intent(in) :: jdir The parameter indicating the subroutine applied for x or y direction private subroutine DensityBasedConvectiveFlux (PGrid, UGrid, VGrid, PCell, UCell, VCell, flux, Vflux, vb, idir, jdir) The subroutine computes convective fluxes through cell faces. Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: PGrid The grid type(Grid), intent(in) :: UGrid The grid type(Grid), intent(in) :: VGrid The grid type(Cell), intent(in) :: PCell The cell type(Cell), intent(in) :: UCell The cell type(Cell), intent(in) :: VCell The cell real(kind=dp), intent(inout), DIMENSION(:,:,:), allocatable :: flux The convective flux real(kind=dp), intent(in), DIMENSION(:,:,:), allocatable :: Vflux The mixture density at cell faces real(kind=dp), intent(in) :: vb The boundary velocity integer(kind=it4b), intent(in) :: idir The parameter indicating the subroutine applied for x or y direction integer(kind=it4b), intent(in) :: jdir The parameter indicating the subroutine applied for x or y direction private subroutine DiffusiveFlux (PGrid, UGrid, VGrid, PCell, UCell, VCell, flux, Eflux, ExEFlux, vb, idir, jdir) The subroutine computes the diffusive fluxes and extra correction for diffusive fluxes Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: PGrid The grid type(Grid), intent(in) :: UGrid The grid type(Grid), intent(in) :: VGrid The grid type(Cell), intent(in) :: PCell The cell type(Cell), intent(in) :: UCell The cell type(Cell), intent(in) :: VCell The cell real(kind=dp), intent(inout), DIMENSION(:,:,:), allocatable :: flux The diffusive flux real(kind=dp), intent(inout), DIMENSION(:,:,:), allocatable :: Eflux The extra diffusive flux coefficient real(kind=dp), intent(inout), DIMENSION(:,:,:), allocatable :: ExEFlux The extra diffusive flux which involve boundary velocity real(kind=dp), intent(in) :: vb The boundary velocity integer(kind=it4b), intent(in) :: idir The parameter indicating the subroutine applied for x or y direction integer(kind=it4b), intent(in) :: jdir The parameter indicating the subroutine applied for x or y direction private subroutine Mixing_Procedure (TGrid, TCell, idir, jdir, flux_mix) The subroutine compute the total flux and redistribute it such that the \n resulted flux doesn't cause any problems to small cell. Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: TGrid The grid type(Cell), intent(in) :: TCell The cell integer(kind=it4b), intent(in) :: idir The parameter indicating the subroutine applied for x or y direction integer(kind=it4b), intent(in) :: jdir The parameter indicating the subroutine applied for x or y direction real(kind=dp), intent(inout), DIMENSION(:,:) :: flux_mix The total flux private subroutine PredictorVelocityBoundaryCondition (Pred, TVar) Arguments Type Intent Optional Attributes Name type( Predictor ), intent(inout) :: Pred type(Variables), intent(in) :: TVar private subroutine frac (nx, ny, diss, dx, dy, vrt) Arguments Type Intent Optional Attributes Name real(kind=dp) :: nx real(kind=dp) :: ny real(kind=dp) :: diss real(kind=dp) :: dx real(kind=dp) :: dy real(kind=dp) :: vrt private subroutine CellGeoCal (nxs, nys, phis, nxl, nyl, phil, dx, dy, vols, volf) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: nxs real(kind=dp), intent(in) :: nys real(kind=dp), intent(in) :: phis real(kind=dp), intent(in) :: nxl real(kind=dp), intent(in) :: nyl real(kind=dp), intent(in) :: phil real(kind=dp), intent(in) :: dx real(kind=dp), intent(in) :: dy real(kind=dp), intent(out) :: vols real(kind=dp), intent(out) :: volf","tags":"","loc":"module/predictoruv.html","title":"PredictorUV – Fortran Program"},{"text":"Uses PrecisionVar Contents Functions sech dsech Subroutines inverse Matrixinv Functions public function sech (x) result(y) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x Return Value real(kind=dp) public function dsech (x) result(y) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x Return Value real(kind=dp) Subroutines public subroutine inverse (a, c, n) Arguments Type Intent Optional Attributes Name real(kind=dp) :: a (n,n) real(kind=dp) :: c (n,n) integer :: n public subroutine Matrixinv (a, b, n) Arguments Type Intent Optional Attributes Name double precision :: a (n,n) double precision :: b (n,n) integer :: n","tags":"","loc":"module/matrix.html","title":"Matrix – Fortran Program"},{"text":"Contents Variables ierr num_procs myid Subroutines MPI_Initial Variables Type Visibility Attributes Name Initial integer, public :: ierr integer, public :: num_procs integer, public :: myid Subroutines public subroutine MPI_Initial () Arguments None","tags":"","loc":"module/mpi.html","title":"MPI – Fortran Program"},{"text":"Contents Variables sp dp it1b it2b it4b it8b Variables Type Visibility Attributes Name Initial integer, public, parameter :: sp = selected_real_kind(6, 35) integer, public, parameter :: dp = selected_real_kind(15, 307) integer, public, parameter :: it1b = selected_int_kind(2) integer, public, parameter :: it2b = selected_int_kind(3) integer, public, parameter :: it4b = selected_int_kind(6) integer, public, parameter :: it8b = selected_int_kind(12)","tags":"","loc":"module/precisionvar.html","title":"PrecisionVar – Fortran Program"},{"text":"VTR_mod.f90 --- XML VTR ASCII data file Auteur          : Jalel Chergui (LIMSI-CNRS) Jalel.Chergui@limsi.fr Dern. mod. par  : Jalel Chergui (LIMSI-CNRS) Jalel.Chergui@limsi.fr Dern. mod. le   : Wed Sep 16 14:36:29 2009 Uses PrecisionVar StateVariables Contents Variables s d newline iproc nb_procs Interfaces VTR_write_mesh VTR_write_var Derived Types VTR_file_handle Subroutines handle_error handle_warning handle_info VTR_open_file VTR_write_mesh_2d VTR_write_mesh_3d VTR_write_vector_2d VTR_write_vector_3d VTR_write_scalar_2d VTR_write_scalar_3d VTR_close_file VTR_collect_file Variables Type Visibility Attributes Name Initial integer, private, parameter :: s = selected_real_kind(6) integer, private, parameter :: d = selected_real_kind(12) character(len=1), private, parameter :: newline = achar(10) integer, private :: iproc = 0 integer, private :: nb_procs = 1 Interfaces public interface VTR_write_mesh private subroutine VTR_write_mesh_2d (fd, x, y) Arguments Type Intent Optional Attributes Name type( VTR_file_handle ), intent(inout) :: fd real(kind=dp), intent(in), DIMENSION(:) :: x real(kind=dp), intent(in), DIMENSION(:) :: y private subroutine VTR_write_mesh_3d (fd, x, y, z) Arguments Type Intent Optional Attributes Name type( VTR_file_handle ), intent(inout) :: fd real(kind=dp), intent(in), DIMENSION(:) :: x real(kind=dp), intent(in), DIMENSION(:) :: y real(kind=dp), intent(in), DIMENSION(:) :: z public interface VTR_write_var private subroutine VTR_write_scalar_2d (fd, name, field) Arguments Type Intent Optional Attributes Name type( VTR_file_handle ), intent(in) :: fd character(len=*), intent(in) :: name real(kind=dp), intent(in), DIMENSION(:,:) :: field private subroutine VTR_write_scalar_3d (fd, name, field) Arguments Type Intent Optional Attributes Name type( VTR_file_handle ), intent(in) :: fd character(len=*), intent(in) :: name real(kind=dp), intent(in), DIMENSION(:,:,:) :: field private subroutine VTR_write_vector_2d (fd, name, vx, vy) Arguments Type Intent Optional Attributes Name type( VTR_file_handle ), intent(in) :: fd character(len=*), intent(in) :: name real(kind=dp), intent(in), DIMENSION(:,:) :: vx real(kind=dp), intent(in), DIMENSION(:,:) :: vy private subroutine VTR_write_vector_3d (fd, name, vx, vy, vz) Arguments Type Intent Optional Attributes Name type( VTR_file_handle ), intent(in) :: fd character(len=*), intent(in) :: name real(kind=dp), intent(in), DIMENSION(:,:,:) :: vx real(kind=dp), intent(in), DIMENSION(:,:,:) :: vy real(kind=dp), intent(in), DIMENSION(:,:,:) :: vz Derived Types type, public :: VTR_file_handle Components Type Visibility Attributes Name Initial character(len=80), private :: prefix integer, private :: unit integer, private :: ni integer, private :: nj integer, private :: nk integer, private :: counter = 0 integer, private :: restart = 0 logical, private :: first = .true. Subroutines private subroutine handle_error (name, message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name character(len=*), intent(in) :: message private subroutine handle_warning (name, message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name character(len=*), intent(in) :: message private subroutine handle_info (name, message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name character(len=*), intent(in) :: message public subroutine VTR_open_file (prefix, proc_rank, num_procs, restart, itera, fd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: prefix integer, intent(in), optional :: proc_rank integer, intent(in), optional :: num_procs integer, intent(in), optional :: restart integer(kind=it8b), intent(in), optional :: itera type( VTR_file_handle ), intent(inout) :: fd private subroutine VTR_write_mesh_2d (fd, x, y) Arguments Type Intent Optional Attributes Name type( VTR_file_handle ), intent(inout) :: fd real(kind=dp), intent(in), DIMENSION(:) :: x real(kind=dp), intent(in), DIMENSION(:) :: y private subroutine VTR_write_mesh_3d (fd, x, y, z) Arguments Type Intent Optional Attributes Name type( VTR_file_handle ), intent(inout) :: fd real(kind=dp), intent(in), DIMENSION(:) :: x real(kind=dp), intent(in), DIMENSION(:) :: y real(kind=dp), intent(in), DIMENSION(:) :: z private subroutine VTR_write_vector_2d (fd, name, vx, vy) Arguments Type Intent Optional Attributes Name type( VTR_file_handle ), intent(in) :: fd character(len=*), intent(in) :: name real(kind=dp), intent(in), DIMENSION(:,:) :: vx real(kind=dp), intent(in), DIMENSION(:,:) :: vy private subroutine VTR_write_vector_3d (fd, name, vx, vy, vz) Arguments Type Intent Optional Attributes Name type( VTR_file_handle ), intent(in) :: fd character(len=*), intent(in) :: name real(kind=dp), intent(in), DIMENSION(:,:,:) :: vx real(kind=dp), intent(in), DIMENSION(:,:,:) :: vy real(kind=dp), intent(in), DIMENSION(:,:,:) :: vz private subroutine VTR_write_scalar_2d (fd, name, field) Arguments Type Intent Optional Attributes Name type( VTR_file_handle ), intent(in) :: fd character(len=*), intent(in) :: name real(kind=dp), intent(in), DIMENSION(:,:) :: field private subroutine VTR_write_scalar_3d (fd, name, field) Arguments Type Intent Optional Attributes Name type( VTR_file_handle ), intent(in) :: fd character(len=*), intent(in) :: name real(kind=dp), intent(in), DIMENSION(:,:,:) :: field public subroutine VTR_close_file (fd) Arguments Type Intent Optional Attributes Name type( VTR_file_handle ), intent(inout) :: fd public subroutine VTR_collect_file (fd) Arguments Type Intent Optional Attributes Name type( VTR_file_handle ), intent(inout) :: fd","tags":"","loc":"module/vtr.html","title":"vtr – Fortran Program"},{"text":"Uses PrecisionVar Mesh StateVariables Clsvof Cutcell vtk vtr Particles Contents Variables newline Interfaces Print_Result_Tecplot_PCent Print_Result_Tecplot_UCent Print_Result_Tecplot_VCent Print_Result_VTK_2D ReadOldDataPCell ReadOldDataVelocityCell ReadOldDataParticle Subroutines Print_Result_Tecplot_PCent Print_Result_Tecplot_UCent Print_Result_Tecplot_VCent Print_Result_VTK_2D ReadOldDataPCell ReadOldDataVelocityCell ReadOldDataParticle Variables Type Visibility Attributes Name Initial character(len=1), private, parameter :: newline = achar(10) Interfaces private interface Print_Result_Tecplot_PCent private interface Print_Result_Tecplot_PCent () Arguments None private interface Print_Result_Tecplot_UCent private interface Print_Result_Tecplot_UCent () Arguments None private interface Print_Result_Tecplot_VCent private interface Print_Result_Tecplot_VCent () Arguments None private interface Print_Result_VTK_2D private interface Print_Result_VTK_2D () Arguments None private interface ReadOldDataPCell private interface ReadOldDataPCell () Arguments None private interface ReadOldDataVelocityCell private interface ReadOldDataVelocityCell () Arguments None private interface ReadOldDataParticle private interface ReadOldDataParticle () Arguments None Subroutines public subroutine Print_Result_Tecplot_PCent (TGrid, TVar, TCell, TraPar, FluxP, iter, PriPar) Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: TGrid type( Variables ), intent(inout) :: TVar type(Cell), intent(in) :: TCell type(Particle), intent(in) :: TraPar real(kind=dp), intent(in), DIMENSION(:,:,:), ALLOCATABLE :: FluxP integer(kind=it8b), intent(in) :: iter integer(kind=it4b), intent(in) :: PriPar public subroutine Print_Result_Tecplot_UCent (TGrid, TVar, TCell, itt) Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: TGrid type( Variables ), intent(in) :: TVar type(Cell), intent(in) :: TCell integer(kind=it8b), intent(in) :: itt public subroutine Print_Result_Tecplot_VCent (TGrid, TVar, TCell, itt) Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: TGrid type( Variables ), intent(in) :: TVar type(Cell), intent(in) :: TCell integer(kind=it8b), intent(in) :: itt public subroutine Print_Result_VTK_2D (TGrid, TVar, TCell, itt) Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: TGrid type( Variables ), intent(in) :: TVar type(Cell), intent(in) :: TCell integer(kind=it8b), intent(in) :: itt public subroutine ReadOldDataPCell (filename, TCell, TVar, FluxP) Arguments Type Intent Optional Attributes Name character(len=80), intent(in) :: filename type(Cell), intent(inout) :: TCell type( Variables ), intent(inout) :: TVar real(kind=dp), intent(inout), DIMENSION(:,:,:), ALLOCATABLE :: FluxP public subroutine ReadOldDataVelocityCell (filename, TCell, UVVel) Arguments Type Intent Optional Attributes Name character(len=80), intent(in) :: filename type(Cell), intent(inout) :: TCell real(kind=dp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: UVVel public subroutine ReadOldDataParticle (filename, TraPar, TVar) Arguments Type Intent Optional Attributes Name character(len=80), intent(in) :: filename type(Particle), intent(inout) :: TraPar type( Variables ) :: TVar","tags":"","loc":"module/printresult.html","title":"PrintResult – Fortran Program"},{"text":"Uses PrecisionVar Mesh Cutcell StateVariables PredictorUV MPI Contents Variables p u v amp alp bet PoCoef HJump Interfaces PoissonEquationSolver Derived Types Projection Subroutines PoissonEquationSolver SetBasicSolver SetPoissonMatrix SetPoissonVectors DeltaPressureGetValues ComputePossionMatrixCoefficient DeltaPressureBoundaryCondition Variables Type Visibility Attributes Name Initial real(kind=dp), private, DIMENSION(:,:), POINTER :: p real(kind=dp), private, DIMENSION(:,:), POINTER :: u real(kind=dp), private, DIMENSION(:,:), POINTER :: v real(kind=dp), private, parameter :: amp = 1.d0 real(kind=dp), private, parameter :: alp = 0.4d0 real(kind=dp), private, parameter :: bet = 0.5d0 real(kind=dp), private, DIMENSION(:,:,:), ALLOCATABLE :: PoCoef real(kind=dp), private, DIMENSION(:,:,:), ALLOCATABLE :: HJump Interfaces private interface PoissonEquationSolver private interface PoissonEquationSolver () Arguments None Derived Types type, public :: Projection Components Type Visibility Attributes Name Initial real(kind=dp), public, DIMENSION(:,:), ALLOCATABLE :: Pp Subroutines public subroutine PoissonEquationSolver (PGrid, UGrid, VGrid, PCellO, PCell, UCell, VCell, TVar, TPred, PU, PV, Proj, vb, dt, itt) Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: PGrid type(Grid), intent(in) :: UGrid type(Grid), intent(in) :: VGrid type(Cell), intent(in) :: PCellO type(Cell), intent(in) :: PCell type(Cell), intent(in) :: UCell type(Cell), intent(in) :: VCell type(Variables), intent(in), target :: TVar type(Predictor), intent(in), target :: TPred type(PoissonCoefficient), intent(in) :: PU type(PoissonCoefficient), intent(in) :: PV type( Projection ), intent(inout), target :: Proj real(kind=dp), intent(in) :: vb real(kind=dp), intent(in) :: dt integer(kind=it8b), intent(in) :: itt private subroutine SetBasicSolver (solver, precond) Arguments Type Intent Optional Attributes Name integer(kind=8), intent(inout) :: solver integer(kind=8), intent(inout), optional :: precond private subroutine SetPoissonMatrix (A, parcsr_A, PGrid, PCell, WB, EB, SB, NB, matr, itt) Arguments Type Intent Optional Attributes Name integer(kind=8), intent(inout) :: A integer(kind=8), intent(inout) :: parcsr_A type(Grid), intent(in) :: PGrid type(Cell), intent(in) :: PCell integer(kind=it4b), intent(in) :: WB integer(kind=it4b), intent(in) :: EB integer(kind=it4b), intent(in) :: SB integer(kind=it4b), intent(in) :: NB real(kind=dp), DIMENSION(:,:,:), allocatable :: matr integer(kind=it8b), intent(in) :: itt private subroutine SetPoissonVectors (b, x, par_b, par_x, PGrid, PCellO, PCell, vb, dt, rhm, itt) Arguments Type Intent Optional Attributes Name integer(kind=8) :: b integer(kind=8) :: x integer(kind=8) :: par_b integer(kind=8) :: par_x type(Grid), intent(in) :: PGrid type(Cell), intent(in) :: PCellO type(Cell), intent(in) :: PCell real(kind=dp), intent(in) :: vb real(kind=dp), intent(in) :: dt real(kind=dp), DIMENSION(:,:), allocatable :: rhm integer(kind=it8b), intent(in) :: itt private subroutine DeltaPressureGetValues (x, PCell, Projp) Arguments Type Intent Optional Attributes Name integer(kind=8), intent(in) :: x type(Cell), intent(in) :: PCell type( Projection ), intent(inout) :: Projp private subroutine ComputePossionMatrixCoefficient (PGrid, UGrid, VGrid, PCell, UCell, VCell, PU, PV) Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: PGrid type(Grid), intent(in) :: UGrid type(Grid), intent(in) :: VGrid type(Cell), intent(in) :: PCell type(Cell), intent(in) :: UCell type(Cell), intent(in) :: VCell type(PoissonCoefficient), intent(in) :: PU type(PoissonCoefficient), intent(in) :: PV private subroutine DeltaPressureBoundaryCondition (Proj, WB, EB, SB, NB) Arguments Type Intent Optional Attributes Name type( Projection ), intent(inout) :: Proj integer(kind=it4b), intent(in) :: WB integer(kind=it4b), intent(in) :: EB integer(kind=it4b), intent(in) :: SB integer(kind=it4b), intent(in) :: NB","tags":"","loc":"module/projectionp.html","title":"ProjectionP – Fortran Program"},{"text":"Uses PrecisionVar Mesh StateVariables Cutcell Clsvof PrintResult ComputePUV MPI Particles Contents Variables Twalls Twall tprint xprintex WavePrint Interfaces IterationSolution Derived Types SolverTime SolverConvergence Subroutines IterationSolution AdamBasforthCrankNicolson ComputeTimeStep PrintHistory InterNewVar ReadFileConvergence PrintWaterHeight PrintWaterWave PrintWaterPressure CopyNewCell Variables Type Visibility Attributes Name Initial real(kind=dp), private, parameter :: Twalls = 300.d0 real(kind=dp), private, parameter :: Twall = 400.d0 real(kind=dp), private :: tprint (7) real(kind=dp), private :: xprintex (0:7) integer(kind=it4b), private :: WavePrint Interfaces private interface IterationSolution private interface IterationSolution () Arguments None Derived Types type, public :: SolverTime Components Type Visibility Attributes Name Initial integer(kind=it8b), public :: iter real(kind=dp), public :: cfl real(kind=dp), public :: dt real(kind=dp), public :: PhysT real(kind=dp), public :: NondiT type, public :: SolverConvergence Components Type Visibility Attributes Name Initial real(kind=dp), public :: N1 real(kind=dp), public :: N2 real(kind=dp), public :: NInf real(kind=dp), public :: N1c real(kind=dp), public :: N2c real(kind=dp), public :: NInfc Subroutines public subroutine IterationSolution (PGrid, UGrid, VGrid, PCell, UCell, VCell, TVar, TraPar, BoomCase, iprint) Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: PGrid type(Grid), intent(in) :: UGrid type(Grid), intent(in) :: VGrid type(Cell), intent(inout) :: PCell type(Cell), intent(inout) :: UCell type(Cell), intent(inout) :: VCell type(Variables), intent(inout) :: TVar type(Particle), intent(inout) :: TraPar type(SolidObject), intent(inout) :: BoomCase integer(kind=it4b), intent(in) :: iprint private subroutine AdamBasforthCrankNicolson (PGrid, UGrid, VGrid, PCellO, UCellO, VCellO, PCell, UCell, VCell, TVar, UConv, VConv, PConv, Time, Flux_n1, TraPar, BoomCase, itt) Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: PGrid type(Grid), intent(in) :: UGrid type(Grid), intent(in) :: VGrid type(Cell), intent(inout) :: PCellO type(Cell), intent(inout) :: UCellO type(Cell), intent(inout) :: VCellO type(Cell), intent(inout) :: PCell type(Cell), intent(inout) :: UCell type(Cell), intent(inout) :: VCell type(Variables), intent(inout) :: TVar type( SolverConvergence ), intent(out) :: UConv type( SolverConvergence ), intent(out) :: VConv type( SolverConvergence ), intent(out) :: PConv type( SolverTime ), intent(inout) :: Time real(kind=dp), intent(inout), DIMENSION(:,:,:), allocatable :: Flux_n1 type(Particle), intent(inout) :: TraPar type(SolidObject), intent(inout) :: BoomCase integer(kind=it8b), intent(in) :: itt private subroutine ComputeTimeStep (UGrid, VGrid, TVar, BoomCase, Time) Arguments Type Intent Optional Attributes Name type(Grid), intent(in) :: UGrid type(Grid), intent(in) :: VGrid type(Variables), intent(in) :: TVar type(SolidObject), intent(in) :: BoomCase type( SolverTime ), intent(out) :: Time private subroutine PrintHistory (itt, Time, TNorm, BoomCase) Arguments Type Intent Optional Attributes Name integer(kind=it8b), intent(in) :: itt type( SolverTime ), intent(in) :: Time type( SolverConvergence ), intent(in) :: TNorm type(SolidObject), intent(in) :: BoomCase private subroutine InterNewVar (PCellO, UCellO, VCellO, PCell, UCell, VCell, PGrid, TVar, vb) Arguments Type Intent Optional Attributes Name type(Cell), intent(in) :: PCellO type(Cell), intent(in) :: UCellO type(Cell), intent(in) :: VCellO type(Cell), intent(in) :: PCell type(Cell), intent(in) :: UCell type(Cell), intent(in) :: VCell type(Grid), intent(in) :: PGrid type(Variables), intent(inout) :: TVar real(kind=dp), intent(in) :: vb private subroutine ReadFileConvergence (filename, Time, TNorm, BoomCase) Arguments Type Intent Optional Attributes Name character(len=80), intent(in) :: filename type( SolverTime ), intent(inout) :: Time type( SolverConvergence ), intent(inout) :: TNorm type(SolidObject), intent(inout) :: BoomCase private subroutine PrintWaterHeight (NonTime, I1, I2, I3, I4, PGrid, PCell) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: NonTime integer(kind=it4b), intent(in) :: I1 integer(kind=it4b), intent(in) :: I2 integer(kind=it4b), intent(in) :: I3 integer(kind=it4b), intent(in) :: I4 type(Grid), intent(in) :: PGrid type(Cell), intent(in) :: PCell private subroutine PrintWaterWave (TimePrint, PGrid, PCell) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: TimePrint type(Grid), intent(in) :: PGrid type(Cell), intent(in) :: PCell private subroutine PrintWaterPressure (NonTime, J1, J2, J3, J4, Var) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: NonTime integer(kind=it4b), intent(in) :: J1 integer(kind=it4b), intent(in) :: J2 integer(kind=it4b), intent(in) :: J3 integer(kind=it4b), intent(in) :: J4 type(Variables), intent(in) :: Var private subroutine CopyNewCell (TCellCo, TCellTa) Arguments Type Intent Optional Attributes Name type(Cell), intent(inout) :: TCellCo type(Cell), intent(in) :: TCellTa","tags":"","loc":"module/solver.html","title":"Solver – Fortran Program"},{"text":"Uses PrecisionVar Mesh Cutcell Clsvof StateVariables PrintResult MPI Solver Particles Contents Variables UGrid VGrid PGrid UCell VCell PCell ReS ReE Var TraPar BoomCase Irec Jrec NI NJ iprint vel Uref Vint Variables Type Attributes Name Initial type(Grid) :: UGrid type(Grid) :: VGrid type(Grid) :: PGrid type(Cell) :: UCell type(Cell) :: VCell type(Cell) :: PCell type(Point) :: ReS type(Point) :: ReE type(Variables) :: Var type(Particle) :: TraPar type(SolidObject) :: BoomCase integer(kind=it4b) :: Irec integer(kind=it4b) :: Jrec integer(kind=it4b) :: NI integer(kind=it4b) :: NJ integer(kind=it4b) :: iprint real(kind=dp) :: vel real(kind=dp) :: Uref real(kind=dp) :: Vint","tags":"","loc":"program/main.html","title":"Main – Fortran Program"},{"text":"","tags":"","loc":"page//index.html","title":"README – Fortran Program"},{"text":"The Navier-Stokes equations for two-phase flow are given as follows, \\begin{equation}\n    \\frac{\\partial \\rho\\bf{u}}{{\\partial t}}+\\nabla\\cdot({\\rho \\bf{u}\\bf{u}})=-\\nabla p+\\mu\\nabla&#94;2\\bf{u}+{\\rho\\bf{g}}\n\\end{equation}","tags":"","loc":"page/./Equation.html","title":"Equation – Fortran Program"},{"text":"","tags":"","loc":"page/examples/index.html","title":"Methods – Fortran Program"},{"text":"","tags":"","loc":"page/examples/STL.html","title":"STL Read – Fortran Program"}]}